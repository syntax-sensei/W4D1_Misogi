

---

URL: https://modelcontextprotocol.io/clients

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Examples
Example Clients
User Guide
Introduction
Quickstart
Concepts
Examples
Example Servers
Example Clients
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Examples
Copy page
Example Clients
A list of applications that support MCP integrations
This page provides an overview of applications that support the Model Context Protocol (MCP). Each client may support different MCP features, allowing for varying levels of integration with MCP servers.
​
Feature support matrix
Client
Resources
Prompts
Tools
Discovery
Sampling
Roots
Notes
5ire
❌
❌
✅
❓
❌
❌
Supports tools.
AgentAI
❌
❌
✅
❓
❌
❌
Agent Library written in Rust with tools support
AgenticFlow
✅
✅
✅
✅
❌
❌
Supports tools, prompts, and resources for no-code AI agents and multi-agent workflows.
Amazon Q CLI
❌
✅
✅
❓
❌
❌
Supports prompts and tools.
Apify MCP Tester
❌
❌
✅
✅
❌
❌
Supports remote MCP servers and tool discovery.
Augment Code
❌
❌
✅
❌
❌
❌
Supports tools in local and remote agents.
BeeAI Framework
❌
❌
✅
❌
❌
❌
Supports tools in agentic workflows.
BoltAI
❌
❌
✅
❓
❌
❌
Supports tools.
Claude.ai
✅
✅
✅
❌
❌
❌
Supports tools, prompts, and resources for remote MCP servers.
Claude Code
❌
✅
✅
❌
❌
❌
Supports prompts and tools
Claude Desktop App
✅
✅
✅
❌
❌
❌
Supports tools, prompts, and resources for local and remote MCP servers.
Cline
✅
❌
✅
✅
❌
❌
Supports tools and resources.
Continue
✅
✅
✅
❓
❌
❌
Supports tools, prompts, and resources.
Copilot-MCP
✅
❌
✅
❓
❌
❌
Supports tools and resources.
Cursor
❌
❌
✅
❌
❌
❌
Supports tools.
Daydreams Agents
✅
✅
✅
❌
❌
❌
Support for drop in Servers to Daydreams agents
Emacs Mcp
❌
❌
✅
❌
❌
❌
Supports tools in Emacs.
fast-agent
✅
✅
✅
✅
✅
✅
Full multimodal MCP support, with end-to-end tests
FLUJO
❌
❌
✅
❓
❌
❌
Support for resources, Prompts and Roots are coming soon
Genkit
⚠️
✅
✅
❓
❌
❌
Supports resource list and lookup through tools.
Glama
✅
✅
✅
❓
❌
❌
Supports tools.
GenAIScript
❌
❌
✅
❓
❌
❌
Supports tools.
Goose
❌
❌
✅
❓
❌
❌
Supports tools.
gptme
❌
❌
✅
❓
❌
❌
Supports tools.
HyperAgent
❌
❌
✅
❓
❌
❌
Supports tools.
JetBrains AI Assistant
❌
❌
✅
❌
❌
❌
Supports tools for all JetBrains IDEs.
Klavis AI Slack/Discord/Web
✅
❌
✅
❓
❌
❌
Supports tools and resources.
LibreChat
❌
❌
✅
❓
❌
❌
Supports tools for Agents
Lutra
✅
✅
✅
❓
❌
❌
Supports any MCP server for reusable playbook creation.
mcp-agent
✅
✅
✅
❓
⚠️
✅
Supports tools, prompts, resources, roots, server connection management, and agent workflows.
mcp-use
✅
✅
✅
❓
❌
❌
Support tools, resources, stdio & http connection, local llms-agents.
MCPHub
✅
✅
✅
❓
❌
❌
Supports tools, resources, and prompts in Neovim
MCPOmni-Connect
✅
✅
✅
❓
✅
❌
Supports tools with agentic mode, ReAct, and orchestrator capabilities.
Memex
✅
✅
✅
❓
❌
❌
Support tools. Also support
building and testing
MCP server, all-in-one desktop app.
Microsoft Copilot Studio
❌
❌
✅
❓
❌
❌
Supports tools
MindPal
❌
❌
✅
❓
❌
❌
Supports tools for no-code AI agents and multi-agent workflows.
MooPoint
❌
❌
✅
❓
✅
❌
Web-Hosted client with tool calling support
Msty Studio
❌
❌
✅
❓
❌
❌
Supports tools
NVIDIA Agent Intelligence toolkit
❌
❌
✅
❓
❌
❌
Supports tools in agentic workflows.
OpenSumi
❌
❌
✅
❓
❌
❌
Supports tools in OpenSumi
oterm
❌
✅
✅
❓
✅
❌
Supports tools, prompts and sampling for Ollama.
Postman
✅
✅
✅
❓
❌
❌
Supports tools, resources, prompts, and sampling
Roo Code
✅
❌
✅
❓
❌
❌
Supports tools and resources.
Slack MCP Client
❌
❌
✅
❓
❌
❌
Supports tools and multiple servers.
Sourcegraph Cody
✅
❌
❌
❓
❌
❌
Supports resources through OpenCTX
SpinAI
❌
❌
✅
❓
❌
❌
Supports tools for Typescript AI Agents
Superinterface
❌
❌
✅
❓
❌
❌
Supports tools
Superjoin
❌
❌
✅
❓
❌
❌
Supports tools and multiple servers.
TheiaAI/TheiaIDE
❌
❌
✅
❓
❌
❌
Supports tools for Agents in Theia AI and the AI-powered Theia IDE
Tome
❌
❌
✅
❓
❌
❌
Supports tools, manages MCP servers.
TypingMind App
❌
❌
✅
❓
❌
❌
Supports tools at app-level (appear as plugins) or when assigned to Agents
VS Code GitHub Copilot
✅
✅
✅
✅
✅
✅
Supports dynamic tool/roots discovery, secure secret configuration, and explicit tool prompting
Warp
✅
❌
✅
✅
❌
❌
Supports tools, resources, and most of the discovery criteria
WhatsMCP
❌
❌
✅
❌
❌
❌
Supports tools for Remote MCP Servers in WhatsApp
Windsurf Editor
❌
❌
✅
✅
❌
❌
Supports tools with AI Flow for collaborative development.
Witsy
❌
❌
✅
❓
❌
❌
Supports tools in Witsy.
Zed
❌
✅
❌
❌
❌
❌
Prompts appear as slash commands
Zencoder
❌
❌
✅
❌
❌
❌
Supports tools
​
Client details
​
5ire
5ire
is an open source cross-platform desktop AI assistant that supports tools through MCP servers.
Key features:
Built-in MCP servers can be quickly enabled and disabled.
Users can add more servers by modifying the configuration file.
It is open-source and user-friendly, suitable for beginners.
Future support for MCP will be continuously improved.
​
AgentAI
AgentAI
is a Rust library designed to simplify the creation of AI agents. The library includes seamless integration with MCP Servers.
Example of MCP Server integration
Key features:
Multi-LLM – We support most LLM APIs (OpenAI, Anthropic, Gemini, Ollama, and all OpenAI API Compatible).
Built-in support for MCP Servers.
Create agentic flows in a type- and memory-safe language like Rust.
​
AgenticFlow
AgenticFlow
is a no-code AI platform that helps you build agents that handle sales, marketing, and creative tasks around the clock. Connect 2,500+ APIs and 10,000+ tools securely via MCP.
Key features:
No-code AI agent creation and workflow building.
Access a vast library of 10,000+ tools and 2,500+ APIs through MCP.
Simple 3-step process to connect MCP servers.
Securely manage connections and revoke access anytime.
Learn more:
AgenticFlow MCP Integration
​
Amazon Q CLI
Amazon Q CLI
is an open-source, agentic coding assistant for terminals.
Key features:
Full support for MCP servers.
Edit prompts using your preferred text editor.
Access saved prompts instantly with
@
.
Control and organize AWS resources directly from your terminal.
Tools, profiles, context management, auto-compact, and so much more!
Get Started
Copy
brew
install
amazon-q
​
Apify MCP Tester
Apify MCP Tester
is an open-source client that connects to any MCP server using Server-Sent Events (SSE).
It is a standalone Apify Actor designed for testing MCP servers over SSE, with support for Authorization headers.
It uses plain JavaScript (old-school style) and is hosted on Apify, allowing you to run it without any setup.
Key features:
Connects to any MCP server via SSE.
Works with the
Apify MCP Server
to interact with one or more Apify
Actors
.
Dynamically utilizes tools based on context and user queries (if supported by the server).
​
Augment Code
Augment Code
is an AI-powered coding platform for VS Code and JetBrains with autonomous agents, chat, and completions. Both local and remote agents are backed by full codebase awareness and native support for MCP, enabling enhanced context through external sources and tools.
Key features:
Full MCP support in local and remote agents.
Add additional context through MCP servers.
Automate your development workflows with MCP tools.
Works in VS Code and JetBrains IDEs.
​
BeeAI Framework
BeeAI Framework
is an open-source framework for building, deploying, and serving powerful agentic workflows at scale. The framework includes the
MCP Tool
, a native feature that simplifies the integration of MCP servers into agentic workflows.
Key features:
Seamlessly incorporate MCP tools into agentic workflows.
Quickly instantiate framework-native tools from connected MCP client(s).
Planned future support for agentic MCP capabilities.
Learn more:
Example of using MCP tools in agentic workflow
​
BoltAI
BoltAI
is a native, all-in-one AI chat client with MCP support. BoltAI supports multiple AI providers (OpenAI, Anthropic, Google AI…), including local AI models (via Ollama, LM Studio or LMX)
Key features:
MCP Tool integrations: once configured, user can enable individual MCP server in each chat
MCP quick setup: import configuration from Claude Desktop app or Cursor editor
Invoke MCP tools inside any app with AI Command feature
Integrate with remote MCP servers in the mobile app
Learn more:
BoltAI docs
BoltAI website
​
Claude Code
Claude Code is an interactive agentic coding tool from Anthropic that helps you code faster through natural language commands. It supports MCP integration for prompts and tools, and also functions as an MCP server to integrate with other clients.
Key features:
Tool and prompt support for MCP servers
Offers its own tools through an MCP server for integrating with other MCP clients
​
Claude.ai
Claude.ai
is Anthropic’s web-based AI assistant that provides MCP support for remote servers.
Key features:
Support for remote MCP servers via integrations UI in settings
Access to tools, prompts, and resources from configured MCP servers
Seamless integration with Claude’s conversational interface
Enterprise-grade security and compliance features
​
Claude Desktop App
The Claude desktop application provides comprehensive support for MCP, enabling deep integration with local tools and data sources.
Key features:
Full support for resources, allowing attachment of local files and data
Support for prompt templates
Tool integration for executing commands and scripts
Local server connections for enhanced privacy and security
​
Cline
Cline
is an autonomous coding agent in VS Code that edits files, runs commands, uses a browser, and more–with your permission at each step.
Key features:
Create and add tools through natural language (e.g. “add a tool that searches the web”)
Share custom MCP servers Cline creates with others via the
~/Documents/Cline/MCP
directory
Displays configured MCP servers along with their tools, resources, and any error logs
​
Continue
Continue
is an open-source AI code assistant, with built-in support for all MCP features.
Key features:
Type ”@” to mention MCP resources
Prompt templates surface as slash commands
Use both built-in and MCP tools directly in chat
Supports VS Code and JetBrains IDEs, with any LLM
​
Copilot-MCP
Copilot-MCP
enables AI coding assistance via MCP.
Key features:
Support for MCP tools and resources
Integration with development workflows
Extensible AI capabilities
​
Cursor
Cursor
is an AI code editor.
Key features:
Support for MCP tools in Cursor Composer
Support for both STDIO and SSE
​
Daydreams
Daydreams
is a generative agent framework for executing anything onchain
Key features:
Supports MCP Servers in config
Exposes MCP Client
​
Emacs Mcp
Emacs Mcp
is an Emacs client designed to interface with MCP servers, enabling seamless connections and interactions. It provides MCP tool invocation support for AI plugins like
gptel
and
llm
, adhering to Emacs’ standard tool invocation format. This integration enhances the functionality of AI tools within the Emacs ecosystem.
Key features:
Provides MCP tool support for Emacs.
​
fast-agent
fast-agent
is a Python Agent framework, with simple declarative support for creating Agents and Workflows, with full multi-modal support for Anthropic and OpenAI models.
Key features:
PDF and Image support, based on MCP Native types
Interactive front-end to develop and diagnose Agent applications, including passthrough and playback simulators
Built in support for “Building Effective Agents” workflows.
Deploy Agents as MCP Servers
​
FLUJO
Think n8n + ChatGPT. FLUJO is an desktop application that integrates with MCP to provide a workflow-builder interface for AI interactions. Built with Next.js and React, it supports both online and offline (ollama) models, it manages API Keys and environment variables centrally and can install MCP Servers from GitHub. FLUJO has an ChatCompletions endpoint and flows can be executed from other AI applications like Cline, Roo or Claude.
Key features:
Environment & API Key Management
Model Management
MCP Server Integration
Workflow Orchestration
Chat Interface
​
Genkit
Genkit
is a cross-language SDK for building and integrating GenAI features into applications. The
genkitx-mcp
plugin enables consuming MCP servers as a client or creating MCP servers from Genkit tools and prompts.
Key features:
Client support for tools and prompts (resources partially supported)
Rich discovery with support in Genkit’s Dev UI playground
Seamless interoperability with Genkit’s existing tools and prompts
Works across a wide variety of GenAI models from top providers
​
Glama
Glama
is a comprehensive AI workspace and integration platform that offers a unified interface to leading LLM providers, including OpenAI, Anthropic, and others. It supports the Model Context Protocol (MCP) ecosystem, enabling developers and enterprises to easily discover, build, and manage MCP servers.
Key features:
Integrated
MCP Server Directory
Integrated
MCP Tool Directory
Host MCP servers and access them via the Chat or SSE endpoints
– Ability to chat with multiple LLMs and MCP servers at once
Upload and analyze local files and data
Full-text search across all your chats and data
​
GenAIScript
Programmatically assemble prompts for LLMs using
GenAIScript
(in JavaScript). Orchestrate LLMs, tools, and data in JavaScript.
Key features:
JavaScript toolbox to work with prompts
Abstraction to make it easy and productive
Seamless Visual Studio Code integration
​
Goose
Goose
is an open source AI agent that supercharges your software development by automating coding tasks.
Key features:
Expose MCP functionality to Goose through tools.
MCPs can be installed directly via the
extensions directory
, CLI, or UI.
Goose allows you to extend its functionality by
building your own MCP servers
.
Includes built-in tools for development, web scraping, automation, memory, and integrations with JetBrains and Google Drive.
​
gptme
gptme
is a open-source terminal-based personal AI assistant/agent, designed to assist with programming tasks and general knowledge work.
Key features:
CLI-first design with a focus on simplicity and ease of use
Rich set of built-in tools for shell commands, Python execution, file operations, and web browsing
Local-first approach with support for multiple LLM providers
Open-source, built to be extensible and easy to modify
​
HyperAgent
HyperAgent
is Playwright supercharged with AI. With HyperAgent, you no longer need brittle scripts, just powerful natural language commands. Using MCP servers, you can extend the capability of HyperAgent, without having to write any code.
Key features:
AI Commands: Simple APIs like page.ai(), page.extract() and executeTask() for any AI automation
Fallback to Regular Playwright: Use regular Playwright when AI isn’t needed
Stealth Mode – Avoid detection with built-in anti-bot patches
Cloud Ready – Instantly scale to hundreds of sessions via
Hyperbrowser
MCP Client – Connect to tools like Composio for full workflows (e.g. writing web data to Google Sheets)
​
JetBrains AI Assistant
JetBrains AI Assistant
plugin provides AI-powered features for software development available in all JetBrains IDEs.
Key features:
Unlimited code completion powered by Mellum, JetBrains’ proprietary AI model.
Context-aware AI chat that understands your code and helps you in real time.
Access to top-tier models from OpenAI, Anthropic, and Google.
Offline mode with connected local LLMs via Ollama or LM Studio.
Deep integration into IDE workflows, including code suggestions in the editor, VCS assistance, runtime error explanation, and more.
​
Klavis AI Slack/Discord/Web
Klavis AI
is an Open-Source Infra to Use, Build & Scale MCPs with ease.
Key features:
Slack/Discord/Web MCP clients for using MCPs directly
Simple web UI dashboard for easy MCP configuration
Direct OAuth integration with Slack & Discord Clients and MCP Servers for secure user authentication
SSE transport support
Open-source infrastructure (
GitHub repository
)
Learn more:
Demo video showing MCP usage in Slack/Discord
​
LibreChat
LibreChat
is an open-source, customizable AI chat UI that supports multiple AI providers, now including MCP integration.
Key features:
Extend current tool ecosystem, including
Code Interpreter
and Image generation tools, through MCP servers
Add tools to customizable
Agents
, using a variety of LLMs from top providers
Open-source and self-hostable, with secure multi-user support
Future roadmap includes expanded MCP feature support
​
Lutra
Lutra
is an AI agent that transforms conversations into actionable, automated workflows.
Key features:
Easy MCP Integration: Connecting Lutra to MCP servers is as simple as providing the server URL; Lutra handles the rest behind the scenes.
Chat to Take Action: Lutra understands your conversational context and goals, automatically integrating with your existing apps to perform tasks.
Reusable Playbooks: After completing a task, save the steps as reusable, automated workflows—simplifying repeatable processes and reducing manual effort.
Shareable Automations: Easily share your saved playbooks with teammates to standardize best practices and accelerate collaborative workflows.
Learn more:
Lutra AI agent explained
​
mcp-agent
mcp-agent
is a simple, composable framework to build agents using Model Context Protocol.
Key features:
Automatic connection management of MCP servers.
Expose tools from multiple servers to an LLM.
Implements every pattern defined in
Building Effective Agents
.
Supports workflow pause/resume signals, such as waiting for human feedback.
​
mcp-use
mcp-use
is an open source python library to very easily connect any LLM to any MCP server both locally and remotely.
Key features:
Very simple interface to connect any LLM to any MCP.
Support the creation of custom agents, workflows.
Supports connection to multiple MCP servers simultaneously.
Supports all langchain supported models, also locally.
Offers efficient tool orchestration and search functionalities.
​
MCPHub
MCPHub
is a powerful Neovim plugin that integrates MCP (Model Context Protocol) servers into your workflow.
Key features:
Install, configure and manage MCP servers with an intuitive UI.
Built-in Neovim MCP server with support for file operations (read, write, search, replace), command execution, terminal integration, LSP integration, buffers, and diagnostics.
Create Lua-based MCP servers directly in Neovim.
Inegrates with popular Neovim chat plugins Avante.nvim and CodeCompanion.nvim
​
MCPOmni-Connect
MCPOmni-Connect
is a versatile command-line interface (CLI) client designed to connect to various Model Context Protocol (MCP) servers using both stdio and SSE transport.
Key features:
Support for resources, prompts, tools, and sampling
Agentic mode with ReAct and orchestrator capabilities
Seamless integration with OpenAI models and other LLMs
Dynamic tool and resource management across multiple servers
Support for both stdio and SSE transport protocols
Comprehensive tool orchestration and resource analysis capabilities
​
Memex
Memex
is the first MCP client and MCP server builder - all-in-one desktop app. Unlike traditional MCP clients that only consume existing servers, Memex can create custom MCP servers from natural language prompts, immediately integrate them into its toolkit, and use them to solve problems—all within a single conversation.
Key features:
Prompt-to-MCP Server
: Generate fully functional MCP servers from natural language descriptions
Self-Testing & Debugging
: Autonomously test, debug, and improve created MCP servers
Universal MCP Client
: Works with any MCP server through intuitive, natural language integration
Curated MCP Directory
: Access to tested, one-click installable MCP servers (Neon, Netlify, GitHub, Context7, and more)
Multi-Server Orchestration
: Leverage multiple MCP servers simultaneously for complex workflows
Learn more:
Memex Launch 2: MCP Teams and Agent API
​
Microsoft Copilot Studio
Microsoft Copilot Studio
is a robust SaaS platform designed for building custom AI-driven applications and intelligent agents, empowering developers to create, deploy, and manage sophisticated AI solutions.
Key features:
Support for MCP tools
Extend Copilot Studio agents with MCP servers
Leveraging Microsoft unified, governed, and secure API management solutions
​
MindPal
MindPal
is a no-code platform for building and running AI agents and multi-agent workflows for business processes.
Key features:
Build custom AI agents with no-code
Connect any SSE MCP server to extend agent tools
Create multi-agent workflows for complex business processes
User-friendly for both technical and non-technical professionals
Ongoing development with continuous improvement of MCP support
Learn more:
MindPal MCP Documentation
​
MooPoint
MooPoint
MooPoint is a web-based AI chat platform built for developers and advanced users, letting you interact with multiple large language models (LLMs) through a single, unified interface. Connect your own API keys (OpenAI, Anthropic, and more) and securely manage custom MCP server integrations.
Key features:
Accessible from any PC or smartphone—no installation required
Choose your preferred LLM provider
Supports
SSE
,
Streamable HTTP
,
npx
, and
uvx
MCP servers
OAuth and sampling support
New features added daily
​
Msty Studio
Msty Studio
is a privacy-first AI productivity platform that seamlessly integrates local and online language models (LLMs) into customizable workflows. Designed for both technical and non-technical users, Msty Studio offers a suite of tools to enhance AI interactions, automate tasks, and maintain full control over data and model behavior.
Key features:
Toolbox & Toolsets
: Connect AI models to local tools and scripts using MCP-compliant configurations. Group tools into Toolsets to enable dynamic, multi-step workflows within conversations.
Turnstiles
: Create automated, multi-step AI interactions, allowing for complex data processing and decision-making flows.
Real-Time Data Integration
: Enhance AI responses with up-to-date information by integrating real-time web search capabilities.
Split Chats & Branching
: Engage in parallel conversations with multiple models simultaneously, enabling comparative analysis and diverse perspectives.
Learn more:
Msty Studio Documentation
​
NVIDIA Agent Intelligence (AIQ) toolkit
NVIDIA Agent Intelligence (AIQ) toolkit
is a flexible, lightweight, and unifying library that allows you to easily connect existing enterprise agents to data sources and tools across any framework.
Key features:
Acts as an MCP
client
to consume remote tools
Acts as an MCP
server
to expose tools
Framework agnostic and compatible with LangChain, CrewAI, Semantic Kernel, and custom agents
Includes built-in observability and evaluation tools
Learn more:
AIQ toolkit GitHub repository
AIQ toolkit MCP documentation
​
OpenSumi
OpenSumi
is a framework helps you quickly build AI Native IDE products.
Key features:
Supports MCP tools in OpenSumi
Supports built-in IDE MCP servers and custom MCP servers
​
oterm
oterm
is a terminal client for Ollama allowing users to create chats/agents.
Key features:
Support for multiple fully customizable chat sessions with Ollama connected with tools.
Support for MCP tools.
​
Roo Code
Roo Code
enables AI coding assistance via MCP.
Key features:
Support for MCP tools and resources
Integration with development workflows
Extensible AI capabilities
​
Postman
Postman
is the most popular API client and now supports MCP server testing and debugging.
Key features:
Full support of all major MCP features (tools, prompts, resources, and subscriptions)
Fast, seamless UI for debugging MCP capabilities
MCP config integration (Claude, VSCode, etc.) for fast first-time experience in testing MCPs
Integration with history, variables, and collections for reuse and collaboration
​
Slack MCP Client
Slack MCP Client
acts as a bridge between Slack and Model Context Protocol (MCP) servers. Using Slack as the interface, it enables large language models (LLMs) to connect and interact with various MCP servers through standardized MCP tools.
Key features:
Supports Popular LLM Providers:
Integrates seamlessly with leading large language model providers such as OpenAI, Anthropic, and Ollama, allowing users to leverage advanced conversational AI and orchestration capabilities within Slack.
Dynamic and Secure Integration:
Supports dynamic registration of MCP tools, works in both channels and direct messages and manages credentials securely via environment variables or Kubernetes secrets.
Easy Deployment and Extensibility:
Offers official Docker images, a Helm chart for Kubernetes, and Docker Compose for local development, making it simple to deploy, configure, and extend with additional MCP servers or tools.
​
Sourcegraph Cody
Cody
is Sourcegraph’s AI coding assistant, which implements MCP through OpenCTX.
Key features:
Support for MCP resources
Integration with Sourcegraph’s code intelligence
Uses OpenCTX as an abstraction layer
Future support planned for additional MCP features
​
SpinAI
SpinAI
is an open-source TypeScript framework for building observable AI agents. The framework provides native MCP compatibility, allowing agents to seamlessly integrate with MCP servers and tools.
Key features:
Built-in MCP compatibility for AI agents
Open-source TypeScript framework
Observable agent architecture
Native support for MCP tools integration
​
Superinterface
Superinterface
is AI infrastructure and a developer platform to build in-app AI assistants with support for MCP, interactive components, client-side function calling and more.
Key features:
Use tools from MCP servers in assistants embedded via React components or script tags
SSE transport support
Use any AI model from any AI provider (OpenAI, Anthropic, Ollama, others)
​
Superjoin
Superjoin
brings the power of MCP directly into Google Sheets extension. With Superjoin, users can access and invoke MCP tools and agents without leaving their spreadsheets, enabling powerful AI workflows and automation right where their data lives.
Key features:
Native Google Sheets add-on providing effortless access to MCP capabilities
Supports OAuth 2.1 and header-based authentication for secure and flexible connections
Compatible with both SSE and Streamable HTTP transport for efficient, real-time streaming communication
Fully web-based, cross-platform client requiring no additional software installation
​
TheiaAI/TheiaIDE
Theia AI
is a framework for building AI-enhanced tools and IDEs. The
AI-powered Theia IDE
is an open and flexible development environment built on Theia AI.
Key features:
Tool Integration
: Theia AI enables AI agents, including those in the Theia IDE, to utilize MCP servers for seamless tool interaction.
Customizable Prompts
: The Theia IDE allows users to define and adapt prompts, dynamically integrating MCP servers for tailored workflows.
Custom agents
: The Theia IDE supports creating custom agents that leverage MCP capabilities, enabling users to design dedicated workflows on the fly.
Theia AI and Theia IDE’s MCP integration provide users with flexibility, making them powerful platforms for exploring and adapting MCP.
Learn more:
Theia IDE and Theia AI MCP Announcement
Download the AI-powered Theia IDE
​
Tome
Tome
is an open source cross-platform desktop app designed for working with local LLMs and MCP servers. It is designed to be beginner friendly and abstract away the nitty gritty of configuration for people getting started with MCP.
Key features:
MCP servers are managed by Tome so there is no need to install uv or npm or configure JSON
Users can quickly add or remove MCP servers via UI
Any tool-supported local model on Ollama is compatible
​
TypingMind App
TypingMind
is an advanced frontend for LLMs with MCP support. TypingMind supports all popular LLM providers like OpenAI, Gemini, Claude, and users can use with their own API keys.
Key features:
MCP Tool Integration
: Once MCP is configured, MCP tools will show up as plugins that can be enabled/disabled easily via the main app interface.
Assign MCP Tools to Agents
: TypingMind allows users to create AI agents that have a set of MCP servers assigned.
Remote MCP servers
: Allows users to customize where to run the MCP servers via its MCP Connector configuration, allowing the use of MCP tools across multiple devices (laptop, mobile devices, etc.) or control MCP servers from a remote private server.
Learn more:
TypingMind MCP Document
Download TypingMind (PWA)
​
VS Code GitHub Copilot
VS Code
integrates MCP with GitHub Copilot through
agent mode
, allowing direct interaction with MCP-provided tools within your agentic coding workflow. Configure servers in Claude Desktop, workspace or user settings, with guided MCP installation and secure handling of keys in input variables to avoid leaking hard-coded keys.
Key features:
Support for stdio and server-sent events (SSE) transport
Per-session selection of tools per agent session for optimal performance
Easy server debugging with restart commands and output logging
Tool calls with editable inputs and always-allow toggle
Integration with existing VS Code extension system to register MCP servers from extensions
​
Warp
Warp
is the intelligent terminal with AI and your dev team’s knowledge built-in. With natural language capabilities integrated directly into an agentic command line, Warp enables developers to code, automate, and collaborate more efficiently — all within a terminal that features a modern UX.
Key features:
Agent Mode with MCP support
: invoke tools and access data from MCP servers using natural language prompts
Flexible server management
: add and manage CLI or SSE-based MCP servers via Warp’s built-in UI
Live tool/resource discovery
: view tools and resources from each running MCP server
Configurable startup
: set MCP servers to start automatically with Warp or launch them manually as needed
​
WhatsMCP
WhatsMCP
is an MCP client for WhatsApp. WhatsMCP lets you interact with your AI stack from the comfort of a WhatsApp chat.
Key features:
Supports MCP tools
SSE transport, full OAuth2 support
Chat flow management for WhatsApp messages
One click setup for connecting to your MCP servers
In chat management of MCP servers
Oauth flow natively supported in WhatsApp
​
Windsurf Editor
Windsurf Editor
is an agentic IDE that combines AI assistance with developer workflows. It features an innovative AI Flow system that enables both collaborative and independent AI interactions while maintaining developer control.
Key features:
Revolutionary AI Flow paradigm for human-AI collaboration
Intelligent code generation and understanding
Rich development tools with multi-model support
​
Witsy
Witsy
is an AI desktop assistant, supporting Anthropic models and MCP servers as LLM tools.
Key features:
Multiple MCP servers support
Tool integration for executing commands and scripts
Local server connections for enhanced privacy and security
Easy-install from Smithery.ai
Open-source, available for macOS, Windows and Linux
​
Zed
Zed
is a high-performance code editor with built-in MCP support, focusing on prompt templates and tool integration.
Key features:
Prompt templates surface as slash commands in the editor
Tool integration for enhanced coding workflows
Tight integration with editor features and workspace context
Does not support MCP resources
​
Zencoder
Zencoder
is a coding agent that’s available as an extension for VS Code and JetBrains family of IDEs, meeting developers where they already work. It comes with RepoGrokking (deep contextual codebase understanding), agentic pipeline, and the ability to create and share custom agents.
Key features:
RepoGrokking - deep contextual understanding of codebases
Agentic pipeline - runs, tests, and executes code before outputting it
Zen Agents platform - ability to build and create custom agents and share with the team
Integrated MCP tool library with one-click installations
Specialized agents for Unit and E2E Testing
Learn more:
Zencoder Documentation
​
Adding MCP support to your application
If you’ve added MCP support to your application, we encourage you to submit a pull request to add it to this list. MCP integration can provide your users with powerful contextual AI capabilities and make your application part of the growing MCP ecosystem.
Benefits of adding MCP support:
Enable users to bring their own context and tools
Join a growing ecosystem of interoperable AI applications
Provide users with flexible integration options
Support local-first AI workflows
To get started with implementing MCP in your application, check out our
Python
or
TypeScript SDK Documentation
​
Updates and corrections
This list is maintained by the community. If you notice any inaccuracies or would like to update information about MCP support in your application, please submit a pull request or
open an issue in our documentation repository
.
Was this page helpful?
Yes
No
Example Servers
Building MCP with LLMs
github
On this page
Feature support matrix
Client details
5ire
AgentAI
AgenticFlow
Amazon Q CLI
Apify MCP Tester
Augment Code
BeeAI Framework
BoltAI
Claude Code
Claude.ai
Claude Desktop App
Cline
Continue
Copilot-MCP
Cursor
Daydreams
Emacs Mcp
fast-agent
FLUJO
Genkit
Glama
GenAIScript
Goose
gptme
HyperAgent
JetBrains AI Assistant
Klavis AI Slack/Discord/Web
LibreChat
Lutra
mcp-agent
mcp-use
MCPHub
MCPOmni-Connect
Memex
Microsoft Copilot Studio
MindPal
MooPoint
Msty Studio
NVIDIA Agent Intelligence (AIQ) toolkit
OpenSumi
oterm
Roo Code
Postman
Slack MCP Client
Sourcegraph Cody
SpinAI
Superinterface
Superjoin
TheiaAI/TheiaIDE
Tome
TypingMind App
VS Code GitHub Copilot
Warp
WhatsMCP
Windsurf Editor
Witsy
Zed
Zencoder
Adding MCP support to your application
Updates and corrections
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/development/contributing

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Development
Contributing
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Development
Copy page
Contributing
How to participate in Model Context Protocol development
We welcome contributions from the community! Please review our
contributing guidelines
for details on how to submit changes.
All contributors must adhere to our
Code of Conduct
.
For questions and discussions, please use
GitHub Discussions
.
Was this page helpful?
Yes
No
Roadmap
C# SDK
github
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/development/roadmap

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Development
Roadmap
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Development
Copy page
Roadmap
Our plans for evolving Model Context Protocol
Last updated:
2025-03-27
The Model Context Protocol is rapidly evolving. This page outlines our current thinking on key priorities and direction for approximately
the next six months
, though these may change significantly as the project develops. To see what’s changed recently, check out the
specification changelog
.
The ideas presented here are not commitments—we may solve these challenges differently than described, or some may not materialize at all. This is also not an
exhaustive
list; we may incorporate work that isn’t mentioned here.
We value community participation! Each section links to relevant discussions where you can learn more and contribute your thoughts.
For a technical view of our standardization process, visit the
Standards Track
on GitHub, which tracks how proposals progress toward inclusion in the official
MCP specification
.
​
Validation
To foster a robust developer ecosystem, we plan to invest in:
Reference Client Implementations
: demonstrating protocol features with high-quality AI applications
Compliance Test Suites
: automated verification that clients, servers, and SDKs properly implement the specification
These tools will help developers confidently implement MCP while ensuring consistent behavior across the ecosystem.
​
Registry
For MCP to reach its full potential, we need streamlined ways to distribute and discover MCP servers.
We plan to develop an
MCP Registry
that will enable centralized server discovery and metadata. This registry will primarily function as an API layer that third-party marketplaces and discovery services can build upon.
​
Agents
As MCP increasingly becomes part of agentic workflows, we’re exploring
improvements
such as:
Agent Graphs
: enabling complex agent topologies through namespacing and graph-aware communication patterns
Interactive Workflows
: improving human-in-the-loop experiences with granular permissioning, standardized interaction patterns, and
ways to directly communicate
with the end user
​
Multimodality
Supporting the full spectrum of AI capabilities in MCP, including:
Additional Modalities
: video and other media types
Streaming
: multipart, chunked messages, and bidirectional communication for interactive experiences
​
Governance
We’re implementing governance structures that prioritize:
Community-Led Development
: fostering a collaborative ecosystem where community members and AI developers can all participate in MCP’s evolution, ensuring it serves diverse applications and use cases
Transparent Standardization
: establishing clear processes for contributing to the specification, while exploring formal standardization via industry bodies
​
Get Involved
We welcome your contributions to MCP’s future! Join our
GitHub Discussions
to share ideas, provide feedback, or participate in the development process.
Was this page helpful?
Yes
No
Versioning
Contributing
github
On this page
Validation
Registry
Agents
Multimodality
Governance
Get Involved
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/architecture

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Core architecture
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Core architecture
Understand how MCP connects clients, servers, and LLMs
The Model Context Protocol (MCP) is built on a flexible, extensible architecture that enables seamless communication between LLM applications and integrations. This document covers the core architectural components and concepts.
​
Overview
MCP follows a client-server architecture where:
Hosts
are LLM applications (like Claude Desktop or IDEs) that initiate connections
Clients
maintain 1:1 connections with servers, inside the host application
Servers
provide context, tools, and prompts to clients
​
Core components
​
Protocol layer
The protocol layer handles message framing, request/response linking, and high-level communication patterns.
TypeScript
Python
Copy
class
Protocol
<
Request
,
Notification
,
Result
> {
// Handle incoming requests
setRequestHandler
<
T
>(
schema
:
T
,
handler
:
(
request
:
T
,
extra
:
RequestHandlerExtra
)
=>
Promise
<
Result
>)
:
void
// Handle incoming notifications
setNotificationHandler
<
T
>(
schema
:
T
,
handler
:
(
notification
:
T
)
=>
Promise
<
void
>)
:
void
// Send requests and await responses
request
<
T
>(
request
:
Request
,
schema
:
T
,
options
?:
RequestOptions
)
:
Promise
<
T
>
// Send one-way notifications
notification
(
notification
:
Notification
)
:
Promise
<
void
>
}
Copy
class
Protocol
<
Request
,
Notification
,
Result
> {
// Handle incoming requests
setRequestHandler
<
T
>(
schema
:
T
,
handler
:
(
request
:
T
,
extra
:
RequestHandlerExtra
)
=>
Promise
<
Result
>)
:
void
// Handle incoming notifications
setNotificationHandler
<
T
>(
schema
:
T
,
handler
:
(
notification
:
T
)
=>
Promise
<
void
>)
:
void
// Send requests and await responses
request
<
T
>(
request
:
Request
,
schema
:
T
,
options
?:
RequestOptions
)
:
Promise
<
T
>
// Send one-way notifications
notification
(
notification
:
Notification
)
:
Promise
<
void
>
}
Copy
class
Session
(BaseSession[RequestT, NotificationT, ResultT]):
async
def
send_request
(
self
,
request
: RequestT,
result_type
: type[Result]
) -> Result:
"""Send request and wait for response. Raises McpError if response contains error."""
# Request handling implementation
async
def
send_notification
(
self
,
notification
: NotificationT
) ->
None
:
"""Send one-way notification that doesn't expect response."""
# Notification handling implementation
async
def
_received_request
(
self
,
responder
: RequestResponder[ReceiveRequestT, ResultT]
) ->
None
:
"""Handle incoming request from other side."""
# Request handling implementation
async
def
_received_notification
(
self
,
notification
: ReceiveNotificationT
) ->
None
:
"""Handle incoming notification from other side."""
# Notification handling implementation
Key classes include:
Protocol
Client
Server
​
Transport layer
The transport layer handles the actual communication between clients and servers. MCP supports multiple transport mechanisms:
Stdio transport
Uses standard input/output for communication
Ideal for local processes
Streamable HTTP transport
Uses HTTP with optional Server-Sent Events for streaming
HTTP POST for client-to-server messages
All transports use
JSON-RPC
2.0 to exchange messages. See the
specification
for detailed information about the Model Context Protocol message format.
​
Message types
MCP has these main types of messages:
Requests
expect a response from the other side:
Copy
interface
Request
{
method
:
string
;
params
?:
{
...
};
}
Results
are successful responses to requests:
Copy
interface
Result
{
[
key
:
string
]
:
unknown
;
}
Errors
indicate that a request failed:
Copy
interface
Error
{
code
:
number
;
message
:
string
;
data
?:
unknown
;
}
Notifications
are one-way messages that don’t expect a response:
Copy
interface
Notification
{
method
:
string
;
params
?:
{
...
};
}
​
Connection lifecycle
​
1. Initialization
Client sends
initialize
request with protocol version and capabilities
Server responds with its protocol version and capabilities
Client sends
initialized
notification as acknowledgment
Normal message exchange begins
​
2. Message exchange
After initialization, the following patterns are supported:
Request-Response
: Client or server sends requests, the other responds
Notifications
: Either party sends one-way messages
​
3. Termination
Either party can terminate the connection:
Clean shutdown via
close()
Transport disconnection
Error conditions
​
Error handling
MCP defines these standard error codes:
Copy
enum
ErrorCode
{
// Standard JSON-RPC error codes
ParseError
=
-
32700
,
InvalidRequest
=
-
32600
,
MethodNotFound
=
-
32601
,
InvalidParams
=
-
32602
,
InternalError
=
-
32603
,
}
SDKs and applications can define their own error codes above -32000.
Errors are propagated through:
Error responses to requests
Error events on transports
Protocol-level error handlers
​
Implementation example
Here’s a basic example of implementing an MCP server:
TypeScript
Python
Copy
import
{
Server
}
from
"@modelcontextprotocol/sdk/server/index.js"
;
import
{
StdioServerTransport
}
from
"@modelcontextprotocol/sdk/server/stdio.js"
;
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{
resources:
{}
}
});
// Handle requests
server
.
setRequestHandler
(
ListResourcesRequestSchema
,
async
()
=>
{
return
{
resources:
[
{
uri:
"example://resource"
,
name:
"Example Resource"
}
]
};
});
// Connect transport
const
transport
=
new
StdioServerTransport
();
await
server
.
connect
(
transport
);
Copy
import
{
Server
}
from
"@modelcontextprotocol/sdk/server/index.js"
;
import
{
StdioServerTransport
}
from
"@modelcontextprotocol/sdk/server/stdio.js"
;
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{
resources:
{}
}
});
// Handle requests
server
.
setRequestHandler
(
ListResourcesRequestSchema
,
async
()
=>
{
return
{
resources:
[
{
uri:
"example://resource"
,
name:
"Example Resource"
}
]
};
});
// Connect transport
const
transport
=
new
StdioServerTransport
();
await
server
.
connect
(
transport
);
Copy
import
asyncio
import
mcp.types
as
types
from
mcp.server
import
Server
from
mcp.server.stdio
import
stdio_server
app
=
Server(
"example-server"
)
@app.list_resources
()
async
def
list_resources
() -> list[types.Resource]:
return
[
types.Resource(
uri
=
"example://resource"
,
name
=
"Example Resource"
)
]
async
def
main
():
async
with
stdio_server()
as
streams:
await
app.run(
streams[
0
],
streams[
1
],
app.create_initialization_options()
)
if
__name__
==
"__main__"
:
asyncio.run(main())
​
Best practices
​
Transport selection
Local communication
Use stdio transport for local processes
Efficient for same-machine communication
Simple process management
Remote communication
Use Streamable HTTP for scenarios requiring HTTP compatibility
Consider security implications including authentication and authorization
​
Message handling
Request processing
Validate inputs thoroughly
Use type-safe schemas
Handle errors gracefully
Implement timeouts
Progress reporting
Use progress tokens for long operations
Report progress incrementally
Include total progress when known
Error management
Use appropriate error codes
Include helpful error messages
Clean up resources on errors
​
Security considerations
Transport security
Use TLS for remote connections
Validate connection origins
Implement authentication when needed
Message validation
Validate all incoming messages
Sanitize inputs
Check message size limits
Verify JSON-RPC format
Resource protection
Implement access controls
Validate resource paths
Monitor resource usage
Rate limit requests
Error handling
Don’t leak sensitive information
Log security-relevant errors
Implement proper cleanup
Handle DoS scenarios
​
Debugging and monitoring
Logging
Log protocol events
Track message flow
Monitor performance
Record errors
Diagnostics
Implement health checks
Monitor connection state
Track resource usage
Profile performance
Testing
Test different transports
Verify error handling
Check edge cases
Load test servers
Was this page helpful?
Yes
No
For Claude Desktop Users
Resources
github
On this page
Overview
Core components
Protocol layer
Transport layer
Message types
Connection lifecycle
1. Initialization
2. Message exchange
3. Termination
Error handling
Implementation example
Best practices
Transport selection
Message handling
Security considerations
Debugging and monitoring
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/prompts

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Prompts
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Prompts
Create reusable prompt templates and workflows
Prompts enable servers to define reusable prompt templates and workflows that clients can easily surface to users and LLMs. They provide a powerful way to standardize and share common LLM interactions.
Prompts are designed to be
user-controlled
, meaning they are exposed from servers to clients with the intention of the user being able to explicitly select them for use.
​
Overview
Prompts in MCP are predefined templates that can:
Accept dynamic arguments
Include context from resources
Chain multiple interactions
Guide specific workflows
Surface as UI elements (like slash commands)
​
Prompt structure
Each prompt is defined with:
Copy
{
name
:
string
;
// Unique identifier for the prompt
description
?:
string
;
// Human-readable description
arguments
?:
[
// Optional list of arguments
{
name:
string
;
// Argument identifier
description
?:
string
;
// Argument description
required
?:
boolean
;
// Whether argument is required
}
]
}
​
Discovering prompts
Clients can discover available prompts by sending a
prompts/list
request:
Copy
// Request
{
method
:
"prompts/list"
;
}
// Response
{
prompts
: [
{
name:
"analyze-code"
,
description:
"Analyze code for potential improvements"
,
arguments:
[
{
name:
"language"
,
description:
"Programming language"
,
required:
true
,
},
],
},
];
}
​
Using prompts
To use a prompt, clients make a
prompts/get
request:
Copy
// Request
{
method
:
"prompts/get"
,
params
: {
name
:
"analyze-code"
,
arguments
: {
language
:
"python"
}
}
}
// Response
{
description
:
"Analyze Python code for potential improvements"
,
messages
: [
{
role:
"user"
,
content:
{
type:
"text"
,
text:
"Please analyze the following Python code for potential improvements:
\n\n
```python
\n
def calculate_sum(numbers):
\n
total = 0
\n
for num in numbers:
\n
total = total + num
\n
return total
\n\n
result = calculate_sum([1, 2, 3, 4, 5])
\n
print(result)
\n
```"
}
}
]
}
​
Dynamic prompts
Prompts can be dynamic and include:
​
Embedded resource context
Copy
{
"name"
:
"analyze-project"
,
"description"
:
"Analyze project logs and code"
,
"arguments"
: [
{
"name"
:
"timeframe"
,
"description"
:
"Time period to analyze logs"
,
"required"
:
true
},
{
"name"
:
"fileUri"
,
"description"
:
"URI of code file to review"
,
"required"
:
true
}
]
}
When handling the
prompts/get
request:
Copy
{
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"Analyze these system logs and the code file for any issues:"
}
},
{
"role"
:
"user"
,
"content"
: {
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"logs://recent?timeframe=1h"
,
"text"
:
"[2024-03-14 15:32:11] ERROR: Connection timeout in network.py:127
\n
[2024-03-14 15:32:15] WARN: Retrying connection (attempt 2/3)
\n
[2024-03-14 15:32:20] ERROR: Max retries exceeded"
,
"mimeType"
:
"text/plain"
}
}
},
{
"role"
:
"user"
,
"content"
: {
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"file:///path/to/code.py"
,
"text"
:
"def connect_to_service(timeout=30):
\n
retries = 3
\n
for attempt in range(retries):
\n
try:
\n
return establish_connection(timeout)
\n
except TimeoutError:
\n
if attempt == retries - 1:
\n
raise
\n
time.sleep(5)
\n\n
def establish_connection(timeout):
\n
# Connection implementation
\n
pass"
,
"mimeType"
:
"text/x-python"
}
}
}
]
}
​
Multi-step workflows
Copy
const
debugWorkflow
=
{
name:
"debug-error"
,
async
getMessages
(
error
:
string
) {
return
[
{
role:
"user"
,
content:
{
type:
"text"
,
text:
`Here's an error I'm seeing:
${
error
}
`
,
},
},
{
role:
"assistant"
,
content:
{
type:
"text"
,
text:
"I'll help analyze this error. What have you tried so far?"
,
},
},
{
role:
"user"
,
content:
{
type:
"text"
,
text:
"I've tried restarting the service, but the error persists."
,
},
},
];
},
};
​
Example implementation
Here’s a complete example of implementing prompts in an MCP server:
TypeScript
Python
Copy
import
{
Server
}
from
"@modelcontextprotocol/sdk/server"
;
import
{
ListPromptsRequestSchema
,
GetPromptRequestSchema
}
from
"@modelcontextprotocol/sdk/types"
;
const
PROMPTS
=
{
"git-commit"
:
{
name:
"git-commit"
,
description:
"Generate a Git commit message"
,
arguments:
[
{
name:
"changes"
,
description:
"Git diff or description of changes"
,
required:
true
}
]
},
"explain-code"
:
{
name:
"explain-code"
,
description:
"Explain how code works"
,
arguments:
[
{
name:
"code"
,
description:
"Code to explain"
,
required:
true
},
{
name:
"language"
,
description:
"Programming language"
,
required:
false
}
]
}
};
const
server
=
new
Server
({
name:
"example-prompts-server"
,
version:
"1.0.0"
}, {
capabilities:
{
prompts:
{}
}
});
// List available prompts
server
.
setRequestHandler
(
ListPromptsRequestSchema
,
async
()
=>
{
return
{
prompts:
Object
.
values
(
PROMPTS
)
};
});
// Get specific prompt
server
.
setRequestHandler
(
GetPromptRequestSchema
,
async
(
request
)
=>
{
const
prompt
=
PROMPTS
[
request
.
params
.
name
];
if
(
!
prompt
) {
throw
new
Error
(
`Prompt not found:
${
request
.
params
.
name
}
`
);
}
if
(
request
.
params
.
name
===
"git-commit"
) {
return
{
messages:
[
{
role:
"user"
,
content:
{
type:
"text"
,
text:
`Generate a concise but descriptive commit message for these changes:
\n\n
${
request
.
params
.
arguments
?.
changes
}
`
}
}
]
};
}
if
(
request
.
params
.
name
===
"explain-code"
) {
const
language
=
request
.
params
.
arguments
?.
language
||
"Unknown"
;
return
{
messages:
[
{
role:
"user"
,
content:
{
type:
"text"
,
text:
`Explain how this
${
language
}
code works:
\n\n
${
request
.
params
.
arguments
?.
code
}
`
}
}
]
};
}
throw
new
Error
(
"Prompt implementation not found"
);
});
Copy
import
{
Server
}
from
"@modelcontextprotocol/sdk/server"
;
import
{
ListPromptsRequestSchema
,
GetPromptRequestSchema
}
from
"@modelcontextprotocol/sdk/types"
;
const
PROMPTS
=
{
"git-commit"
:
{
name:
"git-commit"
,
description:
"Generate a Git commit message"
,
arguments:
[
{
name:
"changes"
,
description:
"Git diff or description of changes"
,
required:
true
}
]
},
"explain-code"
:
{
name:
"explain-code"
,
description:
"Explain how code works"
,
arguments:
[
{
name:
"code"
,
description:
"Code to explain"
,
required:
true
},
{
name:
"language"
,
description:
"Programming language"
,
required:
false
}
]
}
};
const
server
=
new
Server
({
name:
"example-prompts-server"
,
version:
"1.0.0"
}, {
capabilities:
{
prompts:
{}
}
});
// List available prompts
server
.
setRequestHandler
(
ListPromptsRequestSchema
,
async
()
=>
{
return
{
prompts:
Object
.
values
(
PROMPTS
)
};
});
// Get specific prompt
server
.
setRequestHandler
(
GetPromptRequestSchema
,
async
(
request
)
=>
{
const
prompt
=
PROMPTS
[
request
.
params
.
name
];
if
(
!
prompt
) {
throw
new
Error
(
`Prompt not found:
${
request
.
params
.
name
}
`
);
}
if
(
request
.
params
.
name
===
"git-commit"
) {
return
{
messages:
[
{
role:
"user"
,
content:
{
type:
"text"
,
text:
`Generate a concise but descriptive commit message for these changes:
\n\n
${
request
.
params
.
arguments
?.
changes
}
`
}
}
]
};
}
if
(
request
.
params
.
name
===
"explain-code"
) {
const
language
=
request
.
params
.
arguments
?.
language
||
"Unknown"
;
return
{
messages:
[
{
role:
"user"
,
content:
{
type:
"text"
,
text:
`Explain how this
${
language
}
code works:
\n\n
${
request
.
params
.
arguments
?.
code
}
`
}
}
]
};
}
throw
new
Error
(
"Prompt implementation not found"
);
});
Copy
from
mcp.server
import
Server
import
mcp.types
as
types
# Define available prompts
PROMPTS
=
{
"git-commit"
: types.Prompt(
name
=
"git-commit"
,
description
=
"Generate a Git commit message"
,
arguments
=
[
types.PromptArgument(
name
=
"changes"
,
description
=
"Git diff or description of changes"
,
required
=
True
)
],
),
"explain-code"
: types.Prompt(
name
=
"explain-code"
,
description
=
"Explain how code works"
,
arguments
=
[
types.PromptArgument(
name
=
"code"
,
description
=
"Code to explain"
,
required
=
True
),
types.PromptArgument(
name
=
"language"
,
description
=
"Programming language"
,
required
=
False
)
],
)
}
# Initialize server
app
=
Server(
"example-prompts-server"
)
@app.list_prompts
()
async
def
list_prompts
() -> list[types.Prompt]:
return
list
(
PROMPTS
.values())
@app.get_prompt
()
async
def
get_prompt
(
name
:
str
,
arguments
: dict[
str
,
str
]
|
None
=
None
) -> types.GetPromptResult:
if
name
not
in
PROMPTS
:
raise
ValueError
(
f
"Prompt not found:
{
name
}
"
)
if
name
==
"git-commit"
:
changes
=
arguments.get(
"changes"
)
if
arguments
else
""
return
types.GetPromptResult(
messages
=
[
types.PromptMessage(
role
=
"user"
,
content
=
types.TextContent(
type
=
"text"
,
text
=
f
"Generate a concise but descriptive commit message "
f
"for these changes:
\n\n
{
changes
}
"
)
)
]
)
if
name
==
"explain-code"
:
code
=
arguments.get(
"code"
)
if
arguments
else
""
language
=
arguments.get(
"language"
,
"Unknown"
)
if
arguments
else
"Unknown"
return
types.GetPromptResult(
messages
=
[
types.PromptMessage(
role
=
"user"
,
content
=
types.TextContent(
type
=
"text"
,
text
=
f
"Explain how this
{
language
}
code works:
\n\n
{
code
}
"
)
)
]
)
raise
ValueError
(
"Prompt implementation not found"
)
​
Best practices
When implementing prompts:
Use clear, descriptive prompt names
Provide detailed descriptions for prompts and arguments
Validate all required arguments
Handle missing arguments gracefully
Consider versioning for prompt templates
Cache dynamic content when appropriate
Implement error handling
Document expected argument formats
Consider prompt composability
Test prompts with various inputs
​
UI integration
Prompts can be surfaced in client UIs as:
Slash commands
Quick actions
Context menu items
Command palette entries
Guided workflows
Interactive forms
​
Updates and changes
Servers can notify clients about prompt changes:
Server capability:
prompts.listChanged
Notification:
notifications/prompts/list_changed
Client re-fetches prompt list
​
Security considerations
When implementing prompts:
Validate all arguments
Sanitize user input
Consider rate limiting
Implement access controls
Audit prompt usage
Handle sensitive data appropriately
Validate generated content
Implement timeouts
Consider prompt injection risks
Document security requirements
Was this page helpful?
Yes
No
Resources
Tools
github
On this page
Overview
Prompt structure
Discovering prompts
Using prompts
Dynamic prompts
Embedded resource context
Multi-step workflows
Example implementation
Best practices
UI integration
Updates and changes
Security considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/resources

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Resources
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Resources
Expose data and content from your servers to LLMs
Resources are a core primitive in the Model Context Protocol (MCP) that allow servers to expose data and content that can be read by clients and used as context for LLM interactions.
Resources are designed to be
application-controlled
, meaning that the client application can decide how and when they should be used.
Different MCP clients may handle resources differently. For example:
Claude Desktop currently requires users to explicitly select resources before they can be used
Other clients might automatically select resources based on heuristics
Some implementations may even allow the AI model itself to determine which resources to use
Server authors should be prepared to handle any of these interaction patterns when implementing resource support. In order to expose data to models automatically, server authors should use a
model-controlled
primitive such as
Tools
.
​
Overview
Resources represent any kind of data that an MCP server wants to make available to clients. This can include:
File contents
Database records
API responses
Live system data
Screenshots and images
Log files
And more
Each resource is identified by a unique URI and can contain either text or binary data.
​
Resource URIs
Resources are identified using URIs that follow this format:
Copy
[protocol]://[host]/[path]
For example:
file:///home/user/documents/report.pdf
postgres://database/customers/schema
screen://localhost/display1
The protocol and path structure is defined by the MCP server implementation. Servers can define their own custom URI schemes.
​
Resource types
Resources can contain two types of content:
​
Text resources
Text resources contain UTF-8 encoded text data. These are suitable for:
Source code
Configuration files
Log files
JSON/XML data
Plain text
​
Binary resources
Binary resources contain raw binary data encoded in base64. These are suitable for:
Images
PDFs
Audio files
Video files
Other non-text formats
​
Resource discovery
Clients can discover available resources through two main methods:
​
Direct resources
Servers expose a list of resources via the
resources/list
request. Each resource includes:
Copy
{
uri
:
string
;
// Unique identifier for the resource
name
:
string
;
// Human-readable name
description
?:
string
;
// Optional description
mimeType
?:
string
;
// Optional MIME type
size
?:
number
;
// Optional size in bytes
}
​
Resource templates
For dynamic resources, servers can expose
URI templates
that clients can use to construct valid resource URIs:
Copy
{
uriTemplate
:
string
;
// URI template following RFC 6570
name
:
string
;
// Human-readable name for this type
description
?:
string
;
// Optional description
mimeType
?:
string
;
// Optional MIME type for all matching resources
}
​
Reading resources
To read a resource, clients make a
resources/read
request with the resource URI.
The server responds with a list of resource contents:
Copy
{
contents
: [
{
uri:
string
;
// The URI of the resource
mimeType
?:
string
;
// Optional MIME type
// One of:
text
?:
string
;
// For text resources
blob
?:
string
;
// For binary resources (base64 encoded)
}
]
}
Servers may return multiple resources in response to one
resources/read
request. This could be used, for example, to return a list of files inside a directory when the directory is read.
​
Resource updates
MCP supports real-time updates for resources through two mechanisms:
​
List changes
Servers can notify clients when their list of available resources changes via the
notifications/resources/list_changed
notification.
​
Content changes
Clients can subscribe to updates for specific resources:
Client sends
resources/subscribe
with resource URI
Server sends
notifications/resources/updated
when the resource changes
Client can fetch latest content with
resources/read
Client can unsubscribe with
resources/unsubscribe
​
Example implementation
Here’s a simple example of implementing resource support in an MCP server:
TypeScript
Python
Copy
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{
resources:
{}
}
});
// List available resources
server
.
setRequestHandler
(
ListResourcesRequestSchema
,
async
()
=>
{
return
{
resources:
[
{
uri:
"file:///logs/app.log"
,
name:
"Application Logs"
,
mimeType:
"text/plain"
}
]
};
});
// Read resource contents
server
.
setRequestHandler
(
ReadResourceRequestSchema
,
async
(
request
)
=>
{
const
uri
=
request
.
params
.
uri
;
if
(
uri
===
"file:///logs/app.log"
) {
const
logContents
=
await
readLogFile
();
return
{
contents:
[
{
uri
,
mimeType:
"text/plain"
,
text:
logContents
}
]
};
}
throw
new
Error
(
"Resource not found"
);
});
Copy
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{
resources:
{}
}
});
// List available resources
server
.
setRequestHandler
(
ListResourcesRequestSchema
,
async
()
=>
{
return
{
resources:
[
{
uri:
"file:///logs/app.log"
,
name:
"Application Logs"
,
mimeType:
"text/plain"
}
]
};
});
// Read resource contents
server
.
setRequestHandler
(
ReadResourceRequestSchema
,
async
(
request
)
=>
{
const
uri
=
request
.
params
.
uri
;
if
(
uri
===
"file:///logs/app.log"
) {
const
logContents
=
await
readLogFile
();
return
{
contents:
[
{
uri
,
mimeType:
"text/plain"
,
text:
logContents
}
]
};
}
throw
new
Error
(
"Resource not found"
);
});
Copy
app
=
Server(
"example-server"
)
@app.list_resources
()
async
def
list_resources
() -> list[types.Resource]:
return
[
types.Resource(
uri
=
"file:///logs/app.log"
,
name
=
"Application Logs"
,
mimeType
=
"text/plain"
)
]
@app.read_resource
()
async
def
read_resource
(
uri
: AnyUrl) ->
str
:
if
str
(uri)
==
"file:///logs/app.log"
:
log_contents
=
await
read_log_file()
return
log_contents
raise
ValueError
(
"Resource not found"
)
# Start server
async
with
stdio_server()
as
streams:
await
app.run(
streams[
0
],
streams[
1
],
app.create_initialization_options()
)
​
Best practices
When implementing resource support:
Use clear, descriptive resource names and URIs
Include helpful descriptions to guide LLM understanding
Set appropriate MIME types when known
Implement resource templates for dynamic content
Use subscriptions for frequently changing resources
Handle errors gracefully with clear error messages
Consider pagination for large resource lists
Cache resource contents when appropriate
Validate URIs before processing
Document your custom URI schemes
​
Security considerations
When exposing resources:
Validate all resource URIs
Implement appropriate access controls
Sanitize file paths to prevent directory traversal
Be cautious with binary data handling
Consider rate limiting for resource reads
Audit resource access
Encrypt sensitive data in transit
Validate MIME types
Implement timeouts for long-running reads
Handle resource cleanup appropriately
Was this page helpful?
Yes
No
Core architecture
Prompts
github
On this page
Overview
Resource URIs
Resource types
Text resources
Binary resources
Resource discovery
Direct resources
Resource templates
Reading resources
Resource updates
List changes
Content changes
Example implementation
Best practices
Security considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/roots

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Roots
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Roots
Understanding roots in MCP
Roots are a concept in MCP that define the boundaries where servers can operate. They provide a way for clients to inform servers about relevant resources and their locations.
​
What are Roots?
A root is a URI that a client suggests a server should focus on. When a client connects to a server, it declares which roots the server should work with. While primarily used for filesystem paths, roots can be any valid URI including HTTP URLs.
For example, roots could be:
Copy
file:///home/user/projects/myapp
https://api.example.com/v1
​
Why Use Roots?
Roots serve several important purposes:
Guidance
: They inform servers about relevant resources and locations
Clarity
: Roots make it clear which resources are part of your workspace
Organization
: Multiple roots let you work with different resources simultaneously
​
How Roots Work
When a client supports roots, it:
Declares the
roots
capability during connection
Provides a list of suggested roots to the server
Notifies the server when roots change (if supported)
While roots are informational and not strictly enforcing, servers should:
Respect the provided roots
Use root URIs to locate and access resources
Prioritize operations within root boundaries
​
Common Use Cases
Roots are commonly used to define:
Project directories
Repository locations
API endpoints
Configuration locations
Resource boundaries
​
Best Practices
When working with roots:
Only suggest necessary resources
Use clear, descriptive names for roots
Monitor root accessibility
Handle root changes gracefully
​
Example
Here’s how a typical MCP client might expose roots:
Copy
{
"roots"
: [
{
"uri"
:
"file:///home/user/projects/frontend"
,
"name"
:
"Frontend Repository"
},
{
"uri"
:
"https://api.example.com/v1"
,
"name"
:
"API Endpoint"
}
]
}
This configuration suggests the server focus on both a local repository and an API endpoint while keeping them logically separated.
Was this page helpful?
Yes
No
Sampling
Transports
github
On this page
What are Roots?
Why Use Roots?
How Roots Work
Common Use Cases
Best Practices
Example
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/sampling

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Sampling
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Sampling
Let your servers request completions from LLMs
Sampling is a powerful MCP feature that allows servers to request LLM completions through the client, enabling sophisticated agentic behaviors while maintaining security and privacy.
This feature of MCP is not yet supported in the Claude Desktop client.
​
How sampling works
The sampling flow follows these steps:
Server sends a
sampling/createMessage
request to the client
Client reviews the request and can modify it
Client samples from an LLM
Client reviews the completion
Client returns the result to the server
This human-in-the-loop design ensures users maintain control over what the LLM sees and generates.
​
Message format
Sampling requests use a standardized message format:
Copy
{
messages
: [
{
role:
"user"
|
"assistant"
,
content:
{
type:
"text"
|
"image"
,
// For text:
text?
:
string
,
// For images:
data?
:
string
,
// base64 encoded
mimeType?
:
string
}
}
],
modelPreferences
?:
{
hints?
:
[{
name?
:
string
// Suggested model name/family
}],
costPriority?
:
number
,
// 0-1, importance of minimizing cost
speedPriority?
:
number
,
// 0-1, importance of low latency
intelligencePriority?
:
number
// 0-1, importance of capabilities
},
systemPrompt
?:
string
,
includeContext
?:
"none"
|
"thisServer"
|
"allServers"
,
temperature
?:
number
,
maxTokens
:
number
,
stopSequences
?:
string
[],
metadata
?:
Record
<
string
,
unknown
>
}
​
Request parameters
​
Messages
The
messages
array contains the conversation history to send to the LLM. Each message has:
role
: Either “user” or “assistant”
content
: The message content, which can be:
Text content with a
text
field
Image content with
data
(base64) and
mimeType
fields
​
Model preferences
The
modelPreferences
object allows servers to specify their model selection preferences:
hints
: Array of model name suggestions that clients can use to select an appropriate model:
name
: String that can match full or partial model names (e.g. “claude-3”, “sonnet”)
Clients may map hints to equivalent models from different providers
Multiple hints are evaluated in preference order
Priority values (0-1 normalized):
costPriority
: Importance of minimizing costs
speedPriority
: Importance of low latency response
intelligencePriority
: Importance of advanced model capabilities
Clients make the final model selection based on these preferences and their available models.
​
System prompt
An optional
systemPrompt
field allows servers to request a specific system prompt. The client may modify or ignore this.
​
Context inclusion
The
includeContext
parameter specifies what MCP context to include:
"none"
: No additional context
"thisServer"
: Include context from the requesting server
"allServers"
: Include context from all connected MCP servers
The client controls what context is actually included.
​
Sampling parameters
Fine-tune the LLM sampling with:
temperature
: Controls randomness (0.0 to 1.0)
maxTokens
: Maximum tokens to generate
stopSequences
: Array of sequences that stop generation
metadata
: Additional provider-specific parameters
​
Response format
The client returns a completion result:
Copy
{
model
:
string
,
// Name of the model used
stopReason
?:
"endTurn"
|
"stopSequence"
|
"maxTokens"
|
string
,
role
:
"user"
|
"assistant"
,
content
: {
type
:
"text"
|
"image"
,
text
?:
string
,
data
?:
string
,
mimeType
?:
string
}
}
​
Example request
Here’s an example of requesting sampling from a client:
Copy
{
"method"
:
"sampling/createMessage"
,
"params"
: {
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"What files are in the current directory?"
}
}
],
"systemPrompt"
:
"You are a helpful file system assistant."
,
"includeContext"
:
"thisServer"
,
"maxTokens"
:
100
}
}
​
Best practices
When implementing sampling:
Always provide clear, well-structured prompts
Handle both text and image content appropriately
Set reasonable token limits
Include relevant context through
includeContext
Validate responses before using them
Handle errors gracefully
Consider rate limiting sampling requests
Document expected sampling behavior
Test with various model parameters
Monitor sampling costs
​
Human in the loop controls
Sampling is designed with human oversight in mind:
​
For prompts
Clients should show users the proposed prompt
Users should be able to modify or reject prompts
System prompts can be filtered or modified
Context inclusion is controlled by the client
​
For completions
Clients should show users the completion
Users should be able to modify or reject completions
Clients can filter or modify completions
Users control which model is used
​
Security considerations
When implementing sampling:
Validate all message content
Sanitize sensitive information
Implement appropriate rate limits
Monitor sampling usage
Encrypt data in transit
Handle user data privacy
Audit sampling requests
Control cost exposure
Implement timeouts
Handle model errors gracefully
​
Common patterns
​
Agentic workflows
Sampling enables agentic patterns like:
Reading and analyzing resources
Making decisions based on context
Generating structured data
Handling multi-step tasks
Providing interactive assistance
​
Context management
Best practices for context:
Request minimal necessary context
Structure context clearly
Handle context size limits
Update context as needed
Clean up stale context
​
Error handling
Robust error handling should:
Catch sampling failures
Handle timeout errors
Manage rate limits
Validate responses
Provide fallback behaviors
Log errors appropriately
​
Limitations
Be aware of these limitations:
Sampling depends on client capabilities
Users control sampling behavior
Context size has limits
Rate limits may apply
Costs should be considered
Model availability varies
Response times vary
Not all content types supported
Was this page helpful?
Yes
No
Tools
Roots
github
On this page
How sampling works
Message format
Request parameters
Messages
Model preferences
System prompt
Context inclusion
Sampling parameters
Response format
Example request
Best practices
Human in the loop controls
For prompts
For completions
Security considerations
Common patterns
Agentic workflows
Context management
Error handling
Limitations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/tools

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Tools
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Tools
Enable LLMs to perform actions through your server
Tools are a powerful primitive in the Model Context Protocol (MCP) that enable servers to expose executable functionality to clients. Through tools, LLMs can interact with external systems, perform computations, and take actions in the real world.
Tools are designed to be
model-controlled
, meaning that tools are exposed from servers to clients with the intention of the AI model being able to automatically invoke them (with a human in the loop to grant approval).
​
Overview
Tools in MCP allow servers to expose executable functions that can be invoked by clients and used by LLMs to perform actions. Key aspects of tools include:
Discovery
: Clients can obtain a list of available tools by sending a
tools/list
request
Invocation
: Tools are called using the
tools/call
request, where servers perform the requested operation and return results
Flexibility
: Tools can range from simple calculations to complex API interactions
Like
resources
, tools are identified by unique names and can include descriptions to guide their usage. However, unlike resources, tools represent dynamic operations that can modify state or interact with external systems.
​
Tool definition structure
Each tool is defined with the following structure:
Copy
{
name
:
string
;
// Unique identifier for the tool
description
?:
string
;
// Human-readable description
inputSchema
: {
// JSON Schema for the tool's parameters
type
:
"object"
,
properties
: {
...
}
// Tool-specific parameters
},
annotations
?:
{
// Optional hints about tool behavior
title?
:
string
;
// Human-readable title for the tool
readOnlyHint
?:
boolean
;
// If true, the tool does not modify its environment
destructiveHint
?:
boolean
;
// If true, the tool may perform destructive updates
idempotentHint
?:
boolean
;
// If true, repeated calls with same args have no additional effect
openWorldHint
?:
boolean
;
// If true, tool interacts with external entities
}
}
​
Implementing tools
Here’s an example of implementing a basic tool in an MCP server:
TypeScript
Python
Copy
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{
tools:
{}
}
});
// Define available tools
server
.
setRequestHandler
(
ListToolsRequestSchema
,
async
()
=>
{
return
{
tools:
[{
name:
"calculate_sum"
,
description:
"Add two numbers together"
,
inputSchema:
{
type:
"object"
,
properties:
{
a:
{
type:
"number"
},
b:
{
type:
"number"
}
},
required:
[
"a"
,
"b"
]
}
}]
};
});
// Handle tool execution
server
.
setRequestHandler
(
CallToolRequestSchema
,
async
(
request
)
=>
{
if
(
request
.
params
.
name
===
"calculate_sum"
) {
const
{
a
,
b
}
=
request
.
params
.
arguments
;
return
{
content:
[
{
type:
"text"
,
text:
String
(
a
+
b
)
}
]
};
}
throw
new
Error
(
"Tool not found"
);
});
Copy
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{
tools:
{}
}
});
// Define available tools
server
.
setRequestHandler
(
ListToolsRequestSchema
,
async
()
=>
{
return
{
tools:
[{
name:
"calculate_sum"
,
description:
"Add two numbers together"
,
inputSchema:
{
type:
"object"
,
properties:
{
a:
{
type:
"number"
},
b:
{
type:
"number"
}
},
required:
[
"a"
,
"b"
]
}
}]
};
});
// Handle tool execution
server
.
setRequestHandler
(
CallToolRequestSchema
,
async
(
request
)
=>
{
if
(
request
.
params
.
name
===
"calculate_sum"
) {
const
{
a
,
b
}
=
request
.
params
.
arguments
;
return
{
content:
[
{
type:
"text"
,
text:
String
(
a
+
b
)
}
]
};
}
throw
new
Error
(
"Tool not found"
);
});
Copy
app
=
Server(
"example-server"
)
@app.list_tools
()
async
def
list_tools
() -> list[types.Tool]:
return
[
types.Tool(
name
=
"calculate_sum"
,
description
=
"Add two numbers together"
,
inputSchema
=
{
"type"
:
"object"
,
"properties"
: {
"a"
: {
"type"
:
"number"
},
"b"
: {
"type"
:
"number"
}
},
"required"
: [
"a"
,
"b"
]
}
)
]
@app.call_tool
()
async
def
call_tool
(
name
:
str
,
arguments
:
dict
) -> list[types.TextContent
|
types.ImageContent
|
types.EmbeddedResource]:
if
name
==
"calculate_sum"
:
a
=
arguments[
"a"
]
b
=
arguments[
"b"
]
result
=
a
+
b
return
[types.TextContent(
type
=
"text"
,
text
=
str
(result))]
raise
ValueError
(
f
"Tool not found:
{
name
}
"
)
​
Example tool patterns
Here are some examples of types of tools that a server could provide:
​
System operations
Tools that interact with the local system:
Copy
{
name
:
"execute_command"
,
description
:
"Run a shell command"
,
inputSchema
: {
type
:
"object"
,
properties
: {
command
: {
type
:
"string"
},
args
: {
type
:
"array"
,
items
: {
type
:
"string"
} }
}
}
}
​
API integrations
Tools that wrap external APIs:
Copy
{
name
:
"github_create_issue"
,
description
:
"Create a GitHub issue"
,
inputSchema
: {
type
:
"object"
,
properties
: {
title
: {
type
:
"string"
},
body
: {
type
:
"string"
},
labels
: {
type
:
"array"
,
items
: {
type
:
"string"
} }
}
}
}
​
Data processing
Tools that transform or analyze data:
Copy
{
name
:
"analyze_csv"
,
description
:
"Analyze a CSV file"
,
inputSchema
: {
type
:
"object"
,
properties
: {
filepath
: {
type
:
"string"
},
operations
: {
type
:
"array"
,
items
: {
enum
: [
"sum"
,
"average"
,
"count"
]
}
}
}
}
}
​
Best practices
When implementing tools:
Provide clear, descriptive names and descriptions
Use detailed JSON Schema definitions for parameters
Include examples in tool descriptions to demonstrate how the model should use them
Implement proper error handling and validation
Use progress reporting for long operations
Keep tool operations focused and atomic
Document expected return value structures
Implement proper timeouts
Consider rate limiting for resource-intensive operations
Log tool usage for debugging and monitoring
​
Tool name conflicts
MCP client applications and MCP server proxies may encounter tool name conflicts when building their own tool lists. For example, two connected MCP servers
web1
and
web2
may both expose a tool named
search_web
.
Applications may disambiguiate tools with one of the following strategies (among others; not an exhaustive list):
Concatenating a unique, user-defined server name with the tool name, e.g.
web1___search_web
and
web2___search_web
. This strategy may be preferable when unique server names are already provided by the user in a configuration file.
Generating a random prefix for the tool name, e.g.
jrwxs___search_web
and
6cq52___search_web
. This strategy may be preferable in server proxies where user-defined unique names are not available.
Using the server URI as a prefix for the tool name, e.g.
web1.example.com:search_web
and
web2.example.com:search_web
. This strategy may be suitable when working with remote MCP servers.
Note that the server-provided name from the initialization flow is not guaranteed to be unique and is not generally suitable for disambiguation purposes.
​
Security considerations
When exposing tools:
​
Input validation
Validate all parameters against the schema
Sanitize file paths and system commands
Validate URLs and external identifiers
Check parameter sizes and ranges
Prevent command injection
​
Access control
Implement authentication where needed
Use appropriate authorization checks
Audit tool usage
Rate limit requests
Monitor for abuse
​
Error handling
Don’t expose internal errors to clients
Log security-relevant errors
Handle timeouts appropriately
Clean up resources after errors
Validate return values
​
Tool discovery and updates
MCP supports dynamic tool discovery:
Clients can list available tools at any time
Servers can notify clients when tools change using
notifications/tools/list_changed
Tools can be added or removed during runtime
Tool definitions can be updated (though this should be done carefully)
​
Error handling
Tool errors should be reported within the result object, not as MCP protocol-level errors. This allows the LLM to see and potentially handle the error. When a tool encounters an error:
Set
isError
to
true
in the result
Include error details in the
content
array
Here’s an example of proper error handling for tools:
TypeScript
Python
Copy
try
{
// Tool operation
const
result
=
performOperation
();
return
{
content:
[
{
type:
"text"
,
text:
`Operation successful:
${
result
}
`
}
]
};
}
catch
(
error
) {
return
{
isError:
true
,
content:
[
{
type:
"text"
,
text:
`Error:
${
error
.
message
}
`
}
]
};
}
Copy
try
{
// Tool operation
const
result
=
performOperation
();
return
{
content:
[
{
type:
"text"
,
text:
`Operation successful:
${
result
}
`
}
]
};
}
catch
(
error
) {
return
{
isError:
true
,
content:
[
{
type:
"text"
,
text:
`Error:
${
error
.
message
}
`
}
]
};
}
Copy
try
:
# Tool operation
result
=
perform_operation()
return
types.CallToolResult(
content
=
[
types.TextContent(
type
=
"text"
,
text
=
f
"Operation successful:
{
result
}
"
)
]
)
except
Exception
as
error:
return
types.CallToolResult(
isError
=
True
,
content
=
[
types.TextContent(
type
=
"text"
,
text
=
f
"Error:
{
str
(error)
}
"
)
]
)
This approach allows the LLM to see that an error occurred and potentially take corrective action or request human intervention.
​
Tool annotations
Tool annotations provide additional metadata about a tool’s behavior, helping clients understand how to present and manage tools. These annotations are hints that describe the nature and impact of a tool, but should not be relied upon for security decisions.
​
Purpose of tool annotations
Tool annotations serve several key purposes:
Provide UX-specific information without affecting model context
Help clients categorize and present tools appropriately
Convey information about a tool’s potential side effects
Assist in developing intuitive interfaces for tool approval
​
Available tool annotations
The MCP specification defines the following annotations for tools:
Annotation
Type
Default
Description
title
string
-
A human-readable title for the tool, useful for UI display
readOnlyHint
boolean
false
If true, indicates the tool does not modify its environment
destructiveHint
boolean
true
If true, the tool may perform destructive updates (only meaningful when
readOnlyHint
is false)
idempotentHint
boolean
false
If true, calling the tool repeatedly with the same arguments has no additional effect (only meaningful when
readOnlyHint
is false)
openWorldHint
boolean
true
If true, the tool may interact with an “open world” of external entities
​
Example usage
Here’s how to define tools with annotations for different scenarios:
Copy
// A read-only search tool
{
name
:
"web_search"
,
description
:
"Search the web for information"
,
inputSchema
: {
type
:
"object"
,
properties
: {
query
: {
type
:
"string"
}
},
required
: [
"query"
]
},
annotations
: {
title
:
"Web Search"
,
readOnlyHint
:
true
,
openWorldHint
:
true
}
}
// A destructive file deletion tool
{
name
:
"delete_file"
,
description
:
"Delete a file from the filesystem"
,
inputSchema
: {
type
:
"object"
,
properties
: {
path
: {
type
:
"string"
}
},
required
: [
"path"
]
},
annotations
: {
title
:
"Delete File"
,
readOnlyHint
:
false
,
destructiveHint
:
true
,
idempotentHint
:
true
,
openWorldHint
:
false
}
}
// A non-destructive database record creation tool
{
name
:
"create_record"
,
description
:
"Create a new record in the database"
,
inputSchema
: {
type
:
"object"
,
properties
: {
table
: {
type
:
"string"
},
data
: {
type
:
"object"
}
},
required
: [
"table"
,
"data"
]
},
annotations
: {
title
:
"Create Database Record"
,
readOnlyHint
:
false
,
destructiveHint
:
false
,
idempotentHint
:
false
,
openWorldHint
:
false
}
}
​
Integrating annotations in server implementation
TypeScript
Python
Copy
server
.
setRequestHandler
(
ListToolsRequestSchema
,
async
()
=>
{
return
{
tools:
[{
name:
"calculate_sum"
,
description:
"Add two numbers together"
,
inputSchema:
{
type:
"object"
,
properties:
{
a:
{
type:
"number"
},
b:
{
type:
"number"
}
},
required:
[
"a"
,
"b"
]
},
annotations:
{
title:
"Calculate Sum"
,
readOnlyHint:
true
,
openWorldHint:
false
}
}]
};
});
Copy
server
.
setRequestHandler
(
ListToolsRequestSchema
,
async
()
=>
{
return
{
tools:
[{
name:
"calculate_sum"
,
description:
"Add two numbers together"
,
inputSchema:
{
type:
"object"
,
properties:
{
a:
{
type:
"number"
},
b:
{
type:
"number"
}
},
required:
[
"a"
,
"b"
]
},
annotations:
{
title:
"Calculate Sum"
,
readOnlyHint:
true
,
openWorldHint:
false
}
}]
};
});
Copy
from
mcp.server.fastmcp
import
FastMCP
mcp
=
FastMCP(
"example-server"
)
@mcp.tool
(
annotations
=
{
"title"
:
"Calculate Sum"
,
"readOnlyHint"
:
True
,
"openWorldHint"
:
False
}
)
async
def
calculate_sum
(
a
:
float
,
b
:
float
) ->
str
:
"""Add two numbers together.
Args:
a: First number to add
b: Second number to add
"""
result
=
a
+
b
return
str
(result)
​
Best practices for tool annotations
Be accurate about side effects
: Clearly indicate whether a tool modifies its environment and whether those modifications are destructive.
Use descriptive titles
: Provide human-friendly titles that clearly describe the tool’s purpose.
Indicate idempotency properly
: Mark tools as idempotent only if repeated calls with the same arguments truly have no additional effect.
Set appropriate open/closed world hints
: Indicate whether a tool interacts with a closed system (like a database) or an open system (like the web).
Remember annotations are hints
: All properties in ToolAnnotations are hints and not guaranteed to provide a faithful description of tool behavior. Clients should never make security-critical decisions based solely on annotations.
​
Testing tools
A comprehensive testing strategy for MCP tools should cover:
Functional testing
: Verify tools execute correctly with valid inputs and handle invalid inputs appropriately
Integration testing
: Test tool interaction with external systems using both real and mocked dependencies
Security testing
: Validate authentication, authorization, input sanitization, and rate limiting
Performance testing
: Check behavior under load, timeout handling, and resource cleanup
Error handling
: Ensure tools properly report errors through the MCP protocol and clean up resources
Was this page helpful?
Yes
No
Prompts
Sampling
github
On this page
Overview
Tool definition structure
Implementing tools
Example tool patterns
System operations
API integrations
Data processing
Best practices
Tool name conflicts
Security considerations
Input validation
Access control
Error handling
Tool discovery and updates
Error handling
Tool annotations
Purpose of tool annotations
Available tool annotations
Example usage
Integrating annotations in server implementation
Best practices for tool annotations
Testing tools
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/concepts/transports

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Concepts
Transports
User Guide
Introduction
Quickstart
Concepts
Core architecture
Resources
Prompts
Tools
Sampling
Roots
Transports
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Concepts
Copy page
Transports
Learn about MCP’s communication mechanisms
Transports in the Model Context Protocol (MCP) provide the foundation for communication between clients and servers. A transport handles the underlying mechanics of how messages are sent and received.
​
Message Format
MCP uses
JSON-RPC
2.0 as its wire format. The transport layer is responsible for converting MCP protocol messages into JSON-RPC format for transmission and converting received JSON-RPC messages back into MCP protocol messages.
There are three types of JSON-RPC messages used:
​
Requests
Copy
{
jsonrpc
:
"2.0"
,
id
:
number
|
string
,
method
:
string
,
params
?:
object
}
​
Responses
Copy
{
jsonrpc
:
"2.0"
,
id
:
number
|
string
,
result
?:
object
,
error
?:
{
code:
number
,
message:
string
,
data?
:
unknown
}
}
​
Notifications
Copy
{
jsonrpc
:
"2.0"
,
method
:
string
,
params
?:
object
}
​
Built-in Transport Types
MCP currently defines two standard transport mechanisms:
​
Standard Input/Output (stdio)
The stdio transport enables communication through standard input and output streams. This is particularly useful for local integrations and command-line tools.
Use stdio when:
Building command-line tools
Implementing local integrations
Needing simple process communication
Working with shell scripts
TypeScript (Server)
TypeScript (Client)
Python (Server)
Python (Client)
Copy
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
const
transport
=
new
StdioServerTransport
();
await
server
.
connect
(
transport
);
Copy
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
const
transport
=
new
StdioServerTransport
();
await
server
.
connect
(
transport
);
Copy
const
client
=
new
Client
({
name:
"example-client"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
const
transport
=
new
StdioClientTransport
({
command:
"./server"
,
args:
[
"--option"
,
"value"
]
});
await
client
.
connect
(
transport
);
Copy
app
=
Server(
"example-server"
)
async
with
stdio_server()
as
streams:
await
app.run(
streams[
0
],
streams[
1
],
app.create_initialization_options()
)
Copy
params
=
StdioServerParameters(
command
=
"./server"
,
args
=
[
"--option"
,
"value"
]
)
async
with
stdio_client(params)
as
streams:
async
with
ClientSession(streams[
0
], streams[
1
])
as
session:
await
session.initialize()
​
Streamable HTTP
The Streamable HTTP transport uses HTTP POST requests for client-to-server communication and optional Server-Sent Events (SSE) streams for server-to-client communication.
Use Streamable HTTP when:
Building web-based integrations
Needing client-server communication over HTTP
Requiring stateful sessions
Supporting multiple concurrent clients
Implementing resumable connections
​
How it Works
Client-to-Server Communication
: Every JSON-RPC message from client to server is sent as a new HTTP POST request to the MCP endpoint
Server Responses
: The server can respond either with:
A single JSON response (
Content-Type: application/json
)
An SSE stream (
Content-Type: text/event-stream
) for multiple messages
Server-to-Client Communication
: Servers can send requests/notifications to clients via:
SSE streams initiated by client requests
SSE streams from HTTP GET requests to the MCP endpoint
TypeScript (Server)
TypeScript (Client)
Python (Server)
Python (Client)
Copy
import
express
from
"express"
;
const
app
=
express
();
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
// MCP endpoint handles both POST and GET
app
.
post
(
"/mcp"
,
async
(
req
,
res
)
=>
{
// Handle JSON-RPC request
const
response
=
await
server
.
handleRequest
(
req
.
body
);
// Return single response or SSE stream
if
(
needsStreaming
) {
res
.
setHeader
(
"Content-Type"
,
"text/event-stream"
);
// Send SSE events...
}
else
{
res
.
json
(
response
);
}
});
app
.
get
(
"/mcp"
, (
req
,
res
)
=>
{
// Optional: Support server-initiated SSE streams
res
.
setHeader
(
"Content-Type"
,
"text/event-stream"
);
// Send server notifications/requests...
});
app
.
listen
(
3000
);
Copy
import
express
from
"express"
;
const
app
=
express
();
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
// MCP endpoint handles both POST and GET
app
.
post
(
"/mcp"
,
async
(
req
,
res
)
=>
{
// Handle JSON-RPC request
const
response
=
await
server
.
handleRequest
(
req
.
body
);
// Return single response or SSE stream
if
(
needsStreaming
) {
res
.
setHeader
(
"Content-Type"
,
"text/event-stream"
);
// Send SSE events...
}
else
{
res
.
json
(
response
);
}
});
app
.
get
(
"/mcp"
, (
req
,
res
)
=>
{
// Optional: Support server-initiated SSE streams
res
.
setHeader
(
"Content-Type"
,
"text/event-stream"
);
// Send server notifications/requests...
});
app
.
listen
(
3000
);
Copy
const
client
=
new
Client
({
name:
"example-client"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
const
transport
=
new
HttpClientTransport
(
new
URL
(
"http://localhost:3000/mcp"
)
);
await
client
.
connect
(
transport
);
Copy
from
mcp.server.http
import
HttpServerTransport
from
starlette.applications
import
Starlette
from
starlette.routing
import
Route
app
=
Server(
"example-server"
)
async
def
handle_mcp
(
scope
,
receive
,
send
):
if
scope[
"method"
]
==
"POST"
:
# Handle JSON-RPC request
response
=
await
app.handle_request(request_body)
if
needs_streaming:
# Return SSE stream
await
send_sse_response(send, response)
else
:
# Return JSON response
await
send_json_response(send, response)
elif
scope[
"method"
]
==
"GET"
:
# Optional: Support server-initiated SSE streams
await
send_sse_stream(send)
starlette_app
=
Starlette(
routes
=
[
Route(
"/mcp"
,
endpoint
=
handle_mcp,
methods
=
[
"POST"
,
"GET"
]),
]
)
Copy
async
with
http_client(
"http://localhost:8000/mcp"
)
as
transport:
async
with
ClientSession(transport[
0
], transport[
1
])
as
session:
await
session.initialize()
​
Session Management
Streamable HTTP supports stateful sessions to maintain context across multiple requests:
Session Initialization
: Servers may assign a session ID during initialization by including it in an
Mcp-Session-Id
header
Session Persistence
: Clients must include the session ID in all subsequent requests using the
Mcp-Session-Id
header
Session Termination
: Sessions can be explicitly terminated by sending an HTTP DELETE request with the session ID
Example session flow:
Copy
// Server assigns session ID during initialization
app
.
post
(
"/mcp"
, (
req
,
res
)
=>
{
if
(
req
.
body
.
method
===
"initialize"
) {
const
sessionId
=
generateSecureId
();
res
.
setHeader
(
"Mcp-Session-Id"
,
sessionId
);
// Store session state...
}
// Handle request...
});
// Client includes session ID in subsequent requests
fetch
(
"/mcp"
, {
method:
"POST"
,
headers:
{
"Content-Type"
:
"application/json"
,
"Mcp-Session-Id"
:
sessionId
,
},
body:
JSON
.
stringify
(
request
),
});
​
Resumability and Redelivery
To support resuming broken connections, Streamable HTTP provides:
Event IDs
: Servers can attach unique IDs to SSE events for tracking
Resume from Last Event
: Clients can resume by sending the
Last-Event-ID
header
Message Replay
: Servers can replay missed messages from the disconnection point
This ensures reliable message delivery even with unstable network connections.
​
Security Considerations
When implementing Streamable HTTP transport, follow these security best practices:
Validate Origin Headers
: Always validate the
Origin
header on all incoming connections to prevent DNS rebinding attacks
Bind to Localhost
: When running locally, bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
Implement Authentication
: Use proper authentication for all connections
Use HTTPS
: Always use TLS/HTTPS for production deployments
Validate Session IDs
: Ensure session IDs are cryptographically secure and properly validated
Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.
​
Server-Sent Events (SSE) - Deprecated
SSE as a standalone transport is deprecated as of protocol version 2024-11-05.
It has been replaced by Streamable HTTP, which incorporates SSE as an optional
streaming mechanism. For backwards compatibility information, see the
backwards compatibility
section below.
The legacy SSE transport enabled server-to-client streaming with HTTP POST requests for client-to-server communication.
Previously used when:
Only server-to-client streaming is needed
Working with restricted networks
Implementing simple updates
​
Legacy Security Considerations
The deprecated SSE transport had similar security considerations to Streamable HTTP, particularly regarding DNS rebinding attacks. These same protections should be applied when using SSE streams within the Streamable HTTP transport.
TypeScript (Server)
TypeScript (Client)
Python (Server)
Python (Client)
Copy
import
express
from
"express"
;
const
app
=
express
();
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
let
transport
:
SSEServerTransport
|
null
=
null
;
app
.
get
(
"/sse"
, (
req
,
res
)
=>
{
transport
=
new
SSEServerTransport
(
"/messages"
,
res
);
server
.
connect
(
transport
);
});
app
.
post
(
"/messages"
, (
req
,
res
)
=>
{
if
(
transport
) {
transport
.
handlePostMessage
(
req
,
res
);
}
});
app
.
listen
(
3000
);
Copy
import
express
from
"express"
;
const
app
=
express
();
const
server
=
new
Server
({
name:
"example-server"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
let
transport
:
SSEServerTransport
|
null
=
null
;
app
.
get
(
"/sse"
, (
req
,
res
)
=>
{
transport
=
new
SSEServerTransport
(
"/messages"
,
res
);
server
.
connect
(
transport
);
});
app
.
post
(
"/messages"
, (
req
,
res
)
=>
{
if
(
transport
) {
transport
.
handlePostMessage
(
req
,
res
);
}
});
app
.
listen
(
3000
);
Copy
const
client
=
new
Client
({
name:
"example-client"
,
version:
"1.0.0"
}, {
capabilities:
{}
});
const
transport
=
new
SSEClientTransport
(
new
URL
(
"http://localhost:3000/sse"
)
);
await
client
.
connect
(
transport
);
Copy
from
mcp.server.sse
import
SseServerTransport
from
starlette.applications
import
Starlette
from
starlette.routing
import
Route
app
=
Server(
"example-server"
)
sse
=
SseServerTransport(
"/messages"
)
async
def
handle_sse
(
scope
,
receive
,
send
):
async
with
sse.connect_sse(scope, receive, send)
as
streams:
await
app.run(streams[
0
], streams[
1
], app.create_initialization_options())
async
def
handle_messages
(
scope
,
receive
,
send
):
await
sse.handle_post_message(scope, receive, send)
starlette_app
=
Starlette(
routes
=
[
Route(
"/sse"
,
endpoint
=
handle_sse),
Route(
"/messages"
,
endpoint
=
handle_messages,
methods
=
[
"POST"
]),
]
)
Copy
async
with
sse_client(
"http://localhost:8000/sse"
)
as
streams:
async
with
ClientSession(streams[
0
], streams[
1
])
as
session:
await
session.initialize()
​
Custom Transports
MCP makes it easy to implement custom transports for specific needs. Any transport implementation just needs to conform to the Transport interface:
You can implement custom transports for:
Custom network protocols
Specialized communication channels
Integration with existing systems
Performance optimization
TypeScript
Python
Copy
interface
Transport
{
// Start processing messages
start
()
:
Promise
<
void
>;
// Send a JSON-RPC message
send
(
message
:
JSONRPCMessage
)
:
Promise
<
void
>;
// Close the connection
close
()
:
Promise
<
void
>;
// Callbacks
onclose
?:
()
=>
void
;
onerror
?:
(
error
:
Error
)
=>
void
;
onmessage
?:
(
message
:
JSONRPCMessage
)
=>
void
;
}
Copy
interface
Transport
{
// Start processing messages
start
()
:
Promise
<
void
>;
// Send a JSON-RPC message
send
(
message
:
JSONRPCMessage
)
:
Promise
<
void
>;
// Close the connection
close
()
:
Promise
<
void
>;
// Callbacks
onclose
?:
()
=>
void
;
onerror
?:
(
error
:
Error
)
=>
void
;
onmessage
?:
(
message
:
JSONRPCMessage
)
=>
void
;
}
Note that while MCP Servers are often implemented with asyncio, we recommend
implementing low-level interfaces like transports with
anyio
for wider compatibility.
Copy
@contextmanager
async
def
create_transport
(
read_stream
: MemoryObjectReceiveStream[JSONRPCMessage
|
Exception
],
write_stream
: MemoryObjectSendStream[JSONRPCMessage]
):
"""
Transport interface for MCP.
Args:
read_stream: Stream to read incoming messages from
write_stream: Stream to write outgoing messages to
"""
async
with
anyio.create_task_group()
as
tg:
try
:
# Start processing messages
tg.start_soon(
lambda
: process_messages(read_stream))
# Send messages
async
with
write_stream:
yield
write_stream
except
Exception
as
exc:
# Handle errors
raise
exc
finally
:
# Clean up
tg.cancel_scope.cancel()
await
write_stream.aclose()
await
read_stream.aclose()
​
Error Handling
Transport implementations should handle various error scenarios:
Connection errors
Message parsing errors
Protocol errors
Network timeouts
Resource cleanup
Example error handling:
TypeScript
Python
Copy
class
ExampleTransport
implements
Transport
{
async
start
() {
try
{
// Connection logic
}
catch
(
error
) {
this
.
onerror
?.(
new
Error
(
`Failed to connect:
${
error
}
`
));
throw
error
;
}
}
async
send
(
message
:
JSONRPCMessage
) {
try
{
// Sending logic
}
catch
(
error
) {
this
.
onerror
?.(
new
Error
(
`Failed to send message:
${
error
}
`
));
throw
error
;
}
}
}
Copy
class
ExampleTransport
implements
Transport
{
async
start
() {
try
{
// Connection logic
}
catch
(
error
) {
this
.
onerror
?.(
new
Error
(
`Failed to connect:
${
error
}
`
));
throw
error
;
}
}
async
send
(
message
:
JSONRPCMessage
) {
try
{
// Sending logic
}
catch
(
error
) {
this
.
onerror
?.(
new
Error
(
`Failed to send message:
${
error
}
`
));
throw
error
;
}
}
}
Note that while MCP Servers are often implemented with asyncio, we recommend
implementing low-level interfaces like transports with
anyio
for wider compatibility.
Copy
@contextmanager
async
def
example_transport
(
scope
: Scope,
receive
: Receive,
send
: Send):
try
:
# Create streams for bidirectional communication
read_stream_writer, read_stream
=
anyio.create_memory_object_stream(
0
)
write_stream, write_stream_reader
=
anyio.create_memory_object_stream(
0
)
async
def
message_handler
():
try
:
async
with
read_stream_writer:
# Message handling logic
pass
except
Exception
as
exc:
logger.error(
f
"Failed to handle message:
{
exc
}
"
)
raise
exc
async
with
anyio.create_task_group()
as
tg:
tg.start_soon(message_handler)
try
:
# Yield streams for communication
yield
read_stream, write_stream
except
Exception
as
exc:
logger.error(
f
"Transport error:
{
exc
}
"
)
raise
exc
finally
:
tg.cancel_scope.cancel()
await
write_stream.aclose()
await
read_stream.aclose()
except
Exception
as
exc:
logger.error(
f
"Failed to initialize transport:
{
exc
}
"
)
raise
exc
​
Best Practices
When implementing or using MCP transport:
Handle connection lifecycle properly
Implement proper error handling
Clean up resources on connection close
Use appropriate timeouts
Validate messages before sending
Log transport events for debugging
Implement reconnection logic when appropriate
Handle backpressure in message queues
Monitor connection health
Implement proper security measures
​
Security Considerations
When implementing transport:
​
Authentication and Authorization
Implement proper authentication mechanisms
Validate client credentials
Use secure token handling
Implement authorization checks
​
Data Security
Use TLS for network transport
Encrypt sensitive data
Validate message integrity
Implement message size limits
Sanitize input data
​
Network Security
Implement rate limiting
Use appropriate timeouts
Handle denial of service scenarios
Monitor for unusual patterns
Implement proper firewall rules
For HTTP-based transports (including Streamable HTTP), validate Origin headers to prevent DNS rebinding attacks
For local servers, bind only to localhost (127.0.0.1) instead of all interfaces (0.0.0.0)
​
Debugging Transport
Tips for debugging transport issues:
Enable debug logging
Monitor message flow
Check connection states
Validate message formats
Test error scenarios
Use network analysis tools
Implement health checks
Monitor resource usage
Test edge cases
Use proper error tracking
​
Backwards Compatibility
To maintain compatibility between different protocol versions:
​
For Servers Supporting Older Clients
Servers wanting to support clients using the deprecated HTTP+SSE transport should:
Host both the old SSE and POST endpoints alongside the new MCP endpoint
Handle initialization requests on both endpoints
Maintain separate handling logic for each transport type
​
For Clients Supporting Older Servers
Clients wanting to support servers using the deprecated transport should:
Accept server URLs that may use either transport
Attempt to POST an
InitializeRequest
with proper
Accept
headers:
If successful, use Streamable HTTP transport
If it fails with 4xx status, fall back to legacy SSE transport
Issue a GET request expecting an SSE stream with
endpoint
event for legacy servers
Example compatibility detection:
Copy
async
function
detectTransport
(
serverUrl
:
string
)
:
Promise
<
TransportType
> {
try
{
// Try Streamable HTTP first
const
response
=
await
fetch
(
serverUrl
, {
method:
"POST"
,
headers:
{
"Content-Type"
:
"application/json"
,
Accept:
"application/json, text/event-stream"
,
},
body:
JSON
.
stringify
({
jsonrpc:
"2.0"
,
method:
"initialize"
,
params:
{
/* ... */
},
}),
});
if
(
response
.
ok
) {
return
"streamable-http"
;
}
}
catch
(
error
) {
// Fall back to legacy SSE
const
sseResponse
=
await
fetch
(
serverUrl
, {
method:
"GET"
,
headers:
{
Accept:
"text/event-stream"
},
});
if
(
sseResponse
.
ok
) {
return
"legacy-sse"
;
}
}
throw
new
Error
(
"Unsupported transport"
);
}
Was this page helpful?
Yes
No
Roots
Example Servers
github
On this page
Message Format
Requests
Responses
Notifications
Built-in Transport Types
Standard Input/Output (stdio)
Streamable HTTP
How it Works
Session Management
Resumability and Redelivery
Security Considerations
Server-Sent Events (SSE) - Deprecated
Legacy Security Considerations
Custom Transports
Error Handling
Best Practices
Security Considerations
Authentication and Authorization
Data Security
Network Security
Debugging Transport
Backwards Compatibility
For Servers Supporting Older Clients
For Clients Supporting Older Servers
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/tools/debugging

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Tutorials
Debugging
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
Building MCP with LLMs
Debugging
Inspector
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Tutorials
Copy page
Debugging
A comprehensive guide to debugging Model Context Protocol (MCP) integrations
Effective debugging is essential when developing MCP servers or integrating them with applications. This guide covers the debugging tools and approaches available in the MCP ecosystem.
This guide is for macOS. Guides for other platforms are coming soon.
​
Debugging tools overview
MCP provides several tools for debugging at different levels:
MCP Inspector
Interactive debugging interface
Direct server testing
See the
Inspector guide
for details
Claude Desktop Developer Tools
Integration testing
Log collection
Chrome DevTools integration
Server Logging
Custom logging implementations
Error tracking
Performance monitoring
​
Debugging in Claude Desktop
​
Checking server status
The Claude.app interface provides basic server status information:
Click the
icon to view:
Connected servers
Available prompts and resources
Click the “Search and tools”
icon to view:
Tools made available to the model
​
Viewing logs
Review detailed MCP logs from Claude Desktop:
Copy
# Follow logs in real-time
tail
-n
20
-F
~/Library/Logs/Claude/mcp
*
.log
The logs capture:
Server connection events
Configuration issues
Runtime errors
Message exchanges
​
Using Chrome DevTools
Access Chrome’s developer tools inside Claude Desktop to investigate client-side errors:
Create a
developer_settings.json
file with
allowDevTools
set to true:
Copy
echo
'{"allowDevTools": true}'
>
~/Library/Application
\
Support/Claude/developer_settings.json
Open DevTools:
Command-Option-Shift-i
Note: You’ll see two DevTools windows:
Main content window
App title bar window
Use the Console panel to inspect client-side errors.
Use the Network panel to inspect:
Message payloads
Connection timing
​
Common issues
​
Working directory
When using MCP servers with Claude Desktop:
The working directory for servers launched via
claude_desktop_config.json
may be undefined (like
/
on macOS) since Claude Desktop could be started from anywhere
Always use absolute paths in your configuration and
.env
files to ensure reliable operation
For testing servers directly via command line, the working directory will be where you run the command
For example in
claude_desktop_config.json
, use:
Copy
{
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-filesystem"
,
"/Users/username/data"
]
}
Instead of relative paths like
./data
​
Environment variables
MCP servers inherit only a subset of environment variables automatically, like
USER
,
HOME
, and
PATH
.
To override the default variables or provide your own, you can specify an
env
key in
claude_desktop_config.json
:
Copy
{
"myserver"
: {
"command"
:
"mcp-server-myapp"
,
"env"
: {
"MYAPP_API_KEY"
:
"some_key"
}
}
}
​
Server initialization
Common initialization problems:
Path Issues
Incorrect server executable path
Missing required files
Permission problems
Try using an absolute path for
command
Configuration Errors
Invalid JSON syntax
Missing required fields
Type mismatches
Environment Problems
Missing environment variables
Incorrect variable values
Permission restrictions
​
Connection problems
When servers fail to connect:
Check Claude Desktop logs
Verify server process is running
Test standalone with
Inspector
Verify protocol compatibility
​
Implementing logging
​
Server-side logging
When building a server that uses the local stdio
transport
, all messages logged to stderr (standard error) will be captured by the host application (e.g., Claude Desktop) automatically.
Local MCP servers should not log messages to stdout (standard out), as this will interfere with protocol operation.
For all
transports
, you can also provide logging to the client by sending a log message notification:
Python
TypeScript
Copy
server.request_context.session.send_log_message(
level
=
"info"
,
data
=
"Server started successfully"
,
)
Copy
server.request_context.session.send_log_message(
level
=
"info"
,
data
=
"Server started successfully"
,
)
Copy
server
.
sendLoggingMessage
({
level:
"info"
,
data:
"Server started successfully"
,
});
Important events to log:
Initialization steps
Resource access
Tool execution
Error conditions
Performance metrics
​
Client-side logging
In client applications:
Enable debug logging
Monitor network traffic
Track message exchanges
Record error states
​
Debugging workflow
​
Development cycle
Initial Development
Use
Inspector
for basic testing
Implement core functionality
Add logging points
Integration Testing
Test in Claude Desktop
Monitor logs
Check error handling
​
Testing changes
To test changes efficiently:
Configuration changes
: Restart Claude Desktop
Server code changes
: Use Command-R to reload
Quick iteration
: Use
Inspector
during development
​
Best practices
​
Logging strategy
Structured Logging
Use consistent formats
Include context
Add timestamps
Track request IDs
Error Handling
Log stack traces
Include error context
Track error patterns
Monitor recovery
Performance Tracking
Log operation timing
Monitor resource usage
Track message sizes
Measure latency
​
Security considerations
When debugging:
Sensitive Data
Sanitize logs
Protect credentials
Mask personal information
Access Control
Verify permissions
Check authentication
Monitor access patterns
​
Getting help
When encountering issues:
First Steps
Check server logs
Test with
Inspector
Review configuration
Verify environment
Support Channels
GitHub issues
GitHub discussions
Providing Information
Log excerpts
Configuration files
Steps to reproduce
Environment details
​
Next steps
MCP Inspector
Learn to use the MCP Inspector
Was this page helpful?
Yes
No
Building MCP with LLMs
Inspector
github
On this page
Debugging tools overview
Debugging in Claude Desktop
Checking server status
Viewing logs
Using Chrome DevTools
Common issues
Working directory
Environment variables
Server initialization
Connection problems
Implementing logging
Server-side logging
Client-side logging
Debugging workflow
Development cycle
Testing changes
Best practices
Logging strategy
Security considerations
Getting help
Next steps
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/docs/tools/inspector

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Tutorials
Inspector
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
Building MCP with LLMs
Debugging
Inspector
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Tutorials
Copy page
Inspector
In-depth guide to using the MCP Inspector for testing and debugging Model Context Protocol servers
The
MCP Inspector
is an interactive developer tool for testing and debugging MCP servers. While the
Debugging Guide
covers the Inspector as part of the overall debugging toolkit, this document provides a detailed exploration of the Inspector’s features and capabilities.
​
Getting started
​
Installation and basic usage
The Inspector runs directly through
npx
without requiring installation:
Copy
npx
@modelcontextprotocol/inspector
<
comman
d
>
Copy
npx
@modelcontextprotocol/inspector
<
comman
d
>
<
arg
1>
<
arg
2>
​
Inspecting servers from NPM or PyPi
A common way to start server packages from
NPM
or
PyPi
.
NPM package
PyPi package
Copy
npx
-y
@modelcontextprotocol/inspector
npx
<
package-nam
e
>
<
arg
s
>
# For example
npx
-y
@modelcontextprotocol/inspector
npx
@modelcontextprotocol/server-filesystem
/Users/username/Desktop
Copy
npx
-y
@modelcontextprotocol/inspector
npx
<
package-nam
e
>
<
arg
s
>
# For example
npx
-y
@modelcontextprotocol/inspector
npx
@modelcontextprotocol/server-filesystem
/Users/username/Desktop
Copy
npx
@modelcontextprotocol/inspector
uvx
<
package-nam
e
>
<
arg
s
>
# For example
npx
@modelcontextprotocol/inspector
uvx
mcp-server-git
--repository
~/code/mcp/servers.git
​
Inspecting locally developed servers
To inspect servers locally developed or downloaded as a repository, the most common
way is:
TypeScript
Python
Copy
npx
@modelcontextprotocol/inspector
node
path/to/server/index.js
args...
Copy
npx
@modelcontextprotocol/inspector
node
path/to/server/index.js
args...
Copy
npx
@modelcontextprotocol/inspector
\
uv
\
--directory
path/to/server
\
run
\
package-name
\
args...
Please carefully read any attached README for the most accurate instructions.
​
Feature overview
The MCP Inspector interface
The Inspector provides several features for interacting with your MCP server:
​
Server connection pane
Allows selecting the
transport
for connecting to the server
For local servers, supports customizing the command-line arguments and environment
​
Resources tab
Lists all available resources
Shows resource metadata (MIME types, descriptions)
Allows resource content inspection
Supports subscription testing
​
Prompts tab
Displays available prompt templates
Shows prompt arguments and descriptions
Enables prompt testing with custom arguments
Previews generated messages
​
Tools tab
Lists available tools
Shows tool schemas and descriptions
Enables tool testing with custom inputs
Displays tool execution results
​
Notifications pane
Presents all logs recorded from the server
Shows notifications received from the server
​
Best practices
​
Development workflow
Start Development
Launch Inspector with your server
Verify basic connectivity
Check capability negotiation
Iterative testing
Make server changes
Rebuild the server
Reconnect the Inspector
Test affected features
Monitor messages
Test edge cases
Invalid inputs
Missing prompt arguments
Concurrent operations
Verify error handling and error responses
​
Next steps
Inspector Repository
Check out the MCP Inspector source code
Debugging Guide
Learn about broader debugging strategies
Was this page helpful?
Yes
No
Debugging
FAQs
github
On this page
Getting started
Installation and basic usage
Inspecting servers from NPM or PyPi
Inspecting locally developed servers
Feature overview
Server connection pane
Resources tab
Prompts tab
Tools tab
Notifications pane
Best practices
Development workflow
Next steps
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/examples

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Examples
Example Servers
User Guide
Introduction
Quickstart
Concepts
Examples
Example Servers
Example Clients
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Examples
Copy page
Example Servers
A list of example servers and implementations
This page showcases various Model Context Protocol (MCP) servers that demonstrate the protocol’s capabilities and versatility. These servers enable Large Language Models (LLMs) to securely access tools and data sources.
​
Reference implementations
These official reference servers demonstrate core MCP features and SDK usage:
​
Current reference servers
Filesystem
- Secure file operations with configurable access controls
Fetch
- Web content fetching and conversion optimized for LLM usage
Memory
- Knowledge graph-based persistent memory system
Sequential Thinking
- Dynamic problem-solving through thought sequences
​
Archived servers (historical reference)
⚠️
Note
: The following servers have been moved to the
servers-archived repository
and are no longer actively maintained. They are provided for historical reference only.
​
Data and file systems
PostgreSQL
- Read-only database access with schema inspection capabilities
SQLite
- Database interaction and business intelligence features
Google Drive
- File access and search capabilities for Google Drive
​
Development tools
Git
- Tools to read, search, and manipulate Git repositories
GitHub
- Repository management, file operations, and GitHub API integration
GitLab
- GitLab API integration enabling project management
Sentry
- Retrieving and analyzing issues from Sentry.io
​
Web and browser automation
Brave Search
- Web and local search using Brave’s Search API
Puppeteer
- Browser automation and web scraping capabilities
​
Productivity and communication
Slack
- Channel management and messaging capabilities
Google Maps
- Location services, directions, and place details
​
AI and specialized tools
EverArt
- AI image generation using various models
AWS KB Retrieval
- Retrieval from AWS Knowledge Base using Bedrock Agent Runtime
​
Official integrations
Visit the
MCP Servers Repository (Official Integrations section)
for a list of MCP servers maintained by companies for their platforms.
​
Community implementations
Visit the
MCP Servers Repository (Community section)
for a list of MCP servers maintained by community members.
​
Getting started
​
Using reference servers
TypeScript-based servers can be used directly with
npx
:
Copy
npx
-y
@modelcontextprotocol/server-memory
Python-based servers can be used with
uvx
(recommended) or
pip
:
Copy
# Using uvx
uvx
mcp-server-git
# Using pip
pip
install
mcp-server-git
python
-m
mcp_server_git
​
Configuring with Claude
To use an MCP server with Claude, add it to your configuration:
Copy
{
"mcpServers"
: {
"memory"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-memory"
]
},
"filesystem"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-filesystem"
,
"/path/to/allowed/files"
]
},
"github"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-github"
],
"env"
: {
"GITHUB_PERSONAL_ACCESS_TOKEN"
:
"<YOUR_TOKEN>"
}
}
}
}
​
Additional resources
Visit the
MCP Servers Repository (Resources section)
for a collection of other resources and projects related to MCP.
Visit our
GitHub Discussions
to engage with the MCP community.
Was this page helpful?
Yes
No
Transports
Example Clients
github
On this page
Reference implementations
Current reference servers
Archived servers (historical reference)
Data and file systems
Development tools
Web and browser automation
Productivity and communication
AI and specialized tools
Official integrations
Community implementations
Getting started
Using reference servers
Configuring with Claude
Additional resources
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/faqs

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
User Guide
FAQs
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
User Guide
Copy page
FAQs
Explaining MCP and why it matters in simple terms
​
What is MCP?
MCP (Model Context Protocol) is a standard way for AI applications and agents to connect to and work with your data sources (e.g. local files, databases, or content repositories) and tools (e.g. GitHub, Google Maps, or Puppeteer).
Think of MCP as a universal adapter for AI applications, similar to what USB-C is for physical devices. USB-C acts as a universal adapter to connect devices to various peripherals and accessories. Similarly, MCP provides a standardized way to connect AI applications to different data and tools.
Before USB-C, you needed different cables for different connections. Similarly, before MCP, developers had to build custom connections to each data source or tool they wanted their AI application to work with—a time-consuming process that often resulted in limited functionality. Now, with MCP, developers can easily add connections to their AI applications, making their applications much more powerful from day one.
​
Why does MCP matter?
​
For AI application users
MCP means your AI applications can access the information and tools you work with every day, making them much more helpful. Rather than AI being limited to what it already knows about, it can now understand your specific documents, data, and work context.
For example, by using MCP servers, applications can access your personal documents from Google Drive or data about your codebase from GitHub, providing more personalized and contextually relevant assistance.
Imagine asking an AI assistant: “Summarize last week’s team meeting notes and schedule follow-ups with everyone.”
By using connections to data sources powered by MCP, the AI assistant can:
Connect to your Google Drive through an MCP server to read meeting notes
Understand who needs follow-ups based on the notes
Connect to your calendar through another MCP server to schedule the meetings automatically
​
For developers
MCP reduces development time and complexity when building AI applications that need to access various data sources. With MCP, developers can focus on building great AI experiences rather than repeatedly creating custom connectors.
Traditionally, connecting applications with data sources required building custom, one-off connections for each data source and each application. This created significant duplicative work—every developer wanting to connect their AI application to Google Drive or Slack needed to build their own connection.
MCP simplifies this by enabling developers to build MCP servers for data sources that are then reusable by various applications. For example, using the open source Google Drive MCP server, many different applications can access data from Google Drive without each developer needing to build a custom connection.
This open source ecosystem of MCP servers means developers can leverage existing work rather than starting from scratch, making it easier to build powerful AI applications that seamlessly integrate with the tools and data sources their users already rely on.
​
How does MCP work?
MCP creates a bridge between your AI applications and your data through a straightforward system:
MCP servers
connect to your data sources and tools (like Google Drive or Slack)
MCP clients
are run by AI applications (like Claude Desktop) to connect them to these servers
When you give permission, your AI application discovers available MCP servers
The AI model can then use these connections to read information and take actions
This modular system means new capabilities can be added without changing AI applications themselves—just like adding new accessories to your computer without upgrading your entire system.
​
Who creates and maintains MCP servers?
MCP servers are developed and maintained by:
Developers at Anthropic who build servers for common tools and data sources
Open source contributors who create servers for tools they use
Enterprise development teams building servers for their internal systems
Software providers making their applications AI-ready
Once an open source MCP server is created for a data source, it can be used by any MCP-compatible AI application, creating a growing ecosystem of connections. See our
list of example servers
, or
get started building your own server
.
Was this page helpful?
Yes
No
Inspector
Specification
github
On this page
What is MCP?
Why does MCP matter?
For AI application users
For developers
How does MCP work?
Who creates and maintains MCP servers?
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/introduction

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
User Guide
Introduction
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
User Guide
Copy page
Introduction
Get started with the Model Context Protocol (MCP)
MCP is an open protocol that standardizes how applications provide context to LLMs. Think of MCP like a USB-C port for AI applications. Just as USB-C provides a standardized way to connect your devices to various peripherals and accessories, MCP provides a standardized way to connect AI models to different data sources and tools.
​
Why MCP?
MCP helps you build agents and complex workflows on top of LLMs. LLMs frequently need to integrate with data and tools, and MCP provides:
A growing list of pre-built integrations that your LLM can directly plug into
The flexibility to switch between LLM providers and vendors
Best practices for securing your data within your infrastructure
​
General architecture
At its core, MCP follows a client-server architecture where a host application can connect to multiple servers:
MCP Hosts
: Programs like Claude Desktop, IDEs, or AI tools that want to access data through MCP
MCP Clients
: Protocol clients that maintain 1:1 connections with servers
MCP Servers
: Lightweight programs that each expose specific capabilities through the standardized Model Context Protocol
Local Data Sources
: Your computer’s files, databases, and services that MCP servers can securely access
Remote Services
: External systems available over the internet (e.g., through APIs) that MCP servers can connect to
​
Get started
Choose the path that best fits your needs:
​
Quick Starts
For Server Developers
Get started building your own server to use in Claude for Desktop and other
clients
For Client Developers
Get started building your own client that can integrate with all MCP servers
For Claude Desktop Users
Get started using pre-built servers in Claude for Desktop
​
Examples
Example Servers
Check out our gallery of official MCP servers and implementations
Example Clients
View the list of clients that support MCP integrations
​
Tutorials
Building MCP with LLMs
Learn how to use LLMs like Claude to speed up your MCP development
Debugging Guide
Learn how to effectively debug MCP servers and integrations
MCP Inspector
Test and inspect your MCP servers with our interactive debugging tool
MCP Workshop (Video, 2hr)
​
Explore MCP
Dive deeper into MCP’s core concepts and capabilities:
Core architecture
Understand how MCP connects clients, servers, and LLMs
Resources
Expose data and content from your servers to LLMs
Prompts
Create reusable prompt templates and workflows
Tools
Enable LLMs to perform actions through your server
Sampling
Let your servers request completions from LLMs
Transports
Learn about MCP’s communication mechanism
​
Contributing
Want to contribute? Check out our
Contributing Guide
to learn how you can help improve MCP.
​
Support and Feedback
Here’s how to get help or provide feedback:
For bug reports and feature requests related to the MCP specification, SDKs, or documentation (open source), please
create a GitHub issue
For discussions or Q&A about the MCP specification, use the
specification discussions
For discussions or Q&A about other MCP open source components, use the
organization discussions
For bug reports, feature requests, and questions related to Claude.app and claude.ai’s MCP integration, please see Anthropic’s guide on
How to Get Support
Was this page helpful?
Yes
No
For Server Developers
github
On this page
Why MCP?
General architecture
Get started
Quick Starts
Examples
Tutorials
Explore MCP
Contributing
Support and Feedback
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/quickstart/client

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Quickstart
For Client Developers
User Guide
Introduction
Quickstart
For Server Developers
For Client Developers
For Claude Desktop Users
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Quickstart
Copy page
For Client Developers
Get started building your own client that can integrate with all MCP servers.
In this tutorial, you’ll learn how to build an LLM-powered chatbot client that connects to MCP servers. It helps to have gone through the
Server quickstart
that guides you through the basics of building your first server.
Python
Node
Java
Kotlin
C#
You can find the complete code for this tutorial here.
​
System Requirements
Before starting, ensure your system meets these requirements:
Mac or Windows computer
Latest Python version installed
Latest version of
uv
installed
​
Setting Up Your Environment
First, create a new Python project with
uv
:
Copy
# Create project directory
uv
init
mcp-client
cd
mcp-client
# Create virtual environment
uv
venv
# Activate virtual environment
# On Windows:
.venv\Scripts\activate
# On Unix or MacOS:
source
.venv/bin/activate
# Install required packages
uv
add
mcp
anthropic
python-dotenv
# Remove boilerplate files
# On Windows:
del
main.py
# On Unix or MacOS:
rm
main.py
# Create our main file
touch
client.py
​
Setting Up Your API Key
You’ll need an Anthropic API key from the
Anthropic Console
.
Create a
.env
file to store it:
Copy
# Create .env file
touch
.env
Add your key to the
.env
file:
Copy
ANTHROPIC_API_KEY
=<
your
key
her
e
>
Add
.env
to your
.gitignore
:
Copy
echo
".env"
>>
.gitignore
Make sure you keep your
ANTHROPIC_API_KEY
secure!
​
Creating the Client
​
Basic Client Structure
First, let’s set up our imports and create the basic client class:
Copy
import
asyncio
from
typing
import
Optional
from
contextlib
import
AsyncExitStack
from
mcp
import
ClientSession, StdioServerParameters
from
mcp.client.stdio
import
stdio_client
from
anthropic
import
Anthropic
from
dotenv
import
load_dotenv
load_dotenv()
# load environment variables from .env
class
MCPClient
:
def
__init__
(
self
):
# Initialize session and client objects
self
.session: Optional[ClientSession]
=
None
self
.exit_stack
=
AsyncExitStack()
self
.anthropic
=
Anthropic()
# methods will go here
​
Server Connection Management
Next, we’ll implement the method to connect to an MCP server:
Copy
async
def
connect_to_server
(
self
,
server_script_path
:
str
):
"""Connect to an MCP server
Args:
server_script_path: Path to the server script (.py or .js)
"""
is_python
=
server_script_path.endswith(
'.py'
)
is_js
=
server_script_path.endswith(
'.js'
)
if
not
(is_python
or
is_js):
raise
ValueError
(
"Server script must be a .py or .js file"
)
command
=
"python"
if
is_python
else
"node"
server_params
=
StdioServerParameters(
command
=
command,
args
=
[server_script_path],
env
=
None
)
stdio_transport
=
await
self
.exit_stack.enter_async_context(stdio_client(server_params))
self
.stdio,
self
.write
=
stdio_transport
self
.session
=
await
self
.exit_stack.enter_async_context(ClientSession(
self
.stdio,
self
.write))
await
self
.session.initialize()
# List available tools
response
=
await
self
.session.list_tools()
tools
=
response.tools
print
(
"
\n
Connected to server with tools:"
, [tool.name
for
tool
in
tools])
​
Query Processing Logic
Now let’s add the core functionality for processing queries and handling tool calls:
Copy
async
def
process_query
(
self
,
query
:
str
) ->
str
:
"""Process a query using Claude and available tools"""
messages
=
[
{
"role"
:
"user"
,
"content"
: query
}
]
response
=
await
self
.session.list_tools()
available_tools
=
[{
"name"
: tool.name,
"description"
: tool.description,
"input_schema"
: tool.inputSchema
}
for
tool
in
response.tools]
# Initial Claude API call
response
=
self
.anthropic.messages.create(
model
=
"claude-3-5-sonnet-20241022"
,
max_tokens
=
1000
,
messages
=
messages,
tools
=
available_tools
)
# Process response and handle tool calls
final_text
=
[]
assistant_message_content
=
[]
for
content
in
response.content:
if
content.type
==
'text'
:
final_text.append(content.text)
assistant_message_content.append(content)
elif
content.type
==
'tool_use'
:
tool_name
=
content.name
tool_args
=
content.input
# Execute tool call
result
=
await
self
.session.call_tool(tool_name, tool_args)
final_text.append(
f
"[Calling tool
{
tool_name
}
with args
{
tool_args
}
]"
)
assistant_message_content.append(content)
messages.append({
"role"
:
"assistant"
,
"content"
: assistant_message_content
})
messages.append({
"role"
:
"user"
,
"content"
: [
{
"type"
:
"tool_result"
,
"tool_use_id"
: content.id,
"content"
: result.content
}
]
})
# Get next response from Claude
response
=
self
.anthropic.messages.create(
model
=
"claude-3-5-sonnet-20241022"
,
max_tokens
=
1000
,
messages
=
messages,
tools
=
available_tools
)
final_text.append(response.content[
0
].text)
return
"
\n
"
.join(final_text)
​
Interactive Chat Interface
Now we’ll add the chat loop and cleanup functionality:
Copy
async
def
chat_loop
(
self
):
"""Run an interactive chat loop"""
print
(
"
\n
MCP Client Started!"
)
print
(
"Type your queries or 'quit' to exit."
)
while
True
:
try
:
query
=
input
(
"
\n
Query: "
).strip()
if
query.lower()
==
'quit'
:
break
response
=
await
self
.process_query(query)
print
(
"
\n
"
+
response)
except
Exception
as
e:
print
(
f
"
\n
Error:
{
str
(e)
}
"
)
async
def
cleanup
(
self
):
"""Clean up resources"""
await
self
.exit_stack.aclose()
​
Main Entry Point
Finally, we’ll add the main execution logic:
Copy
async
def
main
():
if
len
(sys.argv)
<
2
:
print
(
"Usage: python client.py <path_to_server_script>"
)
sys.exit(
1
)
client
=
MCPClient()
try
:
await
client.connect_to_server(sys.argv[
1
])
await
client.chat_loop()
finally
:
await
client.cleanup()
if
__name__
==
"__main__"
:
import
sys
asyncio.run(main())
You can find the complete
client.py
file
here.
​
Key Components Explained
​
1. Client Initialization
The
MCPClient
class initializes with session management and API clients
Uses
AsyncExitStack
for proper resource management
Configures the Anthropic client for Claude interactions
​
2. Server Connection
Supports both Python and Node.js servers
Validates server script type
Sets up proper communication channels
Initializes the session and lists available tools
​
3. Query Processing
Maintains conversation context
Handles Claude’s responses and tool calls
Manages the message flow between Claude and tools
Combines results into a coherent response
​
4. Interactive Interface
Provides a simple command-line interface
Handles user input and displays responses
Includes basic error handling
Allows graceful exit
​
5. Resource Management
Proper cleanup of resources
Error handling for connection issues
Graceful shutdown procedures
​
Common Customization Points
Tool Handling
Modify
process_query()
to handle specific tool types
Add custom error handling for tool calls
Implement tool-specific response formatting
Response Processing
Customize how tool results are formatted
Add response filtering or transformation
Implement custom logging
User Interface
Add a GUI or web interface
Implement rich console output
Add command history or auto-completion
​
Running the Client
To run your client with any MCP server:
Copy
uv
run
client.py
path/to/server.py
# python server
uv
run
client.py
path/to/build/index.js
# node server
If you’re continuing the weather tutorial from the server quickstart, your command might look something like this:
python client.py .../quickstart-resources/weather-server-python/weather.py
The client will:
Connect to the specified server
List available tools
Start an interactive chat session where you can:
Enter queries
See tool executions
Get responses from Claude
Here’s an example of what it should look like if connected to the weather server from the server quickstart:
​
How It Works
When you submit a query:
The client gets the list of available tools from the server
Your query is sent to Claude along with tool descriptions
Claude decides which tools (if any) to use
The client executes any requested tool calls through the server
Results are sent back to Claude
Claude provides a natural language response
The response is displayed to you
​
Best practices
Error Handling
Always wrap tool calls in try-catch blocks
Provide meaningful error messages
Gracefully handle connection issues
Resource Management
Use
AsyncExitStack
for proper cleanup
Close connections when done
Handle server disconnections
Security
Store API keys securely in
.env
Validate server responses
Be cautious with tool permissions
​
Troubleshooting
​
Server Path Issues
Double-check the path to your server script is correct
Use the absolute path if the relative path isn’t working
For Windows users, make sure to use forward slashes (/) or escaped backslashes (\) in the path
Verify the server file has the correct extension (.py for Python or .js for Node.js)
Example of correct path usage:
Copy
# Relative path
uv
run
client.py
./server/weather.py
# Absolute path
uv
run
client.py
/Users/username/projects/mcp-server/weather.py
# Windows path (either format works)
uv
run
client.py
C:/projects/mcp-server/weather.py
uv
run
client.py
C:
\\
projects
\\
mcp-server
\\
weather.py
​
Response Timing
The first response might take up to 30 seconds to return
This is normal and happens while:
The server initializes
Claude processes the query
Tools are being executed
Subsequent responses are typically faster
Don’t interrupt the process during this initial waiting period
​
Common Error Messages
If you see:
FileNotFoundError
: Check your server path
Connection refused
: Ensure the server is running and the path is correct
Tool execution failed
: Verify the tool’s required environment variables are set
Timeout error
: Consider increasing the timeout in your client configuration
You can find the complete code for this tutorial here.
​
System Requirements
Before starting, ensure your system meets these requirements:
Mac or Windows computer
Latest Python version installed
Latest version of
uv
installed
​
Setting Up Your Environment
First, create a new Python project with
uv
:
Copy
# Create project directory
uv
init
mcp-client
cd
mcp-client
# Create virtual environment
uv
venv
# Activate virtual environment
# On Windows:
.venv\Scripts\activate
# On Unix or MacOS:
source
.venv/bin/activate
# Install required packages
uv
add
mcp
anthropic
python-dotenv
# Remove boilerplate files
# On Windows:
del
main.py
# On Unix or MacOS:
rm
main.py
# Create our main file
touch
client.py
​
Setting Up Your API Key
You’ll need an Anthropic API key from the
Anthropic Console
.
Create a
.env
file to store it:
Copy
# Create .env file
touch
.env
Add your key to the
.env
file:
Copy
ANTHROPIC_API_KEY
=<
your
key
her
e
>
Add
.env
to your
.gitignore
:
Copy
echo
".env"
>>
.gitignore
Make sure you keep your
ANTHROPIC_API_KEY
secure!
​
Creating the Client
​
Basic Client Structure
First, let’s set up our imports and create the basic client class:
Copy
import
asyncio
from
typing
import
Optional
from
contextlib
import
AsyncExitStack
from
mcp
import
ClientSession, StdioServerParameters
from
mcp.client.stdio
import
stdio_client
from
anthropic
import
Anthropic
from
dotenv
import
load_dotenv
load_dotenv()
# load environment variables from .env
class
MCPClient
:
def
__init__
(
self
):
# Initialize session and client objects
self
.session: Optional[ClientSession]
=
None
self
.exit_stack
=
AsyncExitStack()
self
.anthropic
=
Anthropic()
# methods will go here
​
Server Connection Management
Next, we’ll implement the method to connect to an MCP server:
Copy
async
def
connect_to_server
(
self
,
server_script_path
:
str
):
"""Connect to an MCP server
Args:
server_script_path: Path to the server script (.py or .js)
"""
is_python
=
server_script_path.endswith(
'.py'
)
is_js
=
server_script_path.endswith(
'.js'
)
if
not
(is_python
or
is_js):
raise
ValueError
(
"Server script must be a .py or .js file"
)
command
=
"python"
if
is_python
else
"node"
server_params
=
StdioServerParameters(
command
=
command,
args
=
[server_script_path],
env
=
None
)
stdio_transport
=
await
self
.exit_stack.enter_async_context(stdio_client(server_params))
self
.stdio,
self
.write
=
stdio_transport
self
.session
=
await
self
.exit_stack.enter_async_context(ClientSession(
self
.stdio,
self
.write))
await
self
.session.initialize()
# List available tools
response
=
await
self
.session.list_tools()
tools
=
response.tools
print
(
"
\n
Connected to server with tools:"
, [tool.name
for
tool
in
tools])
​
Query Processing Logic
Now let’s add the core functionality for processing queries and handling tool calls:
Copy
async
def
process_query
(
self
,
query
:
str
) ->
str
:
"""Process a query using Claude and available tools"""
messages
=
[
{
"role"
:
"user"
,
"content"
: query
}
]
response
=
await
self
.session.list_tools()
available_tools
=
[{
"name"
: tool.name,
"description"
: tool.description,
"input_schema"
: tool.inputSchema
}
for
tool
in
response.tools]
# Initial Claude API call
response
=
self
.anthropic.messages.create(
model
=
"claude-3-5-sonnet-20241022"
,
max_tokens
=
1000
,
messages
=
messages,
tools
=
available_tools
)
# Process response and handle tool calls
final_text
=
[]
assistant_message_content
=
[]
for
content
in
response.content:
if
content.type
==
'text'
:
final_text.append(content.text)
assistant_message_content.append(content)
elif
content.type
==
'tool_use'
:
tool_name
=
content.name
tool_args
=
content.input
# Execute tool call
result
=
await
self
.session.call_tool(tool_name, tool_args)
final_text.append(
f
"[Calling tool
{
tool_name
}
with args
{
tool_args
}
]"
)
assistant_message_content.append(content)
messages.append({
"role"
:
"assistant"
,
"content"
: assistant_message_content
})
messages.append({
"role"
:
"user"
,
"content"
: [
{
"type"
:
"tool_result"
,
"tool_use_id"
: content.id,
"content"
: result.content
}
]
})
# Get next response from Claude
response
=
self
.anthropic.messages.create(
model
=
"claude-3-5-sonnet-20241022"
,
max_tokens
=
1000
,
messages
=
messages,
tools
=
available_tools
)
final_text.append(response.content[
0
].text)
return
"
\n
"
.join(final_text)
​
Interactive Chat Interface
Now we’ll add the chat loop and cleanup functionality:
Copy
async
def
chat_loop
(
self
):
"""Run an interactive chat loop"""
print
(
"
\n
MCP Client Started!"
)
print
(
"Type your queries or 'quit' to exit."
)
while
True
:
try
:
query
=
input
(
"
\n
Query: "
).strip()
if
query.lower()
==
'quit'
:
break
response
=
await
self
.process_query(query)
print
(
"
\n
"
+
response)
except
Exception
as
e:
print
(
f
"
\n
Error:
{
str
(e)
}
"
)
async
def
cleanup
(
self
):
"""Clean up resources"""
await
self
.exit_stack.aclose()
​
Main Entry Point
Finally, we’ll add the main execution logic:
Copy
async
def
main
():
if
len
(sys.argv)
<
2
:
print
(
"Usage: python client.py <path_to_server_script>"
)
sys.exit(
1
)
client
=
MCPClient()
try
:
await
client.connect_to_server(sys.argv[
1
])
await
client.chat_loop()
finally
:
await
client.cleanup()
if
__name__
==
"__main__"
:
import
sys
asyncio.run(main())
You can find the complete
client.py
file
here.
​
Key Components Explained
​
1. Client Initialization
The
MCPClient
class initializes with session management and API clients
Uses
AsyncExitStack
for proper resource management
Configures the Anthropic client for Claude interactions
​
2. Server Connection
Supports both Python and Node.js servers
Validates server script type
Sets up proper communication channels
Initializes the session and lists available tools
​
3. Query Processing
Maintains conversation context
Handles Claude’s responses and tool calls
Manages the message flow between Claude and tools
Combines results into a coherent response
​
4. Interactive Interface
Provides a simple command-line interface
Handles user input and displays responses
Includes basic error handling
Allows graceful exit
​
5. Resource Management
Proper cleanup of resources
Error handling for connection issues
Graceful shutdown procedures
​
Common Customization Points
Tool Handling
Modify
process_query()
to handle specific tool types
Add custom error handling for tool calls
Implement tool-specific response formatting
Response Processing
Customize how tool results are formatted
Add response filtering or transformation
Implement custom logging
User Interface
Add a GUI or web interface
Implement rich console output
Add command history or auto-completion
​
Running the Client
To run your client with any MCP server:
Copy
uv
run
client.py
path/to/server.py
# python server
uv
run
client.py
path/to/build/index.js
# node server
If you’re continuing the weather tutorial from the server quickstart, your command might look something like this:
python client.py .../quickstart-resources/weather-server-python/weather.py
The client will:
Connect to the specified server
List available tools
Start an interactive chat session where you can:
Enter queries
See tool executions
Get responses from Claude
Here’s an example of what it should look like if connected to the weather server from the server quickstart:
​
How It Works
When you submit a query:
The client gets the list of available tools from the server
Your query is sent to Claude along with tool descriptions
Claude decides which tools (if any) to use
The client executes any requested tool calls through the server
Results are sent back to Claude
Claude provides a natural language response
The response is displayed to you
​
Best practices
Error Handling
Always wrap tool calls in try-catch blocks
Provide meaningful error messages
Gracefully handle connection issues
Resource Management
Use
AsyncExitStack
for proper cleanup
Close connections when done
Handle server disconnections
Security
Store API keys securely in
.env
Validate server responses
Be cautious with tool permissions
​
Troubleshooting
​
Server Path Issues
Double-check the path to your server script is correct
Use the absolute path if the relative path isn’t working
For Windows users, make sure to use forward slashes (/) or escaped backslashes (\) in the path
Verify the server file has the correct extension (.py for Python or .js for Node.js)
Example of correct path usage:
Copy
# Relative path
uv
run
client.py
./server/weather.py
# Absolute path
uv
run
client.py
/Users/username/projects/mcp-server/weather.py
# Windows path (either format works)
uv
run
client.py
C:/projects/mcp-server/weather.py
uv
run
client.py
C:
\\
projects
\\
mcp-server
\\
weather.py
​
Response Timing
The first response might take up to 30 seconds to return
This is normal and happens while:
The server initializes
Claude processes the query
Tools are being executed
Subsequent responses are typically faster
Don’t interrupt the process during this initial waiting period
​
Common Error Messages
If you see:
FileNotFoundError
: Check your server path
Connection refused
: Ensure the server is running and the path is correct
Tool execution failed
: Verify the tool’s required environment variables are set
Timeout error
: Consider increasing the timeout in your client configuration
You can find the complete code for this tutorial here.
​
System Requirements
Before starting, ensure your system meets these requirements:
Mac or Windows computer
Node.js 17 or higher installed
Latest version of
npm
installed
Anthropic API key (Claude)
​
Setting Up Your Environment
First, let’s create and set up our project:
MacOS/Linux
Windows
Copy
# Create project directory
mkdir
mcp-client-typescript
cd
mcp-client-typescript
# Initialize npm project
npm
init
-y
# Install dependencies
npm
install
@anthropic-ai/sdk
@modelcontextprotocol/sdk
dotenv
# Install dev dependencies
npm
install
-D
@types/node
typescript
# Create source file
touch
index.ts
Update your
package.json
to set
type: "module"
and a build script:
package.json
Copy
{
"type"
:
"module"
,
"scripts"
: {
"build"
:
"tsc && chmod 755 build/index.js"
}
}
Create a
tsconfig.json
in the root of your project:
tsconfig.json
Copy
{
"compilerOptions"
: {
"target"
:
"ES2022"
,
"module"
:
"Node16"
,
"moduleResolution"
:
"Node16"
,
"outDir"
:
"./build"
,
"rootDir"
:
"./"
,
"strict"
:
true
,
"esModuleInterop"
:
true
,
"skipLibCheck"
:
true
,
"forceConsistentCasingInFileNames"
:
true
},
"include"
: [
"index.ts"
],
"exclude"
: [
"node_modules"
]
}
​
Setting Up Your API Key
You’ll need an Anthropic API key from the
Anthropic Console
.
Create a
.env
file to store it:
Copy
echo
"ANTHROPIC_API_KEY=<your key here>"
>
.env
Add
.env
to your
.gitignore
:
Copy
echo
".env"
>>
.gitignore
Make sure you keep your
ANTHROPIC_API_KEY
secure!
​
Creating the Client
​
Basic Client Structure
First, let’s set up our imports and create the basic client class in
index.ts
:
Copy
import
{
Anthropic
}
from
"@anthropic-ai/sdk"
;
import
{
MessageParam
,
Tool
,
}
from
"@anthropic-ai/sdk/resources/messages/messages.mjs"
;
import
{
Client
}
from
"@modelcontextprotocol/sdk/client/index.js"
;
import
{
StdioClientTransport
}
from
"@modelcontextprotocol/sdk/client/stdio.js"
;
import
readline
from
"readline/promises"
;
import
dotenv
from
"dotenv"
;
dotenv
.
config
();
const
ANTHROPIC_API_KEY
=
process
.
env
.
ANTHROPIC_API_KEY
;
if
(
!
ANTHROPIC_API_KEY
) {
throw
new
Error
(
"ANTHROPIC_API_KEY is not set"
);
}
class
MCPClient
{
private
mcp
:
Client
;
private
anthropic
:
Anthropic
;
private
transport
:
StdioClientTransport
|
null
=
null
;
private
tools
:
Tool
[]
=
[];
constructor
() {
this
.
anthropic
=
new
Anthropic
({
apiKey:
ANTHROPIC_API_KEY
,
});
this
.
mcp
=
new
Client
({
name:
"mcp-client-cli"
,
version:
"1.0.0"
});
}
// methods will go here
}
​
Server Connection Management
Next, we’ll implement the method to connect to an MCP server:
Copy
async
connectToServer
(
serverScriptPath
:
string
) {
try
{
const
isJs
=
serverScriptPath
.
endsWith
(
".js"
);
const
isPy
=
serverScriptPath
.
endsWith
(
".py"
);
if
(
!
isJs
&&
!
isPy
) {
throw
new
Error
(
"Server script must be a .js or .py file"
);
}
const
command
=
isPy
?
process
.
platform
===
"win32"
?
"python"
:
"python3"
:
process
.
execPath
;
this
.
transport
=
new
StdioClientTransport
({
command
,
args:
[
serverScriptPath
],
});
await
this
.
mcp
.
connect
(
this
.
transport
);
const
toolsResult
=
await
this
.
mcp
.
listTools
();
this
.
tools
=
toolsResult
.
tools
.
map
((
tool
)
=>
{
return
{
name:
tool
.
name
,
description:
tool
.
description
,
input_schema:
tool
.
inputSchema
,
};
});
console
.
log
(
"Connected to server with tools:"
,
this
.
tools
.
map
(({
name
})
=>
name
)
);
}
catch
(
e
) {
console
.
log
(
"Failed to connect to MCP server: "
,
e
);
throw
e
;
}
}
​
Query Processing Logic
Now let’s add the core functionality for processing queries and handling tool calls:
Copy
async
processQuery
(
query
:
string
) {
const
messages
:
MessageParam
[]
=
[
{
role:
"user"
,
content:
query
,
},
];
const
response
=
await
this
.
anthropic
.
messages
.
create
({
model:
"claude-3-5-sonnet-20241022"
,
max_tokens:
1000
,
messages
,
tools:
this
.
tools
,
});
const
finalText
=
[];
for
(
const
content
of
response
.
content
) {
if
(
content
.
type
===
"text"
) {
finalText
.
push
(
content
.
text
);
}
else
if
(
content
.
type
===
"tool_use"
) {
const
toolName
=
content
.
name
;
const
toolArgs
=
content
.
input
as
{ [
x
:
string
]
:
unknown
}
|
undefined
;
const
result
=
await
this
.
mcp
.
callTool
({
name:
toolName
,
arguments:
toolArgs
,
});
finalText
.
push
(
`[Calling tool
${
toolName
}
with args
${
JSON
.
stringify
(
toolArgs
)
}
]`
);
messages
.
push
({
role:
"user"
,
content:
result
.
content
as
string
,
});
const
response
=
await
this
.
anthropic
.
messages
.
create
({
model:
"claude-3-5-sonnet-20241022"
,
max_tokens:
1000
,
messages
,
});
finalText
.
push
(
response
.
content
[
0
].
type
===
"text"
?
response
.
content
[
0
].
text
:
""
);
}
}
return
finalText
.
join
(
"
\n
"
);
}
​
Interactive Chat Interface
Now we’ll add the chat loop and cleanup functionality:
Copy
async
chatLoop
() {
const
rl
=
readline
.
createInterface
({
input:
process
.
stdin
,
output:
process
.
stdout
,
});
try
{
console
.
log
(
"
\n
MCP Client Started!"
);
console
.
log
(
"Type your queries or 'quit' to exit."
);
while
(
true
) {
const
message
=
await
rl
.
question
(
"
\n
Query: "
);
if
(
message
.
toLowerCase
()
===
"quit"
) {
break
;
}
const
response
=
await
this
.
processQuery
(
message
);
console
.
log
(
"
\n
"
+
response
);
}
}
finally
{
rl
.
close
();
}
}
async
cleanup
() {
await
this
.
mcp
.
close
();
}
​
Main Entry Point
Finally, we’ll add the main execution logic:
Copy
async
function
main
() {
if
(
process
.
argv
.
length
<
3
) {
console
.
log
(
"Usage: node index.ts <path_to_server_script>"
);
return
;
}
const
mcpClient
=
new
MCPClient
();
try
{
await
mcpClient
.
connectToServer
(
process
.
argv
[
2
]);
await
mcpClient
.
chatLoop
();
}
finally
{
await
mcpClient
.
cleanup
();
process
.
exit
(
0
);
}
}
main
();
​
Running the Client
To run your client with any MCP server:
Copy
# Build TypeScript
npm
run
build
# Run the client
node
build/index.js
path/to/server.py
# python server
node
build/index.js
path/to/build/index.js
# node server
If you’re continuing the weather tutorial from the server quickstart, your command might look something like this:
node build/index.js .../quickstart-resources/weather-server-typescript/build/index.js
The client will:
Connect to the specified server
List available tools
Start an interactive chat session where you can:
Enter queries
See tool executions
Get responses from Claude
​
How It Works
When you submit a query:
The client gets the list of available tools from the server
Your query is sent to Claude along with tool descriptions
Claude decides which tools (if any) to use
The client executes any requested tool calls through the server
Results are sent back to Claude
Claude provides a natural language response
The response is displayed to you
​
Best practices
Error Handling
Use TypeScript’s type system for better error detection
Wrap tool calls in try-catch blocks
Provide meaningful error messages
Gracefully handle connection issues
Security
Store API keys securely in
.env
Validate server responses
Be cautious with tool permissions
​
Troubleshooting
​
Server Path Issues
Double-check the path to your server script is correct
Use the absolute path if the relative path isn’t working
For Windows users, make sure to use forward slashes (/) or escaped backslashes (\) in the path
Verify the server file has the correct extension (.js for Node.js or .py for Python)
Example of correct path usage:
Copy
# Relative path
node
build/index.js
./server/build/index.js
# Absolute path
node
build/index.js
/Users/username/projects/mcp-server/build/index.js
# Windows path (either format works)
node
build/index.js
C:/projects/mcp-server/build/index.js
node
build/index.js
C:
\\
projects
\\
mcp-server
\\
build
\\
index.js
​
Response Timing
The first response might take up to 30 seconds to return
This is normal and happens while:
The server initializes
Claude processes the query
Tools are being executed
Subsequent responses are typically faster
Don’t interrupt the process during this initial waiting period
​
Common Error Messages
If you see:
Error: Cannot find module
: Check your build folder and ensure TypeScript compilation succeeded
Connection refused
: Ensure the server is running and the path is correct
Tool execution failed
: Verify the tool’s required environment variables are set
ANTHROPIC_API_KEY is not set
: Check your .env file and environment variables
TypeError
: Ensure you’re using the correct types for tool arguments
This is a quickstart demo based on Spring AI MCP auto-configuration and boot starters.
To learn how to create sync and async MCP Clients manually, consult the
Java SDK Client
documentation
This example demonstrates how to build an interactive chatbot that combines Spring AI’s Model Context Protocol (MCP) with the
Brave Search MCP Server
. The application creates a conversational interface powered by Anthropic’s Claude AI model that can perform internet searches through Brave Search, enabling natural language interactions with real-time web data.
You can find the complete code for this tutorial here.
​
System Requirements
Before starting, ensure your system meets these requirements:
Java 17 or higher
Maven 3.6+
npx package manager
Anthropic API key (Claude)
Brave Search API key
​
Setting Up Your Environment
Install npx (Node Package eXecute):
First, make sure to install
npm
and then run:
Copy
npm
install
-g
npx
Clone the repository:
Copy
git
clone
https://github.com/spring-projects/spring-ai-examples.git
cd
model-context-protocol/brave-chatbot
Set up your API keys:
Copy
export
ANTHROPIC_API_KEY
=
'your-anthropic-api-key-here'
export
BRAVE_API_KEY
=
'your-brave-api-key-here'
Build the application:
Copy
./mvnw
clean
install
Run the application using Maven:
Copy
./mvnw
spring-boot:run
Make sure you keep your
ANTHROPIC_API_KEY
and
BRAVE_API_KEY
keys secure!
​
How it Works
The application integrates Spring AI with the Brave Search MCP server through several components:
​
MCP Client Configuration
Required dependencies in pom.xml:
Copy
<
dependency
>
<
groupId
>
org.springframework.ai
</
groupId
>
<
artifactId
>
spring-ai-starter-mcp-client
</
artifactId
>
</
dependency
>
<
dependency
>
<
groupId
>
org.springframework.ai
</
groupId
>
<
artifactId
>
spring-ai-starter-model-anthropic
</
artifactId
>
</
dependency
>
Application properties (application.yml):
Copy
spring
:
ai
:
mcp
:
client
:
enabled
:
true
name
:
brave-search-client
version
:
1.0.0
type
:
SYNC
request-timeout
:
20s
stdio
:
root-change-notification
:
true
servers-configuration
:
classpath:/mcp-servers-config.json
toolcallback
:
enabled
:
true
anthropic
:
api-key
:
${ANTHROPIC_API_KEY}
This activates the
spring-ai-starter-mcp-client
to create one or more
McpClient
s based on the provided server configuration.
The
spring.ai.mcp.client.toolcallback.enabled=true
property enables the tool callback mechanism, that automatically registers all MCP tool as spring ai tools.
It is disabled by default.
MCP Server Configuration (
mcp-servers-config.json
):
Copy
{
"mcpServers"
: {
"brave-search"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-brave-search"
],
"env"
: {
"BRAVE_API_KEY"
:
"<PUT YOUR BRAVE API KEY>"
}
}
}
}
​
Chat Implementation
The chatbot is implemented using Spring AI’s ChatClient with MCP tool integration:
Copy
var
chatClient
=
chatClientBuilder
.
defaultSystem
(
"You are useful assistant, expert in AI and Java."
)
.
defaultToolCallbacks
((
Object
[])
mcpToolAdapter
.
toolCallbacks
())
.
defaultAdvisors
(
new
MessageChatMemoryAdvisor
(
new
InMemoryChatMemory
()))
.
build
();
Breaking change: From SpringAI 1.0.0-M8 onwards, use
.defaultToolCallbacks(...)
instead of
.defaultTool(...)
to register MCP tools.
Key features:
Uses Claude AI model for natural language understanding
Integrates Brave Search through MCP for real-time web search capabilities
Maintains conversation memory using InMemoryChatMemory
Runs as an interactive command-line application
​
Build and run
Copy
./mvnw
clean
install
java
-jar
./target/ai-mcp-brave-chatbot-0.0.1-SNAPSHOT.jar
or
Copy
./mvnw
spring-boot:run
The application will start an interactive chat session where you can ask questions. The chatbot will use Brave Search when it needs to find information from the internet to answer your queries.
The chatbot can:
Answer questions using its built-in knowledge
Perform web searches when needed using Brave Search
Remember context from previous messages in the conversation
Combine information from multiple sources to provide comprehensive answers
​
Advanced Configuration
The MCP client supports additional configuration options:
Client customization through
McpSyncClientCustomizer
or
McpAsyncClientCustomizer
Multiple clients with multiple transport types:
STDIO
and
SSE
(Server-Sent Events)
Integration with Spring AI’s tool execution framework
Automatic client initialization and lifecycle management
For WebFlux-based applications, you can use the WebFlux starter instead:
Copy
<
dependency
>
<
groupId
>
org.springframework.ai
</
groupId
>
<
artifactId
>
spring-ai-mcp-client-webflux-spring-boot-starter
</
artifactId
>
</
dependency
>
This provides similar functionality but uses a WebFlux-based SSE transport implementation, recommended for production deployments.
You can find the complete code for this tutorial here.
​
System Requirements
Before starting, ensure your system meets these requirements:
Java 17 or higher
Anthropic API key (Claude)
​
Setting up your environment
First, let’s install
java
and
gradle
if you haven’t already.
You can download
java
from
official Oracle JDK website
.
Verify your
java
installation:
Copy
java
--version
Now, let’s create and set up your project:
MacOS/Linux
Windows
Copy
# Create a new directory for our project
mkdir
kotlin-mcp-client
cd
kotlin-mcp-client
# Initialize a new kotlin project
gradle
init
After running
gradle init
, you will be presented with options for creating your project.
Select
Application
as the project type,
Kotlin
as the programming language, and
Java 17
as the Java version.
Alternatively, you can create a Kotlin application using the
IntelliJ IDEA project wizard
.
After creating the project, add the following dependencies:
build.gradle.kts
build.gradle
Copy
val
mcpVersion
=
"0.4.0"
val
slf4jVersion
=
"2.0.9"
val
anthropicVersion
=
"0.8.0"
dependencies
{
implementation
(
"io.modelcontextprotocol:kotlin-sdk:
$mcpVersion
"
)
implementation
(
"org.slf4j:slf4j-nop:
$slf4jVersion
"
)
implementation
(
"com.anthropic:anthropic-java:
$anthropicVersion
"
)
}
Also, add the following plugins to your build script:
build.gradle.kts
build.gradle
Copy
plugins
{
id
(
"com.github.johnrengelman.shadow"
) version
"8.1.1"
}
​
Setting up your API key
You’ll need an Anthropic API key from the
Anthropic Console
.
Set up your API key:
Copy
export
ANTHROPIC_API_KEY
=
'your-anthropic-api-key-here'
Make sure your keep your
ANTHROPIC_API_KEY
secure!
​
Creating the Client
​
Basic Client Structure
First, let’s create the basic client class:
Copy
class
MCPClient
:
AutoCloseable
{
private
val
anthropic
=
AnthropicOkHttpClient.
fromEnv
()
private
val
mcp:
Client
=
Client
(clientInfo
=
Implementation
(name
=
"mcp-client-cli"
, version
=
"1.0.0"
))
private
lateinit
var
tools:
List
<
ToolUnion
>
// methods will go here
override
fun
close
() {
runBlocking
{
mcp.
close
()
anthropic.
close
()
}
}
​
Server connection management
Next, we’ll implement the method to connect to an MCP server:
Copy
suspend
fun
connectToServer
(serverScriptPath:
String
) {
try
{
val
command
=
buildList
{
when
(serverScriptPath.
substringAfterLast
(
"."
)) {
"js"
->
add
(
"node"
)
"py"
->
add
(
if
(System.
getProperty
(
"os.name"
).
lowercase
().
contains
(
"win"
))
"python"
else
"python3"
)
"jar"
->
addAll
(
listOf
(
"java"
,
"-jar"
))
else
->
throw
IllegalArgumentException
(
"Server script must be a .js, .py or .jar file"
)
}
add
(serverScriptPath)
}
val
process
=
ProcessBuilder
(command).
start
()
val
transport
=
StdioClientTransport
(
input
=
process.inputStream.
asSource
().
buffered
(),
output
=
process.outputStream.
asSink
().
buffered
()
)
mcp.
connect
(transport)
val
toolsResult
=
mcp.
listTools
()
tools
=
toolsResult?.tools?.
map
{ tool
->
ToolUnion.
ofTool
(
Tool.
builder
()
.
name
(tool.name)
.
description
(tool.description ?:
""
)
.
inputSchema
(
Tool.InputSchema.
builder
()
.
type
(JsonValue.
from
(tool.inputSchema.type))
.
properties
(tool.inputSchema.properties.
toJsonValue
())
.
putAdditionalProperty
(
"required"
, JsonValue.
from
(tool.inputSchema.required))
.
build
()
)
.
build
()
)
} ?:
emptyList
()
println
(
"Connected to server with tools:
${
tools.
joinToString
(
", "
) { it.
tool
().
get
().
name
()
}
}"
)
}
catch
(e:
Exception
) {
println
(
"Failed to connect to MCP server:
$e
"
)
throw
e
}
}
Also create a helper function to convert from
JsonObject
to
JsonValue
for Anthropic:
Copy
private
fun
JsonObject
.
toJsonValue
():
JsonValue
{
val
mapper
=
ObjectMapper
()
val
node
=
mapper.
readTree
(
this
.
toString
())
return
JsonValue.
fromJsonNode
(node)
}
​
Query processing logic
Now let’s add the core functionality for processing queries and handling tool calls:
Copy
private
val
messageParamsBuilder:
MessageCreateParams
.Builder
=
MessageCreateParams.
builder
()
.
model
(Model.CLAUDE_3_5_SONNET_20241022)
.
maxTokens
(
1024
)
suspend
fun
processQuery
(query:
String
):
String
{
val
messages
=
mutableListOf
(
MessageParam.
builder
()
.
role
(MessageParam.Role.USER)
.
content
(query)
.
build
()
)
val
response
=
anthropic.
messages
().
create
(
messageParamsBuilder
.
messages
(messages)
.
tools
(tools)
.
build
()
)
val
finalText
=
mutableListOf
<
String
>()
response.
content
().
forEach
{ content
->
when
{
content.
isText
()
->
finalText.
add
(content.
text
().
getOrNull
()?.
text
() ?:
""
)
content.
isToolUse
()
->
{
val
toolName
=
content.
toolUse
().
get
().
name
()
val
toolArgs
=
content.
toolUse
().
get
().
_input
().
convert
(
object
:
TypeReference
<
Map
<
String
,
JsonValue
>>() {})
val
result
=
mcp.
callTool
(
name
=
toolName,
arguments
=
toolArgs ?:
emptyMap
()
)
finalText.
add
(
"[Calling tool
$toolName
with args
$toolArgs
]"
)
messages.
add
(
MessageParam.
builder
()
.
role
(MessageParam.Role.USER)
.
content
(
"""
"type": "tool_result",
"tool_name":
$toolName
,
"result":
${
result?.content?.
joinToString
(
"
\n
"
) { (it
as
TextContent).text ?:
""
}
}
"""
.
trimIndent
()
)
.
build
()
)
val
aiResponse
=
anthropic.
messages
().
create
(
messageParamsBuilder
.
messages
(messages)
.
build
()
)
finalText.
add
(aiResponse.
content
().
first
().
text
().
getOrNull
()?.
text
() ?:
""
)
}
}
}
return
finalText.
joinToString
(
"
\n
"
, prefix
=
""
, postfix
=
""
)
}
​
Interactive chat
We’ll add the chat loop:
Copy
suspend
fun
chatLoop
() {
println
(
"
\n
MCP Client Started!"
)
println
(
"Type your queries or 'quit' to exit."
)
while
(
true
) {
print
(
"
\n
Query: "
)
val
message
=
readLine
() ?:
break
if
(message.
lowercase
()
==
"quit"
)
break
val
response
=
processQuery
(message)
println
(
"
\n
$response
"
)
}
}
​
Main entry point
Finally, we’ll add the main execution function:
Copy
fun
main
(args:
Array
<
String
>)
=
runBlocking
{
if
(args.
isEmpty
())
throw
IllegalArgumentException
(
"Usage: java -jar <your_path>/build/libs/kotlin-mcp-client-0.1.0-all.jar <path_to_server_script>"
)
val
serverPath
=
args.
first
()
val
client
=
MCPClient
()
client.
use
{
client.
connectToServer
(serverPath)
client.
chatLoop
()
}
}
​
Running the client
To run your client with any MCP server:
Copy
./gradlew
build
# Run the client
java
-jar
build/libs/
<
your-jar-nam
e
>
.jar
path/to/server.jar
# jvm server
java
-jar
build/libs/
<
your-jar-nam
e
>
.jar
path/to/server.py
# python server
java
-jar
build/libs/
<
your-jar-nam
e
>
.jar
path/to/build/index.js
# node server
If you’re continuing the weather tutorial from the server quickstart, your command might look something like this:
java -jar build/libs/kotlin-mcp-client-0.1.0-all.jar .../samples/weather-stdio-server/build/libs/weather-stdio-server-0.1.0-all.jar
The client will:
Connect to the specified server
List available tools
Start an interactive chat session where you can:
Enter queries
See tool executions
Get responses from Claude
​
How it works
Here’s a high-level workflow schema:
When you submit a query:
The client gets the list of available tools from the server
Your query is sent to Claude along with tool descriptions
Claude decides which tools (if any) to use
The client executes any requested tool calls through the server
Results are sent back to Claude
Claude provides a natural language response
The response is displayed to you
​
Best practices
Error Handling
Leverage Kotlin’s type system to model errors explicitly
Wrap external tool and API calls in
try-catch
blocks when exceptions are possible
Provide clear and meaningful error messages
Handle network timeouts and connection issues gracefully
Security
Store API keys and secrets securely in
local.properties
, environment variables, or secret managers
Validate all external responses to avoid unexpected or unsafe data usage
Be cautious with permissions and trust boundaries when using tools
​
Troubleshooting
​
Server Path Issues
Double-check the path to your server script is correct
Use the absolute path if the relative path isn’t working
For Windows users, make sure to use forward slashes (/) or escaped backslashes (\) in the path
Make sure that the required runtime is installed (java for Java, npm for Node.js, or uv for Python)
Verify the server file has the correct extension (.jar for Java, .js for Node.js or .py for Python)
Example of correct path usage:
Copy
# Relative path
java
-jar
build/libs/client.jar
./server/build/libs/server.jar
# Absolute path
java
-jar
build/libs/client.jar
/Users/username/projects/mcp-server/build/libs/server.jar
# Windows path (either format works)
java
-jar
build/libs/client.jar
C:/projects/mcp-server/build/libs/server.jar
java
-jar
build/libs/client.jar
C:
\\
projects
\\
mcp-server
\\
build
\\
libs
\\
server.jar
​
Response Timing
The first response might take up to 30 seconds to return
This is normal and happens while:
The server initializes
Claude processes the query
Tools are being executed
Subsequent responses are typically faster
Don’t interrupt the process during this initial waiting period
​
Common Error Messages
If you see:
Connection refused
: Ensure the server is running and the path is correct
Tool execution failed
: Verify the tool’s required environment variables are set
ANTHROPIC_API_KEY is not set
: Check your environment variables
You can find the complete code for this tutorial here.
​
System Requirements
Before starting, ensure your system meets these requirements:
.NET 8.0 or higher
Anthropic API key (Claude)
Windows, Linux, or MacOS
​
Setting up your environment
First, create a new .NET project:
Copy
dotnet
new
console
-n
QuickstartClient
cd
QuickstartClient
Then, add the required dependencies to your project:
Copy
dotnet
add
package
ModelContextProtocol
--prerelease
dotnet
add
package
Anthropic.SDK
dotnet
add
package
Microsoft.Extensions.Hosting
dotnet
add
package
Microsoft.Extensions.AI
​
Setting up your API key
You’ll need an Anthropic API key from the
Anthropic Console
.
Copy
dotnet
user-secrets
init
dotnet
user-secrets
set
"ANTHROPIC_API_KEY"
"<your key here>"
​
Creating the Client
​
Basic Client Structure
First, let’s setup the basic client class in the file
Program.cs
:
Copy
using
Anthropic
.
SDK
;
using
Microsoft
.
Extensions
.
AI
;
using
Microsoft
.
Extensions
.
Configuration
;
using
Microsoft
.
Extensions
.
Hosting
;
using
ModelContextProtocol
.
Client
;
using
ModelContextProtocol
.
Protocol
.
Transport
;
var
builder
=
Host
.
CreateApplicationBuilder
(
args
);
builder
.
Configuration
.
AddEnvironmentVariables
()
.
AddUserSecrets
<
Program
>();
This creates the beginnings of a .NET console application that can read the API key from user secrets.
Next, we’ll setup the MCP Client:
Copy
var
(
command
,
arguments
)
=
GetCommandAndArguments
(
args
);
var
clientTransport
=
new
StdioClientTransport
(
new
()
{
Name
=
"Demo Server"
,
Command
=
command
,
Arguments
=
arguments
,
});
await
using
var
mcpClient
=
await
McpClientFactory
.
CreateAsync
(
clientTransport
);
var
tools
=
await
mcpClient
.
ListToolsAsync
();
foreach
(
var
tool
in
tools
)
{
Console
.
WriteLine
(
$"Connected to server with tools: {
tool
.
Name
}"
);
}
Add this function at the end of the
Program.cs
file:
Copy
static
(
string
command
,
string
[]
arguments
)
GetCommandAndArguments
(
string
[]
args
)
{
return
args
switch
{
[
var
script
]
when
script
.
EndsWith
(
".py"
)
=>
(
"python"
,
args
),
[
var
script
]
when
script
.
EndsWith
(
".js"
)
=>
(
"node"
,
args
),
[
var
script
]
when
Directory
.
Exists
(
script
)
||
(
File
.
Exists
(
script
)
&&
script
.
EndsWith
(
".csproj"
))
=>
(
"dotnet"
, [
"run"
,
"--project"
,
script
,
"--no-build"
]),
_
=>
throw
new
NotSupportedException
(
"An unsupported server script was provided. Supported scripts are .py, .js, or .csproj"
)
};
}
This creates a MCP client that will connect to a server that is provided as a command line argument. It then lists the available tools from the connected server.
​
Query processing logic
Now let’s add the core functionality for processing queries and handling tool calls:
Copy
using
var
anthropicClient
=
new
AnthropicClient
(
new
APIAuthentication
(
builder
.
Configuration
[
"ANTHROPIC_API_KEY"
]))
.
Messages
.
AsBuilder
()
.
UseFunctionInvocation
()
.
Build
();
var
options
=
new
ChatOptions
{
MaxOutputTokens
=
1000
,
ModelId
=
"claude-3-5-sonnet-20241022"
,
Tools
=
[
..
tools
]
};
Console
.
ForegroundColor
=
ConsoleColor
.
Green
;
Console
.
WriteLine
(
"MCP Client Started!"
);
Console
.
ResetColor
();
PromptForInput
();
while
(
Console
.
ReadLine
()
is
string
query
&&
!
"exit"
.
Equals
(
query
,
StringComparison
.
OrdinalIgnoreCase
))
{
if
(
string
.
IsNullOrWhiteSpace
(
query
))
{
PromptForInput
();
continue
;
}
await
foreach
(
var
message
in
anthropicClient
.
GetStreamingResponseAsync
(
query
,
options
))
{
Console
.
Write
(
message
);
}
Console
.
WriteLine
();
PromptForInput
();
}
static
void
PromptForInput
()
{
Console
.
WriteLine
(
"Enter a command (or 'exit' to quit):"
);
Console
.
ForegroundColor
=
ConsoleColor
.
Cyan
;
Console
.
Write
(
"> "
);
Console
.
ResetColor
();
}
​
Key Components Explained
​
1. Client Initialization
The client is initialized using
McpClientFactory.CreateAsync()
, which sets up the transport type and command to run the server.
​
2. Server Connection
Supports Python, Node.js, and .NET servers.
The server is started using the command specified in the arguments.
Configures to use stdio for communication with the server.
Initializes the session and available tools.
​
3. Query Processing
Leverages
Microsoft.Extensions.AI
for the chat client.
Configures the
IChatClient
to use automatic tool (function) invocation.
The client reads user input and sends it to the server.
The server processes the query and returns a response.
The response is displayed to the user.
​
Running the Client
To run your client with any MCP server:
Copy
dotnet
run
--
path/to/server.csproj
# dotnet server
dotnet
run
--
path/to/server.py
# python server
dotnet
run
--
path/to/server.js
# node server
If you’re continuing the weather tutorial from the server quickstart, your command might look something like this:
dotnet run -- path/to/QuickstartWeatherServer
.
The client will:
Connect to the specified server
List available tools
Start an interactive chat session where you can:
Enter queries
See tool executions
Get responses from Claude
Exit the session when done
Here’s an example of what it should look like it connected to a weather server quickstart:
​
Next steps
Example servers
Check out our gallery of official MCP servers and implementations
Clients
View the list of clients that support MCP integrations
Building MCP with LLMs
Learn how to use LLMs like Claude to speed up your MCP development
Core architecture
Understand how MCP connects clients, servers, and LLMs
Was this page helpful?
Yes
No
For Server Developers
For Claude Desktop Users
github
On this page
Next steps
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/quickstart/server

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Quickstart
For Server Developers
User Guide
Introduction
Quickstart
For Server Developers
For Client Developers
For Claude Desktop Users
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Quickstart
Copy page
For Server Developers
Get started building your own server to use in Claude for Desktop and other clients.
In this tutorial, we’ll build a simple MCP weather server and connect it to a host, Claude for Desktop. We’ll start with a basic setup, and then progress to more complex use cases.
​
What we’ll be building
Many LLMs do not currently have the ability to fetch the forecast and severe weather alerts. Let’s use MCP to solve that!
We’ll build a server that exposes two tools:
get-alerts
and
get-forecast
. Then we’ll connect the server to an MCP host (in this case, Claude for Desktop):
Servers can connect to any client. We’ve chosen Claude for Desktop here for simplicity, but we also have guides on
building your own client
as well as a
list of other clients here
.
​
Core MCP Concepts
MCP servers can provide three main types of capabilities:
Resources
: File-like data that can be read by clients (like API responses or file contents)
Tools
: Functions that can be called by the LLM (with user approval)
Prompts
: Pre-written templates that help users accomplish specific tasks
This tutorial will primarily focus on tools.
Python
Node
Java
Kotlin
C#
Let’s get started with building our weather server!
You can find the complete code for what we’ll be building here.
​
Prerequisite knowledge
This quickstart assumes you have familiarity with:
Python
LLMs like Claude
​
System requirements
Python 3.10 or higher installed.
You must use the Python MCP SDK 1.2.0 or higher.
​
Set up your environment
First, let’s install
uv
and set up our Python project and environment:
MacOS/Linux
Windows
Copy
curl
-LsSf
https://astral.sh/uv/install.sh
|
sh
Make sure to restart your terminal afterwards to ensure that the
uv
command gets picked up.
Now, let’s create and set up our project:
MacOS/Linux
Windows
Copy
# Create a new directory for our project
uv
init
weather
cd
weather
# Create virtual environment and activate it
uv
venv
source
.venv/bin/activate
# Install dependencies
uv
add
"mcp[cli]"
httpx
# Create our server file
touch
weather.py
Now let’s dive into building your server.
​
Building your server
​
Importing packages and setting up the instance
Add these to the top of your
weather.py
:
Copy
from
typing
import
Any
import
httpx
from
mcp.server.fastmcp
import
FastMCP
# Initialize FastMCP server
mcp
=
FastMCP(
"weather"
)
# Constants
NWS_API_BASE
=
"https://api.weather.gov"
USER_AGENT
=
"weather-app/1.0"
The FastMCP class uses Python type hints and docstrings to automatically generate tool definitions, making it easy to create and maintain MCP tools.
​
Helper functions
Next, let’s add our helper functions for querying and formatting the data from the National Weather Service API:
Copy
async
def
make_nws_request
(
url
:
str
) -> dict[
str
, Any]
|
None
:
"""Make a request to the NWS API with proper error handling."""
headers
=
{
"User-Agent"
:
USER_AGENT
,
"Accept"
:
"application/geo+json"
}
async
with
httpx.AsyncClient()
as
client:
try
:
response
=
await
client.get(url,
headers
=
headers,
timeout
=
30.0
)
response.raise_for_status()
return
response.json()
except
Exception
:
return
None
def
format_alert
(
feature
:
dict
) ->
str
:
"""Format an alert feature into a readable string."""
props
=
feature[
"properties"
]
return
f
"""
Event:
{
props.get(
'event'
,
'Unknown'
)
}
Area:
{
props.get(
'areaDesc'
,
'Unknown'
)
}
Severity:
{
props.get(
'severity'
,
'Unknown'
)
}
Description:
{
props.get(
'description'
,
'No description available'
)
}
Instructions:
{
props.get(
'instruction'
,
'No specific instructions provided'
)
}
"""
​
Implementing tool execution
The tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:
Copy
@mcp.tool
()
async
def
get_alerts
(
state
:
str
) ->
str
:
"""Get weather alerts for a US state.
Args:
state: Two-letter US state code (e.g. CA, NY)
"""
url
=
f
"
{
NWS_API_BASE
}
/alerts/active/area/
{
state
}
"
data
=
await
make_nws_request(url)
if
not
data
or
"features"
not
in
data:
return
"Unable to fetch alerts or no alerts found."
if
not
data[
"features"
]:
return
"No active alerts for this state."
alerts
=
[format_alert(feature)
for
feature
in
data[
"features"
]]
return
"
\n
---
\n
"
.join(alerts)
@mcp.tool
()
async
def
get_forecast
(
latitude
:
float
,
longitude
:
float
) ->
str
:
"""Get weather forecast for a location.
Args:
latitude: Latitude of the location
longitude: Longitude of the location
"""
# First get the forecast grid endpoint
points_url
=
f
"
{
NWS_API_BASE
}
/points/
{
latitude
}
,
{
longitude
}
"
points_data
=
await
make_nws_request(points_url)
if
not
points_data:
return
"Unable to fetch forecast data for this location."
# Get the forecast URL from the points response
forecast_url
=
points_data[
"properties"
][
"forecast"
]
forecast_data
=
await
make_nws_request(forecast_url)
if
not
forecast_data:
return
"Unable to fetch detailed forecast."
# Format the periods into a readable forecast
periods
=
forecast_data[
"properties"
][
"periods"
]
forecasts
=
[]
for
period
in
periods[:
5
]:
# Only show next 5 periods
forecast
=
f
"""
{
period[
'name'
]
}
:
Temperature:
{
period[
'temperature'
]
}
°
{
period[
'temperatureUnit'
]
}
Wind:
{
period[
'windSpeed'
]
}
{
period[
'windDirection'
]
}
Forecast:
{
period[
'detailedForecast'
]
}
"""
forecasts.append(forecast)
return
"
\n
---
\n
"
.join(forecasts)
​
Running the server
Finally, let’s initialize and run the server:
Copy
if
__name__
==
"__main__"
:
# Initialize and run the server
mcp.run(
transport
=
'stdio'
)
Your server is complete! Run
uv run weather.py
to confirm that everything’s working.
Let’s now test your server from an existing MCP host, Claude for Desktop.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux. Linux users can proceed to the
Building a client
tutorial to build an MCP client that connects to the server we just built.
First, make sure you have Claude for Desktop installed.
You can install the latest version
here.
If you already have Claude for Desktop,
make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at
~/Library/Application Support/Claude/claude_desktop_config.json
in a text editor. Make sure to create the file if it doesn’t exist.
For example, if you have
VS Code
installed:
MacOS/Linux
Windows
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
$
env:
AppData
\Claude\claude_desktop_config.json
You’ll then add your servers in the
mcpServers
key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:
MacOS/Linux
Windows
Python
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"uv"
,
"args"
: [
"--directory"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather"
,
"run"
,
"weather.py"
]
}
}
}
Python
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"uv"
,
"args"
: [
"--directory"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather"
,
"run"
,
"weather.py"
]
}
}
}
Python
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"uv"
,
"args"
: [
"--directory"
,
"C:
\\
ABSOLUTE
\\
PATH
\\
TO
\\
PARENT
\\
FOLDER
\\
weather"
,
"run"
,
"weather.py"
]
}
}
}
You may need to put the full path to the
uv
executable in the
command
field. You can get this by running
which uv
on MacOS/Linux or
where uv
on Windows.
Make sure you pass in the absolute path to your server.
This tells Claude for Desktop:
There’s an MCP server named “weather”
To launch it by running
uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py
Save the file, and restart
Claude for Desktop
.
Let’s get started with building our weather server!
You can find the complete code for what we’ll be building here.
​
Prerequisite knowledge
This quickstart assumes you have familiarity with:
Python
LLMs like Claude
​
System requirements
Python 3.10 or higher installed.
You must use the Python MCP SDK 1.2.0 or higher.
​
Set up your environment
First, let’s install
uv
and set up our Python project and environment:
MacOS/Linux
Windows
Copy
curl
-LsSf
https://astral.sh/uv/install.sh
|
sh
Make sure to restart your terminal afterwards to ensure that the
uv
command gets picked up.
Now, let’s create and set up our project:
MacOS/Linux
Windows
Copy
# Create a new directory for our project
uv
init
weather
cd
weather
# Create virtual environment and activate it
uv
venv
source
.venv/bin/activate
# Install dependencies
uv
add
"mcp[cli]"
httpx
# Create our server file
touch
weather.py
Now let’s dive into building your server.
​
Building your server
​
Importing packages and setting up the instance
Add these to the top of your
weather.py
:
Copy
from
typing
import
Any
import
httpx
from
mcp.server.fastmcp
import
FastMCP
# Initialize FastMCP server
mcp
=
FastMCP(
"weather"
)
# Constants
NWS_API_BASE
=
"https://api.weather.gov"
USER_AGENT
=
"weather-app/1.0"
The FastMCP class uses Python type hints and docstrings to automatically generate tool definitions, making it easy to create and maintain MCP tools.
​
Helper functions
Next, let’s add our helper functions for querying and formatting the data from the National Weather Service API:
Copy
async
def
make_nws_request
(
url
:
str
) -> dict[
str
, Any]
|
None
:
"""Make a request to the NWS API with proper error handling."""
headers
=
{
"User-Agent"
:
USER_AGENT
,
"Accept"
:
"application/geo+json"
}
async
with
httpx.AsyncClient()
as
client:
try
:
response
=
await
client.get(url,
headers
=
headers,
timeout
=
30.0
)
response.raise_for_status()
return
response.json()
except
Exception
:
return
None
def
format_alert
(
feature
:
dict
) ->
str
:
"""Format an alert feature into a readable string."""
props
=
feature[
"properties"
]
return
f
"""
Event:
{
props.get(
'event'
,
'Unknown'
)
}
Area:
{
props.get(
'areaDesc'
,
'Unknown'
)
}
Severity:
{
props.get(
'severity'
,
'Unknown'
)
}
Description:
{
props.get(
'description'
,
'No description available'
)
}
Instructions:
{
props.get(
'instruction'
,
'No specific instructions provided'
)
}
"""
​
Implementing tool execution
The tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:
Copy
@mcp.tool
()
async
def
get_alerts
(
state
:
str
) ->
str
:
"""Get weather alerts for a US state.
Args:
state: Two-letter US state code (e.g. CA, NY)
"""
url
=
f
"
{
NWS_API_BASE
}
/alerts/active/area/
{
state
}
"
data
=
await
make_nws_request(url)
if
not
data
or
"features"
not
in
data:
return
"Unable to fetch alerts or no alerts found."
if
not
data[
"features"
]:
return
"No active alerts for this state."
alerts
=
[format_alert(feature)
for
feature
in
data[
"features"
]]
return
"
\n
---
\n
"
.join(alerts)
@mcp.tool
()
async
def
get_forecast
(
latitude
:
float
,
longitude
:
float
) ->
str
:
"""Get weather forecast for a location.
Args:
latitude: Latitude of the location
longitude: Longitude of the location
"""
# First get the forecast grid endpoint
points_url
=
f
"
{
NWS_API_BASE
}
/points/
{
latitude
}
,
{
longitude
}
"
points_data
=
await
make_nws_request(points_url)
if
not
points_data:
return
"Unable to fetch forecast data for this location."
# Get the forecast URL from the points response
forecast_url
=
points_data[
"properties"
][
"forecast"
]
forecast_data
=
await
make_nws_request(forecast_url)
if
not
forecast_data:
return
"Unable to fetch detailed forecast."
# Format the periods into a readable forecast
periods
=
forecast_data[
"properties"
][
"periods"
]
forecasts
=
[]
for
period
in
periods[:
5
]:
# Only show next 5 periods
forecast
=
f
"""
{
period[
'name'
]
}
:
Temperature:
{
period[
'temperature'
]
}
°
{
period[
'temperatureUnit'
]
}
Wind:
{
period[
'windSpeed'
]
}
{
period[
'windDirection'
]
}
Forecast:
{
period[
'detailedForecast'
]
}
"""
forecasts.append(forecast)
return
"
\n
---
\n
"
.join(forecasts)
​
Running the server
Finally, let’s initialize and run the server:
Copy
if
__name__
==
"__main__"
:
# Initialize and run the server
mcp.run(
transport
=
'stdio'
)
Your server is complete! Run
uv run weather.py
to confirm that everything’s working.
Let’s now test your server from an existing MCP host, Claude for Desktop.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux. Linux users can proceed to the
Building a client
tutorial to build an MCP client that connects to the server we just built.
First, make sure you have Claude for Desktop installed.
You can install the latest version
here.
If you already have Claude for Desktop,
make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at
~/Library/Application Support/Claude/claude_desktop_config.json
in a text editor. Make sure to create the file if it doesn’t exist.
For example, if you have
VS Code
installed:
MacOS/Linux
Windows
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
$
env:
AppData
\Claude\claude_desktop_config.json
You’ll then add your servers in the
mcpServers
key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:
MacOS/Linux
Windows
Python
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"uv"
,
"args"
: [
"--directory"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather"
,
"run"
,
"weather.py"
]
}
}
}
Python
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"uv"
,
"args"
: [
"--directory"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather"
,
"run"
,
"weather.py"
]
}
}
}
Python
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"uv"
,
"args"
: [
"--directory"
,
"C:
\\
ABSOLUTE
\\
PATH
\\
TO
\\
PARENT
\\
FOLDER
\\
weather"
,
"run"
,
"weather.py"
]
}
}
}
You may need to put the full path to the
uv
executable in the
command
field. You can get this by running
which uv
on MacOS/Linux or
where uv
on Windows.
Make sure you pass in the absolute path to your server.
This tells Claude for Desktop:
There’s an MCP server named “weather”
To launch it by running
uv --directory /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather run weather.py
Save the file, and restart
Claude for Desktop
.
Let’s get started with building our weather server!
You can find the complete code for what we’ll be building here.
​
Prerequisite knowledge
This quickstart assumes you have familiarity with:
TypeScript
LLMs like Claude
​
System requirements
For TypeScript, make sure you have the latest version of Node installed.
​
Set up your environment
First, let’s install Node.js and npm if you haven’t already. You can download them from
nodejs.org
.
Verify your Node.js installation:
Copy
node
--version
npm
--version
For this tutorial, you’ll need Node.js version 16 or higher.
Now, let’s create and set up our project:
MacOS/Linux
Windows
Copy
# Create a new directory for our project
mkdir
weather
cd
weather
# Initialize a new npm project
npm
init
-y
# Install dependencies
npm
install
@modelcontextprotocol/sdk
zod
npm
install
-D
@types/node
typescript
# Create our files
mkdir
src
touch
src/index.ts
Update your package.json to add type: “module” and a build script:
package.json
Copy
{
"type"
:
"module"
,
"bin"
: {
"weather"
:
"./build/index.js"
},
"scripts"
: {
"build"
:
"tsc && chmod 755 build/index.js"
},
"files"
: [
"build"
]
}
Create a
tsconfig.json
in the root of your project:
tsconfig.json
Copy
{
"compilerOptions"
: {
"target"
:
"ES2022"
,
"module"
:
"Node16"
,
"moduleResolution"
:
"Node16"
,
"outDir"
:
"./build"
,
"rootDir"
:
"./src"
,
"strict"
:
true
,
"esModuleInterop"
:
true
,
"skipLibCheck"
:
true
,
"forceConsistentCasingInFileNames"
:
true
},
"include"
: [
"src/**/*"
],
"exclude"
: [
"node_modules"
]
}
Now let’s dive into building your server.
​
Building your server
​
Importing packages and setting up the instance
Add these to the top of your
src/index.ts
:
Copy
import
{
McpServer
}
from
"@modelcontextprotocol/sdk/server/mcp.js"
;
import
{
StdioServerTransport
}
from
"@modelcontextprotocol/sdk/server/stdio.js"
;
import
{
z
}
from
"zod"
;
const
NWS_API_BASE
=
"https://api.weather.gov"
;
const
USER_AGENT
=
"weather-app/1.0"
;
// Create server instance
const
server
=
new
McpServer
({
name:
"weather"
,
version:
"1.0.0"
,
capabilities:
{
resources:
{},
tools:
{},
},
});
​
Helper functions
Next, let’s add our helper functions for querying and formatting the data from the National Weather Service API:
Copy
// Helper function for making NWS API requests
async
function
makeNWSRequest
<
T
>(
url
:
string
)
:
Promise
<
T
|
null
> {
const
headers
=
{
"User-Agent"
:
USER_AGENT
,
Accept:
"application/geo+json"
,
};
try
{
const
response
=
await
fetch
(
url
, {
headers
});
if
(
!
response
.
ok
) {
throw
new
Error
(
`HTTP error! status:
${
response
.
status
}
`
);
}
return
(
await
response
.
json
())
as
T
;
}
catch
(
error
) {
console
.
error
(
"Error making NWS request:"
,
error
);
return
null
;
}
}
interface
AlertFeature
{
properties
:
{
event
?:
string
;
areaDesc
?:
string
;
severity
?:
string
;
status
?:
string
;
headline
?:
string
;
};
}
// Format alert data
function
formatAlert
(
feature
:
AlertFeature
)
:
string
{
const
props
=
feature
.
properties
;
return
[
`Event:
${
props
.
event
||
"Unknown"
}
`
,
`Area:
${
props
.
areaDesc
||
"Unknown"
}
`
,
`Severity:
${
props
.
severity
||
"Unknown"
}
`
,
`Status:
${
props
.
status
||
"Unknown"
}
`
,
`Headline:
${
props
.
headline
||
"No headline"
}
`
,
"---"
,
].
join
(
"
\n
"
);
}
interface
ForecastPeriod
{
name
?:
string
;
temperature
?:
number
;
temperatureUnit
?:
string
;
windSpeed
?:
string
;
windDirection
?:
string
;
shortForecast
?:
string
;
}
interface
AlertsResponse
{
features
:
AlertFeature
[];
}
interface
PointsResponse
{
properties
:
{
forecast
?:
string
;
};
}
interface
ForecastResponse
{
properties
:
{
periods
:
ForecastPeriod
[];
};
}
​
Implementing tool execution
The tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:
Copy
// Register weather tools
server
.
tool
(
"get-alerts"
,
"Get weather alerts for a state"
,
{
state:
z
.
string
().
length
(
2
).
describe
(
"Two-letter state code (e.g. CA, NY)"
),
},
async
({
state
})
=>
{
const
stateCode
=
state
.
toUpperCase
();
const
alertsUrl
=
`
${
NWS_API_BASE
}
/alerts?area=
${
stateCode
}
`
;
const
alertsData
=
await
makeNWSRequest
<
AlertsResponse
>(
alertsUrl
);
if
(
!
alertsData
) {
return
{
content:
[
{
type:
"text"
,
text:
"Failed to retrieve alerts data"
,
},
],
};
}
const
features
=
alertsData
.
features
||
[];
if
(
features
.
length
===
0
) {
return
{
content:
[
{
type:
"text"
,
text:
`No active alerts for
${
stateCode
}
`
,
},
],
};
}
const
formattedAlerts
=
features
.
map
(
formatAlert
);
const
alertsText
=
`Active alerts for
${
stateCode
}
:
\n\n
${
formattedAlerts
.
join
(
"
\n
"
)
}
`
;
return
{
content:
[
{
type:
"text"
,
text:
alertsText
,
},
],
};
},
);
server
.
tool
(
"get-forecast"
,
"Get weather forecast for a location"
,
{
latitude:
z
.
number
().
min
(
-
90
).
max
(
90
).
describe
(
"Latitude of the location"
),
longitude:
z
.
number
()
.
min
(
-
180
)
.
max
(
180
)
.
describe
(
"Longitude of the location"
),
},
async
({
latitude
,
longitude
})
=>
{
// Get grid point data
const
pointsUrl
=
`
${
NWS_API_BASE
}
/points/
${
latitude
.
toFixed
(
4
)
}
,
${
longitude
.
toFixed
(
4
)
}
`
;
const
pointsData
=
await
makeNWSRequest
<
PointsResponse
>(
pointsUrl
);
if
(
!
pointsData
) {
return
{
content:
[
{
type:
"text"
,
text:
`Failed to retrieve grid point data for coordinates:
${
latitude
}
,
${
longitude
}
. This location may not be supported by the NWS API (only US locations are supported).`
,
},
],
};
}
const
forecastUrl
=
pointsData
.
properties
?.
forecast
;
if
(
!
forecastUrl
) {
return
{
content:
[
{
type:
"text"
,
text:
"Failed to get forecast URL from grid point data"
,
},
],
};
}
// Get forecast data
const
forecastData
=
await
makeNWSRequest
<
ForecastResponse
>(
forecastUrl
);
if
(
!
forecastData
) {
return
{
content:
[
{
type:
"text"
,
text:
"Failed to retrieve forecast data"
,
},
],
};
}
const
periods
=
forecastData
.
properties
?.
periods
||
[];
if
(
periods
.
length
===
0
) {
return
{
content:
[
{
type:
"text"
,
text:
"No forecast periods available"
,
},
],
};
}
// Format forecast periods
const
formattedForecast
=
periods
.
map
((
period
:
ForecastPeriod
)
=>
[
`
${
period
.
name
||
"Unknown"
}
:`
,
`Temperature:
${
period
.
temperature
||
"Unknown"
}
°
${
period
.
temperatureUnit
||
"F"
}
`
,
`Wind:
${
period
.
windSpeed
||
"Unknown"
}
${
period
.
windDirection
||
""
}
`
,
`
${
period
.
shortForecast
||
"No forecast available"
}
`
,
"---"
,
].
join
(
"
\n
"
),
);
const
forecastText
=
`Forecast for
${
latitude
}
,
${
longitude
}
:
\n\n
${
formattedForecast
.
join
(
"
\n
"
)
}
`
;
return
{
content:
[
{
type:
"text"
,
text:
forecastText
,
},
],
};
},
);
​
Running the server
Finally, implement the main function to run the server:
Copy
async
function
main
() {
const
transport
=
new
StdioServerTransport
();
await
server
.
connect
(
transport
);
console
.
error
(
"Weather MCP Server running on stdio"
);
}
main
().
catch
((
error
)
=>
{
console
.
error
(
"Fatal error in main():"
,
error
);
process
.
exit
(
1
);
});
Make sure to run
npm run build
to build your server! This is a very important step in getting your server to connect.
Let’s now test your server from an existing MCP host, Claude for Desktop.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux. Linux users can proceed to the
Building a client
tutorial to build an MCP client that connects to the server we just built.
First, make sure you have Claude for Desktop installed.
You can install the latest version
here.
If you already have Claude for Desktop,
make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at
~/Library/Application Support/Claude/claude_desktop_config.json
in a text editor. Make sure to create the file if it doesn’t exist.
For example, if you have
VS Code
installed:
MacOS/Linux
Windows
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
$
env:
AppData
\Claude\claude_desktop_config.json
You’ll then add your servers in the
mcpServers
key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:
MacOS/Linux
Windows
Node
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"node"
,
"args"
: [
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"
]
}
}
}
Node
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"node"
,
"args"
: [
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js"
]
}
}
}
Node
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"node"
,
"args"
: [
"C:
\\
PATH
\\
TO
\\
PARENT
\\
FOLDER
\\
weather
\\
build
\\
index.js"
]
}
}
}
This tells Claude for Desktop:
There’s an MCP server named “weather”
Launch it by running
node /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/index.js
Save the file, and restart
Claude for Desktop
.
This is a quickstart demo based on Spring AI MCP auto-configuration and boot starters.
To learn how to create sync and async MCP Servers, manually, consult the
Java SDK Server
documentation.
Let’s get started with building our weather server!
You can find the complete code for what we’ll be building here.
For more information, see the
MCP Server Boot Starter
reference documentation.
For manual MCP Server implementation, refer to the
MCP Server Java SDK documentation
.
​
System requirements
Java 17 or higher installed.
Spring Boot 3.3.x
or higher
​
Set up your environment
Use the
Spring Initializer
to bootstrap the project.
You will need to add the following dependencies:
Maven
Gradle
Copy
<
dependencies
>
<
dependency
>
<
groupId
>
org.springframework.ai
</
groupId
>
<
artifactId
>
spring-ai-starter-mcp-server
</
artifactId
>
</
dependency
>
<
dependency
>
<
groupId
>
org.springframework
</
groupId
>
<
artifactId
>
spring-web
</
artifactId
>
</
dependency
>
</
dependencies
>
Copy
<
dependencies
>
<
dependency
>
<
groupId
>
org.springframework.ai
</
groupId
>
<
artifactId
>
spring-ai-starter-mcp-server
</
artifactId
>
</
dependency
>
<
dependency
>
<
groupId
>
org.springframework
</
groupId
>
<
artifactId
>
spring-web
</
artifactId
>
</
dependency
>
</
dependencies
>
Copy
dependencies {
implementation platform(
"org.springframework.ai:spring-ai-starter-mcp-server"
)
implementation platform(
"org.springframework:spring-web"
)
}
Then configure your application by setting the application properties:
application.properties
application.yml
Copy
spring.main.bannerMode
=off
logging.pattern.console
=
The
Server Configuration Properties
documents all available properties.
Now let’s dive into building your server.
​
Building your server
​
Weather Service
Let’s implement a
WeatherService.java
that uses a REST client to query the data from the National Weather Service API:
Copy
@
Service
public
class
WeatherService
{
private
final
RestClient
restClient
;
public
WeatherService
() {
this
.
restClient
=
RestClient
.
builder
()
.
baseUrl
(
"https://api.weather.gov"
)
.
defaultHeader
(
"Accept"
,
"application/geo+json"
)
.
defaultHeader
(
"User-Agent"
,
"WeatherApiClient/1.0 (
[email protected]
)"
)
.
build
();
}
@
Tool
(
description
=
"Get weather forecast for a specific latitude/longitude"
)
public
String
getWeatherForecastByLocation
(
double
latitude
,
// Latitude coordinate
double
longitude
// Longitude coordinate
) {
// Returns detailed forecast including:
// - Temperature and unit
// - Wind speed and direction
// - Detailed forecast description
}
@
Tool
(
description
=
"Get weather alerts for a US state"
)
public
String
getAlerts
(
@
ToolParam
(
description
=
"Two-letter US state code (e.g. CA, NY)"
)
String
state
) {
// Returns active alerts including:
// - Event type
// - Affected area
// - Severity
// - Description
// - Safety instructions
}
// ......
}
The
@Service
annotation with auto-register the service in your application context.
The Spring AI
@Tool
annotation, making it easy to create and maintain MCP tools.
The auto-configuration will automatically register these tools with the MCP server.
​
Create your Boot Application
Copy
@
SpringBootApplication
public
class
McpServerApplication
{
public
static
void
main
(
String
[]
args
) {
SpringApplication
.
run
(
McpServerApplication
.
class
, args);
}
@
Bean
public
ToolCallbackProvider
weatherTools
(
WeatherService
weatherService
) {
return
MethodToolCallbackProvider
.
builder
().
toolObjects
(weatherService).
build
();
}
}
Uses the the
MethodToolCallbackProvider
utils to convert the
@Tools
into actionable callbacks used by the MCP server.
​
Running the server
Finally, let’s build the server:
Copy
./mvnw
clean
install
This will generate a
mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar
file within the
target
folder.
Let’s now test your server from an existing MCP host, Claude for Desktop.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux.
First, make sure you have Claude for Desktop installed.
You can install the latest version here.
If you already have Claude for Desktop,
make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use.
To do this, open your Claude for Desktop App configuration at
~/Library/Application Support/Claude/claude_desktop_config.json
in a text editor.
Make sure to create the file if it doesn’t exist.
For example, if you have
VS Code
installed:
MacOS/Linux
Windows
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
$
env:
AppData
\Claude\claude_desktop_config.json
You’ll then add your servers in the
mcpServers
key.
The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:
MacOS/Linux
Windows
java
Copy
{
"mcpServers"
: {
"spring-ai-mcp-weather"
: {
"command"
:
"java"
,
"args"
: [
"-Dspring.ai.mcp.server.stdio=true"
,
"-jar"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
]
}
}
}
java
Copy
{
"mcpServers"
: {
"spring-ai-mcp-weather"
: {
"command"
:
"java"
,
"args"
: [
"-Dspring.ai.mcp.server.stdio=true"
,
"-jar"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
]
}
}
}
java
Copy
{
"mcpServers"
: {
"spring-ai-mcp-weather"
: {
"command"
:
"java"
,
"args"
: [
"-Dspring.ai.mcp.server.transport=STDIO"
,
"-jar"
,
"C:
\\
ABSOLUTE
\\
PATH
\\
TO
\\
PARENT
\\
FOLDER
\\
weather
\\
mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
]
}
}
}
Make sure you pass in the absolute path to your server.
This tells Claude for Desktop:
There’s an MCP server named “my-weather-server”
To launch it by running
java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar
Save the file, and restart
Claude for Desktop
.
​
Testing your server with Java client
​
Create a MCP Client manually
Use the
McpClient
to connect to the server:
Copy
var
stdioParams
=
ServerParameters
.
builder
(
"java"
)
.
args
(
"-jar"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/mcp-weather-stdio-server-0.0.1-SNAPSHOT.jar"
)
.
build
();
var
stdioTransport
=
new
StdioClientTransport
(stdioParams);
var
mcpClient
=
McpClient
.
sync
(stdioTransport).
build
();
mcpClient
.
initialize
();
ListToolsResult
toolsList
=
mcpClient
.
listTools
();
CallToolResult
weather
=
mcpClient
.
callTool
(
new
CallToolRequest
(
"getWeatherForecastByLocation"
,
Map
.
of
(
"latitude"
,
"47.6062"
,
"longitude"
,
"-122.3321"
)));
CallToolResult
alert
=
mcpClient
.
callTool
(
new
CallToolRequest
(
"getAlerts"
,
Map
.
of
(
"state"
,
"NY"
)));
mcpClient
.
closeGracefully
();
​
Use MCP Client Boot Starter
Create a new boot starter application using the
spring-ai-starter-mcp-client
dependency:
Copy
<
dependency
>
<
groupId
>
org.springframework.ai
</
groupId
>
<
artifactId
>
spring-ai-starter-mcp-client
</
artifactId
>
</
dependency
>
and set the
spring.ai.mcp.client.stdio.servers-configuration
property to point to your
claude_desktop_config.json
.
You can reuse the existing Anthropic Desktop configuration:
Copy
spring.ai.mcp.client.stdio.servers-configuration
=file:PATH/TO/claude_desktop_config.json
When you start your client application, the auto-configuration will create, automatically MCP clients from the claude_desktop_config.json.
For more information, see the
MCP Client Boot Starters
reference documentation.
​
More Java MCP Server examples
The
starter-webflux-server
demonstrates how to create a MCP server using SSE transport.
It showcases how to define and register MCP Tools, Resources, and Prompts, using the Spring Boot’s auto-configuration capabilities.
Let’s get started with building our weather server!
You can find the complete code for what we’ll be building here.
​
Prerequisite knowledge
This quickstart assumes you have familiarity with:
Kotlin
LLMs like Claude
​
System requirements
Java 17 or higher installed.
​
Set up your environment
First, let’s install
java
and
gradle
if you haven’t already.
You can download
java
from
official Oracle JDK website
.
Verify your
java
installation:
Copy
java
--version
Now, let’s create and set up your project:
MacOS/Linux
Windows
Copy
# Create a new directory for our project
mkdir
weather
cd
weather
# Initialize a new kotlin project
gradle
init
After running
gradle init
, you will be presented with options for creating your project.
Select
Application
as the project type,
Kotlin
as the programming language, and
Java 17
as the Java version.
Alternatively, you can create a Kotlin application using the
IntelliJ IDEA project wizard
.
After creating the project, add the following dependencies:
build.gradle.kts
build.gradle
Copy
val
mcpVersion
=
"0.4.0"
val
slf4jVersion
=
"2.0.9"
val
ktorVersion
=
"3.1.1"
dependencies
{
implementation
(
"io.modelcontextprotocol:kotlin-sdk:
$mcpVersion
"
)
implementation
(
"org.slf4j:slf4j-nop:
$slf4jVersion
"
)
implementation
(
"io.ktor:ktor-client-content-negotiation:
$ktorVersion
"
)
implementation
(
"io.ktor:ktor-serialization-kotlinx-json:
$ktorVersion
"
)
}
Also, add the following plugins to your build script:
build.gradle.kts
build.gradle
Copy
plugins
{
kotlin
(
"plugin.serialization"
) version
"your_version_of_kotlin"
id
(
"com.github.johnrengelman.shadow"
) version
"8.1.1"
}
Now let’s dive into building your server.
​
Building your server
​
Setting up the instance
Add a server initialization function:
Copy
// Main function to run the MCP server
fun
`run mcp server`
() {
// Create the MCP Server instance with a basic implementation
val
server
=
Server
(
Implementation
(
name
=
"weather"
,
// Tool name is "weather"
version
=
"1.0.0"
// Version of the implementation
),
ServerOptions
(
capabilities
=
ServerCapabilities
(tools
=
ServerCapabilities.
Tools
(listChanged
=
true
))
)
)
// Create a transport using standard IO for server communication
val
transport
=
StdioServerTransport
(
System.`
in
`.
asInput
(),
System.out.
asSink
().
buffered
()
)
runBlocking
{
server.
connect
(transport)
val
done
=
Job
()
server.
onClose
{
done.
complete
()
}
done.
join
()
}
}
​
Weather API helper functions
Next, let’s add functions and data classes for querying and converting responses from the National Weather Service API:
Copy
// Extension function to fetch forecast information for given latitude and longitude
suspend
fun
HttpClient
.
getForecast
(latitude:
Double
, longitude:
Double
):
List
<
String
> {
val
points
=
this
.
get
(
"/points/
$latitude
,
$longitude
"
).
body
<
Points
>()
val
forecast
=
this
.
get
(points.properties.forecast).
body
<
Forecast
>()
return
forecast.properties.periods.
map
{ period
->
"""
${
period.name
}
:
Temperature:
${
period.temperature
}
${
period.temperatureUnit
}
Wind:
${
period.windSpeed
}
${
period.windDirection
}
Forecast:
${
period.detailedForecast
}
"""
.
trimIndent
()
}
}
// Extension function to fetch weather alerts for a given state
suspend
fun
HttpClient
.
getAlerts
(state:
String
):
List
<
String
> {
val
alerts
=
this
.
get
(
"/alerts/active/area/
$state
"
).
body
<
Alert
>()
return
alerts.features.
map
{ feature
->
"""
Event:
${
feature.properties.event
}
Area:
${
feature.properties.areaDesc
}
Severity:
${
feature.properties.severity
}
Description:
${
feature.properties.description
}
Instruction:
${
feature.properties.instruction
}
"""
.
trimIndent
()
}
}
@Serializable
data
class
Points
(
val
properties:
Properties
) {
@Serializable
data
class
Properties
(
val
forecast:
String
)
}
@Serializable
data
class
Forecast
(
val
properties:
Properties
) {
@Serializable
data
class
Properties
(
val
periods:
List
<
Period
>)
@Serializable
data
class
Period
(
val
number:
Int
,
val
name:
String
,
val
startTime:
String
,
val
endTime:
String
,
val
isDaytime:
Boolean
,
val
temperature:
Int
,
val
temperatureUnit:
String
,
val
temperatureTrend:
String
,
val
probabilityOfPrecipitation:
JsonObject
,
val
windSpeed:
String
,
val
windDirection:
String
,
val
shortForecast:
String
,
val
detailedForecast:
String
,
)
}
@Serializable
data
class
Alert
(
val
features:
List
<
Feature
>
) {
@Serializable
data
class
Feature
(
val
properties:
Properties
)
@Serializable
data
class
Properties
(
val
event:
String
,
val
areaDesc:
String
,
val
severity:
String
,
val
description:
String
,
val
instruction:
String
?,
)
}
​
Implementing tool execution
The tool execution handler is responsible for actually executing the logic of each tool. Let’s add it:
Copy
// Create an HTTP client with a default request configuration and JSON content negotiation
val
httpClient
=
HttpClient
{
defaultRequest
{
url
(
"https://api.weather.gov"
)
headers
{
append
(
"Accept"
,
"application/geo+json"
)
append
(
"User-Agent"
,
"WeatherApiClient/1.0"
)
}
contentType
(ContentType.Application.Json)
}
// Install content negotiation plugin for JSON serialization/deserialization
install
(ContentNegotiation) {
json
(
Json
{ ignoreUnknownKeys
=
true
}) }
}
// Register a tool to fetch weather alerts by state
server.
addTool
(
name
=
"get_alerts"
,
description
=
"""
Get weather alerts for a US state. Input is Two-letter US state code (e.g. CA, NY)
"""
.
trimIndent
(),
inputSchema
=
Tool.
Input
(
properties
=
buildJsonObject
{
putJsonObject
(
"state"
) {
put
(
"type"
,
"string"
)
put
(
"description"
,
"Two-letter US state code (e.g. CA, NY)"
)
}
},
required
=
listOf
(
"state"
)
)
) { request
->
val
state
=
request.arguments[
"state"
]?.jsonPrimitive?.content
if
(state
==
null
) {
return
@addTool
CallToolResult
(
content
=
listOf
(
TextContent
(
"The 'state' parameter is required."
))
)
}
val
alerts
=
httpClient.
getAlerts
(state)
CallToolResult
(content
=
alerts.
map
{
TextContent
(it) })
}
// Register a tool to fetch weather forecast by latitude and longitude
server.
addTool
(
name
=
"get_forecast"
,
description
=
"""
Get weather forecast for a specific latitude/longitude
"""
.
trimIndent
(),
inputSchema
=
Tool.
Input
(
properties
=
buildJsonObject
{
putJsonObject
(
"latitude"
) {
put
(
"type"
,
"number"
) }
putJsonObject
(
"longitude"
) {
put
(
"type"
,
"number"
) }
},
required
=
listOf
(
"latitude"
,
"longitude"
)
)
) { request
->
val
latitude
=
request.arguments[
"latitude"
]?.jsonPrimitive?.doubleOrNull
val
longitude
=
request.arguments[
"longitude"
]?.jsonPrimitive?.doubleOrNull
if
(latitude
==
null
||
longitude
==
null
) {
return
@addTool
CallToolResult
(
content
=
listOf
(
TextContent
(
"The 'latitude' and 'longitude' parameters are required."
))
)
}
val
forecast
=
httpClient.
getForecast
(latitude, longitude)
CallToolResult
(content
=
forecast.
map
{
TextContent
(it) })
}
​
Running the server
Finally, implement the main function to run the server:
Copy
fun
main
()
=
`run mcp server`
()
Make sure to run
./gradlew build
to build your server. This is a very important step in getting your server to connect.
Let’s now test your server from an existing MCP host, Claude for Desktop.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux. Linux users can proceed to the
Building a client
tutorial to build an MCP client that connects to the server we just built.
First, make sure you have Claude for Desktop installed.
You can install the latest version
here.
If you already have Claude for Desktop,
make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use.
To do this, open your Claude for Desktop App configuration at
~/Library/Application Support/Claude/claude_desktop_config.json
in a text editor.
Make sure to create the file if it doesn’t exist.
For example, if you have
VS Code
installed:
MacOS/Linux
Windows
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
You’ll then add your servers in the
mcpServers
key.
The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:
MacOS/Linux
Windows
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"java"
,
"args"
: [
"-jar"
,
"/ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar"
]
}
}
}
This tells Claude for Desktop:
There’s an MCP server named “weather”
Launch it by running
java -jar /ABSOLUTE/PATH/TO/PARENT/FOLDER/weather/build/libs/weather-0.1.0-all.jar
Save the file, and restart
Claude for Desktop
.
Let’s get started with building our weather server!
You can find the complete code for what we’ll be building here.
​
Prerequisite knowledge
This quickstart assumes you have familiarity with:
C#
LLMs like Claude
.NET 8 or higher
​
System requirements
.NET 8 SDK
or higher installed.
​
Set up your environment
First, let’s install
dotnet
if you haven’t already. You can download
dotnet
from
official Microsoft .NET website
. Verify your
dotnet
installation:
Copy
dotnet
--version
Now, let’s create and set up your project:
MacOS/Linux
Windows
Copy
# Create a new directory for our project
mkdir
weather
cd
weather
# Initialize a new C# project
dotnet
new
console
After running
dotnet new console
, you will be presented with a new C# project.
You can open the project in your favorite IDE, such as
Visual Studio
or
Rider
.
Alternatively, you can create a C# application using the
Visual Studio project wizard
.
After creating the project, add NuGet package for the Model Context Protocol SDK and hosting:
Copy
# Add the Model Context Protocol SDK NuGet package
dotnet
add
package
ModelContextProtocol
--prerelease
# Add the .NET Hosting NuGet package
dotnet
add
package
Microsoft.Extensions.Hosting
Now let’s dive into building your server.
​
Building your server
Open the
Program.cs
file in your project and replace its contents with the following code:
Copy
using
Microsoft
.
Extensions
.
DependencyInjection
;
using
Microsoft
.
Extensions
.
Hosting
;
using
ModelContextProtocol
;
using
System
.
Net
.
Http
.
Headers
;
var
builder
=
Host
.
CreateEmptyApplicationBuilder
(
settings
:
null
);
builder
.
Services
.
AddMcpServer
()
.
WithStdioServerTransport
()
.
WithToolsFromAssembly
();
builder
.
Services
.
AddSingleton
(
_
=>
{
var
client
=
new
HttpClient
() {
BaseAddress
=
new
Uri
(
"https://api.weather.gov"
) };
client
.
DefaultRequestHeaders
.
UserAgent
.
Add
(
new
ProductInfoHeaderValue
(
"weather-tool"
,
"1.0"
));
return
client
;
});
var
app
=
builder
.
Build
();
await
app
.
RunAsync
();
When creating the
ApplicationHostBuilder
, ensure you use
CreateEmptyApplicationBuilder
instead of
CreateDefaultBuilder
. This ensures that the server does not write any additional messages to the console. This is only necessary for servers using STDIO transport.
This code sets up a basic console application that uses the Model Context Protocol SDK to create an MCP server with standard I/O transport.
​
Weather API helper functions
Create an extension class for
HttpClient
which helps simplify JSON request handling:
Copy
using
System
.
Text
.
Json
;
internal
static
class
HttpClientExt
{
public
static
async
Task
<
JsonDocument
>
ReadJsonDocumentAsync
(
this
HttpClient
client
,
string
requestUri
)
{
using
var
response
=
await
client
.
GetAsync
(
requestUri
);
response
.
EnsureSuccessStatusCode
();
return
await
JsonDocument
.
ParseAsync
(
await
response
.
Content
.
ReadAsStreamAsync
());
}
}
Next, define a class with the tool execution handlers for querying and converting responses from the National Weather Service API:
Copy
using
ModelContextProtocol
.
Server
;
using
System
.
ComponentModel
;
using
System
.
Globalization
;
using
System
.
Text
.
Json
;
namespace
QuickstartWeatherServer
.
Tools
;
[
McpServerToolType
]
public
static
class
WeatherTools
{
[
McpServerTool
,
Description
(
"Get weather alerts for a US state."
)]
public
static
async
Task
<
string
>
GetAlerts
(
HttpClient
client
,
[
Description
(
"The US state to get alerts for."
)]
string
state
)
{
using
var
jsonDocument
=
await
client
.
ReadJsonDocumentAsync
(
$"/alerts/active/area/{
state
}"
);
var
jsonElement
=
jsonDocument
.
RootElement
;
var
alerts
=
jsonElement
.
GetProperty
(
"features"
).
EnumerateArray
();
if
(
!
alerts
.
Any
())
{
return
"No active alerts for this state."
;
}
return
string
.
Join
(
"
\n
--
\n
"
,
alerts
.
Select
(
alert
=>
{
JsonElement
properties
=
alert
.
GetProperty
(
"properties"
);
return
$"""
Event: {
properties
.
GetProperty
("event").
GetString
()}
Area: {
properties
.
GetProperty
("areaDesc").
GetString
()}
Severity: {
properties
.
GetProperty
("severity").
GetString
()}
Description: {
properties
.
GetProperty
("description").
GetString
()}
Instruction: {
properties
.
GetProperty
("instruction").
GetString
()}
"""
;
}));
}
[
McpServerTool
,
Description
(
"Get weather forecast for a location."
)]
public
static
async
Task
<
string
>
GetForecast
(
HttpClient
client
,
[
Description
(
"Latitude of the location."
)]
double
latitude
,
[
Description
(
"Longitude of the location."
)]
double
longitude
)
{
var
pointUrl
=
string
.
Create
(
CultureInfo
.
InvariantCulture
,
$"/points/{
latitude
},{
longitude
}"
);
using
var
jsonDocument
=
await
client
.
ReadJsonDocumentAsync
(
pointUrl
);
var
forecastUrl
=
jsonDocument
.
RootElement
.
GetProperty
(
"properties"
).
GetProperty
(
"forecast"
).
GetString
()
??
throw
new
Exception
(
$"No forecast URL provided by {
client
.
BaseAddress
}points/{
latitude
},{
longitude
}"
);
using
var
forecastDocument
=
await
client
.
ReadJsonDocumentAsync
(
forecastUrl
);
var
periods
=
forecastDocument
.
RootElement
.
GetProperty
(
"properties"
).
GetProperty
(
"periods"
).
EnumerateArray
();
return
string
.
Join
(
"
\n
---
\n
"
,
periods
.
Select
(
period
=>
$"""
{
period
.
GetProperty
("name").
GetString
()}
Temperature: {
period
.
GetProperty
("temperature").
GetInt32
()}°F
Wind: {
period
.
GetProperty
("windSpeed").
GetString
()} {
period
.
GetProperty
("windDirection").
GetString
()}
Forecast: {
period
.
GetProperty
("detailedForecast").
GetString
()}
"""
));
}
}
​
Running the server
Finally, run the server using the following command:
Copy
dotnet
run
This will start the server and listen for incoming requests on standard input/output.
​
Testing your server with Claude for Desktop
Claude for Desktop is not yet available on Linux. Linux users can proceed to the
Building a client
tutorial to build an MCP client that connects to the server we just built.
First, make sure you have Claude for Desktop installed.
You can install the latest version
here.
If you already have Claude for Desktop,
make sure it’s updated to the latest version.
We’ll need to configure Claude for Desktop for whichever MCP servers you want to use. To do this, open your Claude for Desktop App configuration at
~/Library/Application Support/Claude/claude_desktop_config.json
in a text editor. Make sure to create the file if it doesn’t exist.
For example, if you have
VS Code
installed:
MacOS/Linux
Windows
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
~/Library/Application
\
Support/Claude/claude_desktop_config.json
Copy
code
$
env:
AppData
\Claude\claude_desktop_config.json
You’ll then add your servers in the
mcpServers
key. The MCP UI elements will only show up in Claude for Desktop if at least one server is properly configured.
In this case, we’ll add our single weather server like so:
MacOS/Linux
Windows
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"dotnet"
,
"args"
: [
"run"
,
"--project"
,
"/ABSOLUTE/PATH/TO/PROJECT"
,
"--no-build"
]
}
}
}
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"dotnet"
,
"args"
: [
"run"
,
"--project"
,
"/ABSOLUTE/PATH/TO/PROJECT"
,
"--no-build"
]
}
}
}
Copy
{
"mcpServers"
: {
"weather"
: {
"command"
:
"dotnet"
,
"args"
: [
"run"
,
"--project"
,
"C:
\\
ABSOLUTE
\\
PATH
\\
TO
\\
PROJECT"
,
"--no-build"
]
}
}
}
This tells Claude for Desktop:
There’s an MCP server named “weather”
Launch it by running
dotnet run /ABSOLUTE/PATH/TO/PROJECT
Save the file, and restart
Claude for Desktop
.
​
Test with commands
Let’s make sure Claude for Desktop is picking up the two tools we’ve exposed in our
weather
server. You can do this by looking for the “Search and tools”
icon:
After clicking on the slider icon, you should see two tools listed:
If your server isn’t being picked up by Claude for Desktop, proceed to the
Troubleshooting
section for debugging tips.
If the tool settings icon has shown up, you can now test your server by running the following commands in Claude for Desktop:
What’s the weather in Sacramento?
What are the active weather alerts in Texas?
Since this is the US National Weather service, the queries will only work for US locations.
​
What’s happening under the hood
When you ask a question:
The client sends your question to Claude
Claude analyzes the available tools and decides which one(s) to use
The client executes the chosen tool(s) through the MCP server
The results are sent back to Claude
Claude formulates a natural language response
The response is displayed to you!
​
Troubleshooting
Claude for Desktop Integration Issues
Getting logs from Claude for Desktop
Claude.app logging related to MCP is written to log files in
~/Library/Logs/Claude
:
mcp.log
will contain general logging about MCP connections and connection failures.
Files named
mcp-server-SERVERNAME.log
will contain error (stderr) logging from the named server.
You can run the following command to list recent logs and follow along with any new ones:
Copy
# Check Claude's logs for errors
tail
-n
20
-f
~/Library/Logs/Claude/mcp
*
.log
Server not showing up in Claude
Check your
claude_desktop_config.json
file syntax
Make sure the path to your project is absolute and not relative
Restart Claude for Desktop completely
Tool calls failing silently
If Claude attempts to use the tools but they fail:
Check Claude’s logs for errors
Verify your server builds and runs without errors
Try restarting Claude for Desktop
None of this is working. What do I do?
Please refer to our
debugging guide
for better debugging tools and more detailed guidance.
Weather API Issues
Error: Failed to retrieve grid point data
This usually means either:
The coordinates are outside the US
The NWS API is having issues
You’re being rate limited
Fix:
Verify you’re using US coordinates
Add a small delay between requests
Check the NWS API status page
Error: No active alerts for [STATE]
This isn’t an error - it just means there are no current weather alerts for that state. Try a different state or check during severe weather.
For more advanced troubleshooting, check out our guide on
Debugging MCP
​
Next steps
Building a client
Learn how to build your own MCP client that can connect to your server
Example servers
Check out our gallery of official MCP servers and implementations
Debugging Guide
Learn how to effectively debug MCP servers and integrations
Building MCP with LLMs
Learn how to use LLMs like Claude to speed up your MCP development
Was this page helpful?
Yes
No
Introduction
For Client Developers
github
On this page
What we’ll be building
Core MCP Concepts
Test with commands
What’s happening under the hood
Troubleshooting
Next steps
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/quickstart/user

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Quickstart
For Claude Desktop Users
User Guide
Introduction
Quickstart
For Server Developers
For Client Developers
For Claude Desktop Users
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Quickstart
Copy page
For Claude Desktop Users
Get started using pre-built servers in Claude for Desktop.
In this tutorial, you will extend
Claude for Desktop
so that it can read from your computer’s file system, write new files, move files, and even search files.
Don’t worry — it will ask you for your permission before executing these actions!
​
1. Download Claude for Desktop
Start by downloading
Claude for Desktop
, choosing either macOS or Windows. (Linux is not yet supported for Claude for Desktop.)
Follow the installation instructions.
If you already have Claude for Desktop, make sure it’s on the latest version by clicking on the Claude menu on your computer and selecting “Check for Updates…“
​
2. Add the Filesystem MCP Server
To add this filesystem functionality, we will be installing a pre-built
Filesystem MCP Server
to Claude for Desktop. This is one of several current
reference servers
and many community-created servers.
Get started by opening up the Claude menu on your computer and select “Settings…” Please note that these are not the Claude Account Settings found in the app window itself.
This is what it should look like on a Mac:
Click on “Developer” in the left-hand bar of the Settings pane, and then click on “Edit Config”:
This will create a configuration file at:
macOS:
~/Library/Application Support/Claude/claude_desktop_config.json
Windows:
%APPDATA%\Claude\claude_desktop_config.json
if you don’t already have one, and will display the file in your file system.
Open up the configuration file in any text editor. Replace the file contents with this:
MacOS/Linux
Windows
Copy
{
"mcpServers"
: {
"filesystem"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-filesystem"
,
"/Users/username/Desktop"
,
"/Users/username/Downloads"
]
}
}
}
Copy
{
"mcpServers"
: {
"filesystem"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-filesystem"
,
"/Users/username/Desktop"
,
"/Users/username/Downloads"
]
}
}
}
Copy
{
"mcpServers"
: {
"filesystem"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-filesystem"
,
"C:
\\
Users
\\
username
\\
Desktop"
,
"C:
\\
Users
\\
username
\\
Downloads"
]
}
}
}
Make sure to replace
username
with your computer’s username. The paths should point to valid directories that you want Claude to be able to access and modify. It’s set up to work for Desktop and Downloads, but you can add more paths as well.
You will also need
Node.js
on your computer for this to run properly. To verify you have Node installed, open the command line on your computer.
On macOS, open the Terminal from your Applications folder
On Windows, press Windows + R, type “cmd”, and press Enter
Once in the command line, verify you have Node installed by entering in the following command:
Copy
node
--version
If you get an error saying “command not found” or “node is not recognized”, download Node from
nodejs.org
.
How does the configuration file work?
This configuration file tells Claude for Desktop which MCP servers to start up every time you start the application. In this case, we have added one server called “filesystem” that will use the Node
npx
command to install and run
@modelcontextprotocol/server-filesystem
. This server, described
here
, will let you access your file system in Claude for Desktop.
Command Privileges
Claude for Desktop will run the commands in the configuration file with the permissions of your user account, and access to your local files. Only add commands if you understand and trust the source.
​
3. Restart Claude
After updating your configuration file, you need to restart Claude for Desktop.
Upon restarting, you should see a slider
icon in the bottom left corner of the input box:
After clicking on the slider icon, you should see the tools that come with the Filesystem MCP Server:
If your server isn’t being picked up by Claude for Desktop, proceed to the
Troubleshooting
section for debugging tips.
​
4. Try it out!
You can now talk to Claude and ask it about your filesystem. It should know when to call the relevant tools.
Things you might try asking Claude:
Can you write a poem and save it to my desktop?
What are some work-related files in my downloads folder?
Can you take all the images on my desktop and move them to a new folder called “Images”?
As needed, Claude will call the relevant tools and seek your approval before taking an action:
​
Troubleshooting
Server not showing up in Claude / hammer icon missing
Restart Claude for Desktop completely
Check your
claude_desktop_config.json
file syntax
Make sure the file paths included in
claude_desktop_config.json
are valid and that they are absolute and not relative
Look at
logs
to see why the server is not connecting
In your command line, try manually running the server (replacing
username
as you did in
claude_desktop_config.json
) to see if you get any errors:
MacOS/Linux
Windows
Copy
npx
-y
@modelcontextprotocol/server-filesystem
/Users/username/Desktop
/Users/username/Downloads
Copy
npx
-y
@modelcontextprotocol/server-filesystem
/Users/username/Desktop
/Users/username/Downloads
Copy
npx
-y
@modelcontextprotocol/server-filesystem
C:
\U
sers
\u
sername
\D
esktop
C:
\U
sers
\u
sername
\D
ownloads
Getting logs from Claude for Desktop
Claude.app logging related to MCP is written to log files in:
macOS:
~/Library/Logs/Claude
Windows:
%APPDATA%\Claude\logs
mcp.log
will contain general logging about MCP connections and connection failures.
Files named
mcp-server-SERVERNAME.log
will contain error (stderr) logging from the named server.
You can run the following command to list recent logs and follow along with any new ones (on Windows, it will only show recent logs):
MacOS/Linux
Windows
Copy
# Check Claude's logs for errors
tail
-n
20
-f
~/Library/Logs/Claude/mcp
*
.log
Copy
# Check Claude's logs for errors
tail
-n
20
-f
~/Library/Logs/Claude/mcp
*
.log
Copy
type
"%APPDATA%\Claude\logs\mcp*.log"
Tool calls failing silently
If Claude attempts to use the tools but they fail:
Check Claude’s logs for errors
Verify your server builds and runs without errors
Try restarting Claude for Desktop
None of this is working. What do I do?
Please refer to our
debugging guide
for better debugging tools and more detailed guidance.
ENOENT error and `${APPDATA}` in paths on Windows
If your configured server fails to load, and you see within its logs an error referring to
${APPDATA}
within a path, you may need to add the expanded value of
%APPDATA%
to your
env
key in
claude_desktop_config.json
:
Copy
{
"brave-search"
: {
"command"
:
"npx"
,
"args"
: [
"-y"
,
"@modelcontextprotocol/server-brave-search"
],
"env"
: {
"APPDATA"
:
"C:
\\
Users
\\
user
\\
AppData
\\
Roaming
\\
"
,
"BRAVE_API_KEY"
:
"..."
}
}
}
With this change in place, launch Claude Desktop once again.
NPM should be installed globally
The
npx
command may continue to fail if you have not installed NPM globally. If NPM is already installed globally, you will find
%APPDATA%\npm
exists on your system. If not, you can install NPM globally by running the following command:
Copy
npm
install
-g
npm
​
Next steps
Explore other servers
Check out our gallery of official MCP servers and implementations
Build your own server
Now build your own custom server to use in Claude for Desktop and other
clients
Was this page helpful?
Yes
No
For Client Developers
Core architecture
github
On this page
1. Download Claude for Desktop
2. Add the Filesystem MCP Server
3. Restart Claude
4. Try it out!
Troubleshooting
Next steps
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/architecture/index

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Architecture
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Architecture
The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.
​
Core Components
​
Host
The host process acts as the container and coordinator:
Creates and manages multiple client instances
Controls client connection permissions and lifecycle
Enforces security policies and consent requirements
Handles user authorization decisions
Coordinates AI/LLM integration and sampling
Manages context aggregation across clients
​
Clients
Each client is created by the host and maintains an isolated server connection:
Establishes one stateful session per server
Handles protocol negotiation and capability exchange
Routes protocol messages bidirectionally
Manages subscriptions and notifications
Maintains security boundaries between servers
A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.
​
Servers
Servers provide specialized context and capabilities:
Expose resources, tools and prompts via MCP primitives
Operate independently with focused responsibilities
Request sampling through client interfaces
Must respect security constraints
Can be local processes or remote services
​
Design Principles
MCP is built on several key design principles that inform its architecture and
implementation:
Servers should be extremely easy to build
Host applications handle complex orchestration responsibilities
Servers focus on specific, well-defined capabilities
Simple interfaces minimize implementation overhead
Clear separation enables maintainable code
Servers should be highly composable
Each server provides focused functionality in isolation
Multiple servers can be combined seamlessly
Shared protocol enables interoperability
Modular design supports extensibility
Servers should not be able to read the whole conversation, nor “see into” other
servers
Servers receive only necessary contextual information
Full conversation history stays with the host
Each server connection maintains isolation
Cross-server interactions are controlled by the host
Host process enforces security boundaries
Features can be added to servers and clients progressively
Core protocol provides minimal required functionality
Additional capabilities can be negotiated as needed
Servers and clients evolve independently
Protocol designed for future extensibility
Backwards compatibility is maintained
​
Message Types
MCP defines three core message types based on
JSON-RPC 2.0
:
Requests
: Bidirectional messages with method and parameters expecting a response
Responses
: Successful results or errors matching specific request IDs
Notifications
: One-way messages requiring no response
Each message type follows the JSON-RPC 2.0 specification for structure and delivery
semantics.
​
Capability Negotiation
The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.
Servers declare capabilities like resource subscriptions, tool support, and prompt
templates
Clients declare capabilities like sampling support and notification handling
Both parties must respect declared capabilities throughout the session
Additional capabilities can be negotiated through extensions to the protocol
Each capability unlocks specific protocol features for use during the session. For
example:
Implemented
server features
must be
advertised in the server’s capabilities
Emitting resource subscription notifications requires the server to declare
subscription support
Tool invocation requires the server to declare tool capabilities
Sampling
requires the client to
declare support in its capabilities
This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.
Was this page helpful?
Yes
No
Specification
Overview
github
On this page
Core Components
Host
Clients
Servers
Design Principles
Message Types
Capability Negotiation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/index

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Overview
Protocol Revision
: 2024-11-05
All messages between MCP clients and servers
MUST
follow the
JSON-RPC 2.0
specification. The protocol defines
three fundamental types of messages:
Type
Description
Requirements
Requests
Messages sent to initiate an operation
Must include unique ID and method name
Responses
Messages sent in reply to requests
Must include same ID as request
Notifications
One-way messages with no reply
Must not include an ID
Responses
are further sub-categorized as either
successful results
or
errors
.
Results can follow any JSON object structure, while errors must include an error code and
message at minimum.
​
Protocol Layers
The Model Context Protocol consists of several key components that work together:
Base Protocol
: Core JSON-RPC message types
Lifecycle Management
: Connection initialization, capability negotiation, and
session control
Server Features
: Resources, prompts, and tools exposed by servers
Client Features
: Sampling and root directory lists provided by clients
Utilities
: Cross-cutting concerns like logging and argument completion
All implementations
MUST
support the base protocol and lifecycle management
components. Other components
MAY
be implemented based on the specific needs of the
application.
These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.
See the following pages for more details on the different components:
Lifecycle
Resources
Prompts
Tools
Logging
Sampling
​
Auth
Authentication and authorization are not currently part of the core MCP specification,
but we are considering ways to introduce them in future. Join us in
GitHub Discussions
to help shape the future of the protocol!
Clients and servers
MAY
negotiate their own custom authentication and authorization
strategies.
​
Schema
The full specification of the protocol is defined as a
TypeScript schema
.
This is the source of truth for all protocol messages and structures.
There is also a
JSON Schema
,
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.
Was this page helpful?
Yes
No
Architecture
Lifecycle
github
On this page
Protocol Layers
Auth
Schema
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/lifecycle

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Lifecycle
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Lifecycle
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.
Initialization
: Capability negotiation and protocol version agreement
Operation
: Normal protocol communication
Shutdown
: Graceful termination of the connection
​
Lifecycle Phases
​
Initialization
The initialization phase
MUST
be the first interaction between client and server.
During this phase, the client and server:
Establish protocol version compatibility
Exchange and negotiate capabilities
Share implementation details
The client
MUST
initiate this phase by sending an
initialize
request containing:
Protocol version supported
Client capabilities
Client implementation information
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"initialize"
,
"params"
: {
"protocolVersion"
:
"2024-11-05"
,
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
},
"sampling"
: {}
},
"clientInfo"
: {
"name"
:
"ExampleClient"
,
"version"
:
"1.0.0"
}
}
}
The server
MUST
respond with its own capabilities and information:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"protocolVersion"
:
"2024-11-05"
,
"capabilities"
: {
"logging"
: {},
"prompts"
: {
"listChanged"
:
true
},
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
},
"tools"
: {
"listChanged"
:
true
}
},
"serverInfo"
: {
"name"
:
"ExampleServer"
,
"version"
:
"1.0.0"
}
}
}
After successful initialization, the client
MUST
send an
initialized
notification
to indicate it is ready to begin normal operations:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/initialized"
}
The client
SHOULD NOT
send requests other than
pings
before the server
has responded to the
initialize
request.
The server
SHOULD NOT
send requests other than
pings
and
logging
before
receiving the
initialized
notification.
​
Version Negotiation
In the
initialize
request, the client
MUST
send a protocol version it supports.
This
SHOULD
be the
latest
version supported by the client.
If the server supports the requested protocol version, it
MUST
respond with the same
version. Otherwise, the server
MUST
respond with another protocol version it
supports. This
SHOULD
be the
latest
version supported by the server.
If the client does not support the version in the server’s response, it
SHOULD
disconnect.
​
Capability Negotiation
Client and server capabilities establish which optional protocol features will be
available during the session.
Key capabilities include:
Category
Capability
Description
Client
roots
Ability to provide filesystem
roots
Client
sampling
Support for LLM
sampling
requests
Client
experimental
Describes support for non-standard experimental features
Server
prompts
Offers
prompt templates
Server
resources
Provides readable
resources
Server
tools
Exposes callable
tools
Server
logging
Emits structured
log messages
Server
experimental
Describes support for non-standard experimental features
Capability objects can describe sub-capabilities like:
listChanged
: Support for list change notifications (for prompts, resources, and
tools)
subscribe
: Support for subscribing to individual items’ changes (resources only)
​
Operation
During the operation phase, the client and server exchange messages according to the
negotiated capabilities.
Both parties
SHOULD
:
Respect the negotiated protocol version
Only use capabilities that were successfully negotiated
​
Shutdown
During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are defined—instead, the underlying transport
mechanism should be used to signal connection termination:
​
stdio
For the stdio
transport
, the
client
SHOULD
initiate shutdown by:
First, closing the input stream to the child process (the server)
Waiting for the server to exit, or sending
SIGTERM
if the server does not exit
within a reasonable time
Sending
SIGKILL
if the server does not exit within a reasonable time after
SIGTERM
The server
MAY
initiate shutdown by closing its output stream to the client and
exiting.
​
HTTP
For HTTP
transports
, shutdown
is indicated by closing the associated HTTP connection(s).
​
Error Handling
Implementations
SHOULD
be prepared to handle these error cases:
Protocol version mismatch
Failure to negotiate required capabilities
Initialize request timeout
Shutdown timeout
Implementations
SHOULD
implement appropriate timeouts for all requests, to prevent
hung connections and resource exhaustion.
Example initialization error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unsupported protocol version"
,
"data"
: {
"supported"
: [
"2024-11-05"
],
"requested"
:
"1.0.0"
}
}
}
Was this page helpful?
Yes
No
Overview
Messages
github
On this page
Lifecycle Phases
Initialization
Version Negotiation
Capability Negotiation
Operation
Shutdown
stdio
HTTP
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/messages

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Messages
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Messages
Protocol Revision
: 2024-11-05
All messages in MCP
MUST
follow the
JSON-RPC 2.0
specification. The protocol defines
three types of messages:
​
Requests
Requests are sent from the client to the server or vice versa.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Requests
MUST
include a string or integer ID.
Unlike base JSON-RPC, the ID
MUST NOT
be
null
.
The request ID
MUST NOT
have been previously used by the requestor within the same
session.
​
Responses
Responses are sent in reply to requests.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
result
?:
{
[key: string]:
unknown
;
}
error
?:
{
code:
number
;
message
:
string
;
data
?:
unknown
;
}
}
Responses
MUST
include the same ID as the request they correspond to.
Either a
result
or an
error
MUST
be set. A response
MUST NOT
set both.
Error codes
MUST
be integers.
​
Notifications
Notifications are sent from the client to the server or vice versa. They do not expect a
response.
Copy
{
jsonrpc
:
"2.0"
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Notifications
MUST NOT
include an ID.
Was this page helpful?
Yes
No
Lifecycle
Transports
github
On this page
Requests
Responses
Notifications
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/transports

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Transports
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Transports
Protocol Revision
: 2024-11-05
MCP currently defines two standard transport mechanisms for client-server communication:
stdio
, communication over standard in and standard out
HTTP with Server-Sent Events
(SSE)
Clients
SHOULD
support stdio whenever possible.
It is also possible for clients and servers to implement
custom transports
in a pluggable fashion.
​
stdio
In the
stdio
transport:
The client launches the MCP server as a subprocess.
The server receives JSON-RPC messages on its standard input (
stdin
) and writes
responses to its standard output (
stdout
).
Messages are delimited by newlines, and
MUST NOT
contain embedded newlines.
The server
MAY
write UTF-8 strings to its standard error (
stderr
) for logging
purposes. Clients
MAY
capture, forward, or ignore this logging.
The server
MUST NOT
write anything to its
stdout
that is not a valid MCP message.
The client
MUST NOT
write anything to the server’s
stdin
that is not a valid MCP
message.
​
HTTP with SSE
In the
SSE
transport, the server operates as an independent process that can handle
multiple client connections.
​
Security Warning
When implementing HTTP with SSE transport:
Servers
MUST
validate the
Origin
header on all incoming connections to prevent DNS rebinding attacks
When running locally, servers
SHOULD
bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
Servers
SHOULD
implement proper authentication for all connections
Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.
The server
MUST
provide two endpoints:
An SSE endpoint, for clients to establish a connection and receive messages from the
server
A regular HTTP POST endpoint for clients to send messages to the server
When a client connects, the server
MUST
send an
endpoint
event containing a URI for
the client to use for sending messages. All subsequent client messages
MUST
be sent
as HTTP POST requests to this endpoint.
Server messages are sent as SSE
message
events, with the message content encoded as
JSON in the event data.
​
Custom Transports
Clients and servers
MAY
implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.
Implementers who choose to support custom transports
MUST
ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
SHOULD
document their specific connection establishment and message exchange patterns
to aid interoperability.
Was this page helpful?
Yes
No
Messages
Cancellation
github
On this page
stdio
HTTP with SSE
Security Warning
Custom Transports
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/utilities/cancellation

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Cancellation
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Cancellation
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.
​
Cancellation Flow
When a party wants to cancel an in-progress request, it sends a
notifications/cancelled
notification containing:
The ID of the request to cancel
An optional reason string that can be logged or displayed
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/cancelled"
,
"params"
: {
"requestId"
:
"123"
,
"reason"
:
"User requested cancellation"
}
}
​
Behavior Requirements
Cancellation notifications
MUST
only reference requests that:
Were previously issued in the same direction
Are believed to still be in-progress
The
initialize
request
MUST NOT
be cancelled by clients
Receivers of cancellation notifications
SHOULD
:
Stop processing the cancelled request
Free associated resources
Not send a response for the cancelled request
Receivers
MAY
ignore cancellation notifications if:
The referenced request is unknown
Processing has already completed
The request cannot be cancelled
The sender of the cancellation notification
SHOULD
ignore any response to the
request that arrives afterward
​
Timing Considerations
Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.
Both parties
MUST
handle these race conditions gracefully:
​
Implementation Notes
Both parties
SHOULD
log cancellation reasons for debugging
Application UIs
SHOULD
indicate when cancellation is requested
​
Error Handling
Invalid cancellation notifications
SHOULD
be ignored:
Unknown request IDs
Already completed requests
Malformed notifications
This maintains the “fire and forget” nature of notifications while allowing for race
conditions in asynchronous communication.
Was this page helpful?
Yes
No
Transports
Ping
github
On this page
Cancellation Flow
Behavior Requirements
Timing Considerations
Implementation Notes
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/utilities/ping

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Ping
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Ping
Protocol Revision
: 2024-11-05
The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.
​
Overview
The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a
ping
request.
​
Message Format
A ping request is a standard JSON-RPC request with no parameters:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"method"
:
"ping"
}
​
Behavior Requirements
The receiver
MUST
respond promptly with an empty response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {}
}
If no response is received within a reasonable timeout period, the sender
MAY
:
Consider the connection stale
Terminate the connection
Attempt reconnection procedures
​
Usage Patterns
​
Implementation Considerations
Implementations
SHOULD
periodically issue pings to detect connection health
The frequency of pings
SHOULD
be configurable
Timeouts
SHOULD
be appropriate for the network environment
Excessive pinging
SHOULD
be avoided to reduce network overhead
​
Error Handling
Timeouts
SHOULD
be treated as connection failures
Multiple failed pings
MAY
trigger connection reset
Implementations
SHOULD
log ping failures for diagnostics
Was this page helpful?
Yes
No
Cancellation
Progress
github
On this page
Overview
Message Format
Behavior Requirements
Usage Patterns
Implementation Considerations
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/basic/utilities/progress

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Progress
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Overview
Lifecycle
Messages
Transports
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Progress
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.
​
Progress Flow
When a party wants to
receive
progress updates for a request, it includes a
progressToken
in the request metadata.
Progress tokens
MUST
be a string or integer value
Progress tokens can be chosen by the sender using any means, but
MUST
be unique
across all active requests.
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"some_method"
,
"params"
: {
"_meta"
: {
"progressToken"
:
"abc123"
}
}
}
The receiver
MAY
then send progress notifications containing:
The original progress token
The current progress value so far
An optional “total” value
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/progress"
,
"params"
: {
"progressToken"
:
"abc123"
,
"progress"
:
50
,
"total"
:
100
}
}
The
progress
value
MUST
increase with each notification, even if the total is
unknown.
The
progress
and the
total
values
MAY
be floating point.
​
Behavior Requirements
Progress notifications
MUST
only reference tokens that:
Were provided in an active request
Are associated with an in-progress operation
Receivers of progress requests
MAY
:
Choose not to send any progress notifications
Send notifications at whatever frequency they deem appropriate
Omit the total value if unknown
​
Implementation Notes
Senders and receivers
SHOULD
track active progress tokens
Both parties
SHOULD
implement rate limiting to prevent flooding
Progress notifications
MUST
stop after completion
Was this page helpful?
Yes
No
Ping
Roots
github
On this page
Progress Flow
Behavior Requirements
Implementation Notes
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/client/roots

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Roots
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Roots
Sampling
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Roots
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem “roots” to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.
​
User Interaction Model
Roots in MCP are typically exposed through workspace or project configuration interfaces.
For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.
However, implementations are free to expose roots through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Clients that support roots
MUST
declare the
roots
capability during
initialization
:
Copy
{
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the client will emit notifications when the list of roots
changes.
​
Protocol Messages
​
Listing Roots
To retrieve roots, servers send a
roots/list
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"roots/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"roots"
: [
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
]
}
}
​
Root List Changes
When roots change, clients that support
listChanged
MUST
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/roots/list_changed"
}
​
Message Flow
​
Data Types
​
Root
A root definition includes:
uri
: Unique identifier for the root. This
MUST
be a
file://
URI in the current
specification.
name
: Optional human-readable name for display purposes.
Example roots for different use cases:
​
Project Directory
Copy
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
​
Multiple Repositories
Copy
[
{
"uri"
:
"file:///home/user/repos/frontend"
,
"name"
:
"Frontend Repository"
},
{
"uri"
:
"file:///home/user/repos/backend"
,
"name"
:
"Backend Repository"
}
]
​
Error Handling
Clients
SHOULD
return standard JSON-RPC errors for common failure cases:
Client does not support roots:
-32601
(Method not found)
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32601
,
"message"
:
"Roots not supported"
,
"data"
: {
"reason"
:
"Client does not have roots capability"
}
}
}
​
Security Considerations
Clients
MUST
:
Only expose roots with appropriate permissions
Validate all root URIs to prevent path traversal
Implement proper access controls
Monitor root accessibility
Servers
SHOULD
:
Handle cases where roots become unavailable
Respect root boundaries during operations
Validate all paths against provided roots
​
Implementation Guidelines
Clients
SHOULD
:
Prompt users for consent before exposing roots to servers
Provide clear user interfaces for root management
Validate root accessibility before exposing
Monitor for root changes
Servers
SHOULD
:
Check for roots capability before usage
Handle root list changes gracefully
Respect root boundaries in operations
Cache root information appropriately
Was this page helpful?
Yes
No
Progress
Sampling
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Roots
Root List Changes
Message Flow
Data Types
Root
Project Directory
Multiple Repositories
Error Handling
Security Considerations
Implementation Guidelines
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/client/sampling

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Sampling
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Roots
Sampling
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Sampling
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling (“completions” or “generations”) from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities—with no server API keys necessary.
Servers can request text or image-based interactions and optionally include context from
MCP servers in their prompts.
​
User Interaction Model
Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur
nested
inside other MCP server features.
Implementations are free to expose sampling through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny sampling requests.
Applications
SHOULD
:
Provide UI that makes it easy and intuitive to review sampling requests
Allow users to view and edit prompts before sending
Present generated responses for review before delivery
​
Capabilities
Clients that support sampling
MUST
declare the
sampling
capability during
initialization
:
Copy
{
"capabilities"
: {
"sampling"
: {}
}
}
​
Protocol Messages
​
Creating Messages
To request a language model generation, servers send a
sampling/createMessage
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"sampling/createMessage"
,
"params"
: {
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"What is the capital of France?"
}
}
],
"modelPreferences"
: {
"hints"
: [
{
"name"
:
"claude-3-sonnet"
}
],
"intelligencePriority"
:
0.8
,
"speedPriority"
:
0.5
},
"systemPrompt"
:
"You are a helpful assistant."
,
"maxTokens"
:
100
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"role"
:
"assistant"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"The capital of France is Paris."
},
"model"
:
"claude-3-sonnet-20240307"
,
"stopReason"
:
"endTurn"
}
}
​
Message Flow
​
Data Types
​
Messages
Sampling messages can contain:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"The message content"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/jpeg"
}
​
Model Preferences
Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider’s equivalent model.
To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:
​
Capability Priorities
Servers express their needs through three normalized priority values (0-1):
costPriority
: How important is minimizing costs? Higher values prefer cheaper models.
speedPriority
: How important is low latency? Higher values prefer faster models.
intelligencePriority
: How important are advanced capabilities? Higher values prefer
more capable models.
​
Model Hints
While priorities help select models based on characteristics,
hints
allow servers to
suggest specific models or model families:
Hints are treated as substrings that can match model names flexibly
Multiple hints are evaluated in order of preference
Clients
MAY
map hints to equivalent models from different providers
Hints are advisory—clients make final model selection
For example:
Copy
{
"hints"
: [
{
"name"
:
"claude-3-sonnet"
},
// Prefer Sonnet-class models
{
"name"
:
"claude"
}
// Fall back to any Claude model
],
"costPriority"
:
0.3
,
// Cost is less important
"speedPriority"
:
0.8
,
// Speed is very important
"intelligencePriority"
:
0.5
// Moderate capability needs
}
The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn’t have access to Claude models but has Gemini,
it might map the sonnet hint to
gemini-1.5-pro
based on similar capabilities.
​
Error Handling
Clients
SHOULD
return errors for common failure cases:
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-1
,
"message"
:
"User rejected sampling request"
}
}
​
Security Considerations
Clients
SHOULD
implement user approval controls
Both parties
SHOULD
validate message content
Clients
SHOULD
respect model preference hints
Clients
SHOULD
implement rate limiting
Both parties
MUST
handle sensitive data appropriately
Was this page helpful?
Yes
No
Roots
Overview
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Creating Messages
Message Flow
Data Types
Messages
Text Content
Image Content
Model Preferences
Capability Priorities
Model Hints
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/index

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Specification
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Specification
Model Context Protocol
(MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.
This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
schema.ts
.
For implementation guides and examples, visit
modelcontextprotocol.io
.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD
NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in
BCP 14
[
RFC2119
]
[
RFC8174
] when, and only when, they
appear in all capitals, as shown here.
​
Overview
MCP provides a standardized way for applications to:
Share contextual information with language models
Expose tools and capabilities to AI systems
Build composable integrations and workflows
The protocol uses
JSON-RPC
2.0 messages to establish
communication between:
Hosts
: LLM applications that initiate connections
Clients
: Connectors within the host application
Servers
: Services that provide context and capabilities
MCP takes some inspiration from the
Language Server Protocol
, which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.
​
Key Details
​
Base Protocol
JSON-RPC
message format
Stateful connections
Server and client capability negotiation
​
Features
Servers offer any of the following features to clients:
Resources
: Context and data, for the user or the AI model to use
Prompts
: Templated messages and workflows for users
Tools
: Functions for the AI model to execute
Clients may offer the following feature to servers:
Sampling
: Server-initiated agentic behaviors and recursive LLM interactions
​
Additional Utilities
Configuration
Progress tracking
Cancellation
Error reporting
Logging
​
Security and Trust & Safety
The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.
​
Key Principles
User Consent and Control
Users must explicitly consent to and understand all data access and operations
Users must retain control over what data is shared and what actions are taken
Implementors should provide clear UIs for reviewing and authorizing activities
Data Privacy
Hosts must obtain explicit user consent before exposing user data to servers
Hosts must not transmit resource data elsewhere without user consent
User data should be protected with appropriate access controls
Tool Safety
Tools represent arbitrary code execution and must be treated with appropriate
caution
Hosts must obtain explicit user consent before invoking any tool
Users should understand what each tool does before authorizing its use
LLM Sampling Controls
Users must explicitly approve any LLM sampling requests
Users should control:
Whether sampling occurs at all
The actual prompt that will be sent
What results the server can see
The protocol intentionally limits server visibility into prompts
​
Implementation Guidelines
While MCP itself cannot enforce these security principles at the protocol level,
implementors
SHOULD
:
Build robust consent and authorization flows into their applications
Provide clear documentation of security implications
Implement appropriate access controls and data protections
Follow security best practices in their integrations
Consider privacy implications in their feature designs
​
Learn More
Explore the detailed specification for each protocol component:
Architecture
Base Protocol
Server Features
Client Features
Contributing
Was this page helpful?
Yes
No
FAQs
Architecture
github
On this page
Overview
Key Details
Base Protocol
Features
Additional Utilities
Security and Trust & Safety
Key Principles
Implementation Guidelines
Learn More
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/index

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Overview
Protocol Revision
: 2024-11-05
Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:
Prompts
: Pre-defined templates or instructions that guide language model
interactions
Resources
: Structured data or content that provides additional context to the model
Tools
: Executable functions that allow models to perform actions or retrieve
information
Each primitive can be summarized in the following control hierarchy:
Primitive
Control
Description
Example
Prompts
User-controlled
Interactive templates invoked by user choice
Slash commands, menu options
Resources
Application-controlled
Contextual data attached and managed by the client
File contents, git history
Tools
Model-controlled
Functions exposed to the LLM to take actions
API POST requests, file writing
Explore these key primitives in more detail below:
Prompts
Resources
Tools
Was this page helpful?
Yes
No
Sampling
Prompts
github
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/prompts

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Prompts
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Prompts
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.
​
User Interaction Model
Prompts are designed to be
user-controlled
, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.
Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.
For example, as slash commands:
However, implementors are free to expose prompts through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
​
Capabilities
Servers that support prompts
MUST
declare the
prompts
capability during
initialization
:
Copy
{
"capabilities"
: {
"prompts"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available prompts changes.
​
Protocol Messages
​
Listing Prompts
To retrieve available prompts, clients send a
prompts/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"prompts/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"prompts"
: [
{
"name"
:
"code_review"
,
"description"
:
"Asks the LLM to analyze code quality and suggest improvements"
,
"arguments"
: [
{
"name"
:
"code"
,
"description"
:
"The code to review"
,
"required"
:
true
}
]
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Getting a Prompt
To retrieve a specific prompt, clients send a
prompts/get
request. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"prompts/get"
,
"params"
: {
"name"
:
"code_review"
,
"arguments"
: {
"code"
:
"def hello():
\n
print('world')"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"description"
:
"Code review prompt"
,
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"Please review this Python code:
\n
def hello():
\n
print('world')"
}
}
]
}
}
​
List Changed Notification
When the list of available prompts changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/prompts/list_changed"
}
​
Message Flow
​
Data Types
​
Prompt
A prompt definition includes:
name
: Unique identifier for the prompt
description
: Optional human-readable description
arguments
: Optional list of arguments for customization
​
PromptMessage
Messages in a prompt can contain:
role
: Either “user” or “assistant” to indicate the speaker
content
: One of the following content types:
​
Text Content
Text content represents plain text messages:
Copy
{
"type"
:
"text"
,
"text"
:
"The text content of the message"
}
This is the most common content type used for natural language interactions.
​
Image Content
Image content allows including visual information in messages:
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/png"
}
The image data
MUST
be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.
​
Embedded Resources
Embedded resources allow referencing server-side resources directly in messages:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"resource://example"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
}
Resources can contain either text or binary (blob) data and
MUST
include:
A valid resource URI
The appropriate MIME type
Either text content or base64-encoded blob data
Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
validate prompt arguments before processing
Clients
SHOULD
handle pagination for large prompt lists
Both parties
SHOULD
respect capability negotiation
​
Security
Implementations
MUST
carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.
Was this page helpful?
Yes
No
Overview
Resources
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Prompts
Getting a Prompt
List Changed Notification
Message Flow
Data Types
Prompt
PromptMessage
Text Content
Image Content
Embedded Resources
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/resources

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Resources
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Resources
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
URI
.
​
User Interaction Model
Resources in MCP are designed to be
application-driven
, with host applications
determining how to incorporate context based on their needs.
For example, applications could:
Expose resources through UI elements for explicit selection, in a tree or list view
Allow the user to search through and filter available resources
Implement automatic context inclusion, based on heuristics or the AI model’s selection
However, implementations are free to expose resources through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support resources
MUST
declare the
resources
capability:
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
}
}
}
The capability supports two optional features:
subscribe
: whether the client can subscribe to be notified of changes to individual
resources.
listChanged
: whether the server will emit notifications when the list of available
resources changes.
Both
subscribe
and
listChanged
are optional—servers can support neither,
either, or both:
Copy
{
"capabilities"
: {
"resources"
: {}
// Neither feature supported
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
// Only subscriptions supported
}
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"listChanged"
:
true
// Only list change notifications supported
}
}
}
​
Protocol Messages
​
Listing Resources
To discover available resources, clients send a
resources/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"resources"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"description"
:
"Primary application entry point"
,
"mimeType"
:
"text/x-rust"
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Reading Resources
To retrieve resource contents, clients send a
resources/read
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"resources/read"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"contents"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"mimeType"
:
"text/x-rust"
,
"text"
:
"fn main() {
\n
println!(
\"
Hello world!
\"
);
\n
}"
}
]
}
}
​
Resource Templates
Resource templates allow servers to expose parameterized resources using
URI templates
. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"method"
:
"resources/templates/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"result"
: {
"resourceTemplates"
: [
{
"uriTemplate"
:
"file:///{path}"
,
"name"
:
"Project Files"
,
"description"
:
"Access files in the project directory"
,
"mimeType"
:
"application/octet-stream"
}
]
}
}
​
List Changed Notification
When the list of available resources changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/list_changed"
}
​
Subscriptions
The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:
Subscribe Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"method"
:
"resources/subscribe"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Update Notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/updated"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
​
Message Flow
​
Data Types
​
Resource
A resource definition includes:
uri
: Unique identifier for the resource
name
: Human-readable name
description
: Optional description
mimeType
: Optional MIME type
​
Resource Contents
Resources can contain either text or binary data:
​
Text Content
Copy
{
"uri"
:
"file:///example.txt"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
​
Binary Content
Copy
{
"uri"
:
"file:///example.png"
,
"mimeType"
:
"image/png"
,
"blob"
:
"base64-encoded-data"
}
​
Common URI Schemes
The protocol defines several standard URI schemes. This list not
exhaustive—implementations are always free to use additional, custom URI schemes.
​
https://
Used to represent a resource available on the web.
Servers
SHOULD
use this scheme only when the client is able to fetch and load the
resource directly from the web on its own—that is, it doesn’t need to read the resource
via the MCP server.
For other use cases, servers
SHOULD
prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.
​
file://
Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.
MCP servers
MAY
identify file:// resources with an
XDG MIME type
,
like
inode/directory
, to represent non-regular files (such as directories) that don’t
otherwise have a standard MIME type.
​
git://
Git version control integration.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Resource not found:
-32002
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
5
,
"error"
: {
"code"
:
-32002
,
"message"
:
"Resource not found"
,
"data"
: {
"uri"
:
"file:///nonexistent.txt"
}
}
}
​
Security Considerations
Servers
MUST
validate all resource URIs
Access controls
SHOULD
be implemented for sensitive resources
Binary data
MUST
be properly encoded
Resource permissions
SHOULD
be checked before operations
Was this page helpful?
Yes
No
Prompts
Tools
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Resources
Reading Resources
Resource Templates
List Changed Notification
Subscriptions
Message Flow
Data Types
Resource
Resource Contents
Text Content
Binary Content
Common URI Schemes
https://
file://
git://
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/tools

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Tools
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Tools
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.
​
User Interaction Model
Tools in MCP are designed to be
model-controlled
, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user’s prompts.
However, implementations are free to expose tools through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny tool invocations.
Applications
SHOULD
:
Provide UI that makes clear which tools are being exposed to the AI model
Insert clear visual indicators when tools are invoked
Present confirmation prompts to the user for operations, to ensure a human is in the
loop
​
Capabilities
Servers that support tools
MUST
declare the
tools
capability:
Copy
{
"capabilities"
: {
"tools"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available tools changes.
​
Protocol Messages
​
Listing Tools
To discover available tools, clients send a
tools/list
request. This operation supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"tools/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"tools"
: [
{
"name"
:
"get_weather"
,
"description"
:
"Get current weather information for a location"
,
"inputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"location"
: {
"type"
:
"string"
,
"description"
:
"City name or zip code"
}
},
"required"
: [
"location"
]
}
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Calling Tools
To invoke a tool, clients send a
tools/call
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"tools/call"
,
"params"
: {
"name"
:
"get_weather"
,
"arguments"
: {
"location"
:
"New York"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Current weather in New York:
\n
Temperature: 72°F
\n
Conditions: Partly cloudy"
}
],
"isError"
:
false
}
}
​
List Changed Notification
When the list of available tools changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/tools/list_changed"
}
​
Message Flow
​
Data Types
​
Tool
A tool definition includes:
name
: Unique identifier for the tool
description
: Human-readable description of functionality
inputSchema
: JSON Schema defining expected parameters
​
Tool Result
Tool results can contain multiple content items of different types:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"Tool result text"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-data"
,
"mimeType"
:
"image/png"
}
​
Embedded Resources
Resources
MAY
be
embedded, to provide additional context or data, behind a URI that can be subscribed to
or fetched again by the client later:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"resource://example"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
}
​
Error Handling
Tools use two error reporting mechanisms:
Protocol Errors
: Standard JSON-RPC errors for issues like:
Unknown tools
Invalid arguments
Server errors
Tool Execution Errors
: Reported in tool results with
isError: true
:
API failures
Invalid input data
Business logic errors
Example protocol error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unknown tool: invalid_tool_name"
}
}
Example tool execution error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Failed to fetch weather data: API rate limit exceeded"
}
],
"isError"
:
true
}
}
​
Security Considerations
Servers
MUST
:
Validate all tool inputs
Implement proper access controls
Rate limit tool invocations
Sanitize tool outputs
Clients
SHOULD
:
Prompt for user confirmation on sensitive operations
Show tool inputs to the user before calling the server, to avoid malicious or
accidental data exfiltration
Validate tool results before passing to LLM
Implement timeouts for tool calls
Log tool usage for audit purposes
Was this page helpful?
Yes
No
Resources
Completion
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Tools
Calling Tools
List Changed Notification
Message Flow
Data Types
Tool
Tool Result
Text Content
Image Content
Embedded Resources
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/utilities/completion

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Completion
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Completion
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.
​
User Interaction Model
Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.
For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.
However, implementations are free to expose completion through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Protocol Messages
​
Requesting Completions
To get completion suggestions, clients send a
completion/complete
request specifying
what is being completed through a reference type:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"completion/complete"
,
"params"
: {
"ref"
: {
"type"
:
"ref/prompt"
,
"name"
:
"code_review"
},
"argument"
: {
"name"
:
"language"
,
"value"
:
"py"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"completion"
: {
"values"
: [
"python"
,
"pytorch"
,
"pyside"
],
"total"
:
10
,
"hasMore"
:
true
}
}
}
​
Reference Types
The protocol supports two types of completion references:
Type
Description
Example
ref/prompt
References a prompt by name
{"type": "ref/prompt", "name": "code_review"}
ref/resource
References a resource URI
{"type": "ref/resource", "uri": "file:///{path}"}
​
Completion Results
Servers return an array of completion values ranked by relevance, with:
Maximum 100 items per response
Optional total number of available matches
Boolean indicating if additional results exist
​
Message Flow
​
Data Types
​
CompleteRequest
ref
: A
PromptReference
or
ResourceReference
argument
: Object containing:
name
: Argument name
value
: Current value
​
CompleteResult
completion
: Object containing:
values
: Array of suggestions (max 100)
total
: Optional total matches
hasMore
: Additional results flag
​
Implementation Considerations
Servers
SHOULD
:
Return suggestions sorted by relevance
Implement fuzzy matching where appropriate
Rate limit completion requests
Validate all inputs
Clients
SHOULD
:
Debounce rapid completion requests
Cache completion results where appropriate
Handle missing or partial results gracefully
​
Security
Implementations
MUST
:
Validate all completion inputs
Implement appropriate rate limiting
Control access to sensitive suggestions
Prevent completion-based information disclosure
Was this page helpful?
Yes
No
Tools
Logging
github
On this page
User Interaction Model
Protocol Messages
Requesting Completions
Reference Types
Completion Results
Message Flow
Data Types
CompleteRequest
CompleteResult
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/utilities/logging

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Logging
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Logging
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.
​
User Interaction Model
Implementations are free to expose logging through any interface pattern that suits their
needs—the protocol itself does not mandate any specific user interaction model.
​
Capabilities
Servers that emit log message notifications
MUST
declare the
logging
capability:
Copy
{
"capabilities"
: {
"logging"
: {}
}
}
​
Log Levels
The protocol follows the standard syslog severity levels specified in
RFC 5424
:
Level
Description
Example Use Case
debug
Detailed debugging information
Function entry/exit points
info
General informational messages
Operation progress updates
notice
Normal but significant events
Configuration changes
warning
Warning conditions
Deprecated feature usage
error
Error conditions
Operation failures
critical
Critical conditions
System component failures
alert
Action must be taken immediately
Data corruption detected
emergency
System is unusable
Complete system failure
​
Protocol Messages
​
Setting Log Level
To configure the minimum log level, clients
MAY
send a
logging/setLevel
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"logging/setLevel"
,
"params"
: {
"level"
:
"info"
}
}
​
Log Message Notifications
Servers send log messages using
notifications/message
notifications:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/message"
,
"params"
: {
"level"
:
"error"
,
"logger"
:
"database"
,
"data"
: {
"error"
:
"Connection failed"
,
"details"
: {
"host"
:
"localhost"
,
"port"
:
5432
}
}
}
}
​
Message Flow
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid log level:
-32602
(Invalid params)
Configuration errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Rate limit log messages
Include relevant context in data field
Use consistent logger names
Remove sensitive information
Clients
MAY
:
Present log messages in the UI
Implement log filtering/search
Display severity visually
Persist log messages
​
Security
Log messages
MUST NOT
contain:
Credentials or secrets
Personal identifying information
Internal system details that could aid attacks
Implementations
SHOULD
:
Rate limit messages
Validate all data fields
Control log access
Monitor for sensitive content
Was this page helpful?
Yes
No
Completion
Pagination
github
On this page
User Interaction Model
Capabilities
Log Levels
Protocol Messages
Setting Log Level
Log Message Notifications
Message Flow
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2024-11-05/server/utilities/pagination

Model Context Protocol
home page
Version 2024-11-05
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Pagination
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Pagination
Protocol Revision
: 2024-11-05
The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.
Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.
​
Pagination Model
Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.
The
cursor
is an opaque string token, representing a position in the result set
Page size
is determined by the server, and clients
MUST NOT
assume a fixed page
size
​
Response Format
Pagination starts when the server sends a
response
that includes:
The current page of results
An optional
nextCursor
field if more results exist
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {
"resources"
: [
...
],
"nextCursor"
:
"eyJwYWdlIjogM30="
}
}
​
Request Format
After receiving a cursor, the client can
continue
paginating by issuing a request
including that cursor:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"eyJwYWdlIjogMn0="
}
}
​
Pagination Flow
​
Operations Supporting Pagination
The following MCP operations support pagination:
resources/list
- List available resources
resources/templates/list
- List resource templates
prompts/list
- List available prompts
tools/list
- List available tools
​
Implementation Guidelines
Servers
SHOULD
:
Provide stable cursors
Handle invalid cursors gracefully
Clients
SHOULD
:
Treat a missing
nextCursor
as the end of results
Support both paginated and non-paginated flows
Clients
MUST
treat cursors as opaque tokens:
Don’t make assumptions about cursor format
Don’t attempt to parse or modify cursors
Don’t persist cursors across sessions
​
Error Handling
Invalid cursors
SHOULD
result in an error with code -32602 (Invalid params).
Was this page helpful?
Yes
No
Logging
Versioning
github
On this page
Pagination Model
Response Format
Request Format
Pagination Flow
Operations Supporting Pagination
Implementation Guidelines
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/architecture/index

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Architecture
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Architecture
The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.
​
Core Components
​
Host
The host process acts as the container and coordinator:
Creates and manages multiple client instances
Controls client connection permissions and lifecycle
Enforces security policies and consent requirements
Handles user authorization decisions
Coordinates AI/LLM integration and sampling
Manages context aggregation across clients
​
Clients
Each client is created by the host and maintains an isolated server connection:
Establishes one stateful session per server
Handles protocol negotiation and capability exchange
Routes protocol messages bidirectionally
Manages subscriptions and notifications
Maintains security boundaries between servers
A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.
​
Servers
Servers provide specialized context and capabilities:
Expose resources, tools and prompts via MCP primitives
Operate independently with focused responsibilities
Request sampling through client interfaces
Must respect security constraints
Can be local processes or remote services
​
Design Principles
MCP is built on several key design principles that inform its architecture and
implementation:
Servers should be extremely easy to build
Host applications handle complex orchestration responsibilities
Servers focus on specific, well-defined capabilities
Simple interfaces minimize implementation overhead
Clear separation enables maintainable code
Servers should be highly composable
Each server provides focused functionality in isolation
Multiple servers can be combined seamlessly
Shared protocol enables interoperability
Modular design supports extensibility
Servers should not be able to read the whole conversation, nor “see into” other
servers
Servers receive only necessary contextual information
Full conversation history stays with the host
Each server connection maintains isolation
Cross-server interactions are controlled by the host
Host process enforces security boundaries
Features can be added to servers and clients progressively
Core protocol provides minimal required functionality
Additional capabilities can be negotiated as needed
Servers and clients evolve independently
Protocol designed for future extensibility
Backwards compatibility is maintained
​
Capability Negotiation
The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.
Servers declare capabilities like resource subscriptions, tool support, and prompt
templates
Clients declare capabilities like sampling support and notification handling
Both parties must respect declared capabilities throughout the session
Additional capabilities can be negotiated through extensions to the protocol
Each capability unlocks specific protocol features for use during the session. For
example:
Implemented
server features
must be advertised in the
server’s capabilities
Emitting resource subscription notifications requires the server to declare
subscription support
Tool invocation requires the server to declare tool capabilities
Sampling
requires the client to declare support in its
capabilities
This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.
Was this page helpful?
Yes
No
Key Changes
Overview
github
On this page
Core Components
Host
Clients
Servers
Design Principles
Capability Negotiation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/authorization

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Authorization
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Authorization
Protocol Revision
: 2025-03-26
​
Introduction
​
Purpose and Scope
The Model Context Protocol provides authorization capabilities at the transport level,
enabling MCP clients to make requests to restricted MCP servers on behalf of resource
owners. This specification defines the authorization flow for HTTP-based transports.
​
Protocol Requirements
Authorization is
OPTIONAL
for MCP implementations. When supported:
Implementations using an HTTP-based transport
SHOULD
conform to this specification.
Implementations using an STDIO transport
SHOULD NOT
follow this specification, and
instead retrieve credentials from the environment.
Implementations using alternative transports
MUST
follow established security best
practices for their protocol.
​
Standards Compliance
This authorization mechanism is based on established specifications listed below, but
implements a selected subset of their features to ensure security and interoperability
while maintaining simplicity:
OAuth 2.1 IETF DRAFT
OAuth 2.0 Authorization Server Metadata
(
RFC8414
)
OAuth 2.0 Dynamic Client Registration Protocol
(
RFC7591
)
​
Authorization Flow
​
Overview
MCP auth implementations
MUST
implement OAuth 2.1 with appropriate security
measures for both confidential and public clients.
MCP auth implementations
SHOULD
support the OAuth 2.0 Dynamic Client Registration
Protocol (
RFC7591
).
MCP servers
SHOULD
and MCP clients
MUST
implement OAuth 2.0 Authorization
Server Metadata (
RFC8414
). Servers
that do not support Authorization Server Metadata
MUST
follow the default URI
schema.
​
OAuth Grant Types
OAuth specifies different flows or grant types, which are different ways of obtaining an
access token. Each of these targets different use cases and scenarios.
MCP servers
SHOULD
support the OAuth grant types that best align with the intended
audience. For instance:
Authorization Code: useful when the client is acting on behalf of a (human) end user.
For instance, an agent calls an MCP tool implemented by a SaaS system.
Client Credentials: the client is another application (not a human)
For instance, an agent calls a secure MCP tool to check inventory at a specific
store. No need to impersonate the end user.
​
Example: authorization code grant
This demonstrates the OAuth 2.1 flow for the authorization code grant type, used for user
auth.
NOTE
: The following example assumes the MCP server is also functioning as the
authorization server. However, the authorization server may be deployed as its own
distinct service.
A human user completes the OAuth flow through a web browser, obtaining an access token
that identifies them personally and allows the client to act on their behalf.
When authorization is required and not yet proven by the client, servers
MUST
respond
with
HTTP 401 Unauthorized
.
Clients initiate the
OAuth 2.1 IETF DRAFT
authorization flow after receiving the
HTTP 401 Unauthorized
.
The following demonstrates the basic OAuth 2.1 for public clients using PKCE.
​
Server Metadata Discovery
For server capability discovery:
MCP clients
MUST
follow the OAuth 2.0 Authorization Server Metadata protocol defined
in
RFC8414
.
MCP server
SHOULD
follow the OAuth 2.0 Authorization Server Metadata protocol.
MCP servers that do not support the OAuth 2.0 Authorization Server Metadata protocol,
MUST
support fallback URLs.
The discovery flow is illustrated below:
​
Server Metadata Discovery Headers
MCP clients
SHOULD
include the header
MCP-Protocol-Version: <protocol-version>
during
Server Metadata Discovery to allow the MCP server to respond based on the MCP protocol
version.
For example:
MCP-Protocol-Version: 2024-11-05
​
Authorization Base URL
The authorization base URL
MUST
be determined from the MCP server URL by discarding
any existing
path
component. For example:
If the MCP server URL is
https://api.example.com/v1/mcp
, then:
The authorization base URL is
https://api.example.com
The metadata endpoint
MUST
be at
https://api.example.com/.well-known/oauth-authorization-server
This ensures authorization endpoints are consistently located at the root level of the
domain hosting the MCP server, regardless of any path components in the MCP server URL.
​
Fallbacks for Servers without Metadata Discovery
For servers that do not implement OAuth 2.0 Authorization Server Metadata, clients
MUST
use the following default endpoint paths relative to the
authorization base
URL
:
Endpoint
Default Path
Description
Authorization Endpoint
/authorize
Used for authorization requests
Token Endpoint
/token
Used for token exchange & refresh
Registration Endpoint
/register
Used for dynamic client registration
For example, with an MCP server hosted at
https://api.example.com/v1/mcp
, the default
endpoints would be:
https://api.example.com/authorize
https://api.example.com/token
https://api.example.com/register
Clients
MUST
first attempt to discover endpoints via the metadata document before
falling back to default paths. When using default paths, all other protocol requirements
remain unchanged.
​
Dynamic Client Registration
MCP clients and servers
SHOULD
support the
OAuth 2.0 Dynamic Client Registration Protocol
to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a
standardized way for clients to automatically register with new servers, which is crucial
for MCP because:
Clients cannot know all possible servers in advance
Manual registration would create friction for users
It enables seamless connection to new servers
Servers can implement their own registration policies
Any MCP servers that
do not
support Dynamic Client Registration need to provide
alternative ways to obtain a client ID (and, if applicable, client secret). For one of
these servers, MCP clients will have to either:
Hardcode a client ID (and, if applicable, client secret) specifically for that MCP
server, or
Present a UI to users that allows them to enter these details, after registering an
OAuth client themselves (e.g., through a configuration interface hosted by the
server).
​
Authorization Flow Steps
The complete Authorization flow proceeds as follows:
​
Decision Flow Overview
​
Access Token Usage
​
Token Requirements
Access token handling
MUST
conform to
OAuth 2.1 Section 5
requirements for resource requests. Specifically:
MCP client
MUST
use the Authorization request header field
Section 5.1.1
:
Copy
Authorization: Bearer <access-token>
Note that authorization
MUST
be included in every HTTP request from client to server,
even if they are part of the same logical session.
Access tokens
MUST NOT
be included in the URI query string
Example request:
Copy
GET
/v1/contexts
HTTP
/
1.1
Host
:
mcp.example.com
Authorization
:
Bearer eyJhbGciOiJIUzI1NiIs...
​
Token Handling
Resource servers
MUST
validate access tokens as described in
Section 5.2
.
If validation fails, servers
MUST
respond according to
Section 5.3
error handling requirements. Invalid or expired tokens
MUST
receive a HTTP 401
response.
​
Security Considerations
The following security requirements
MUST
be implemented:
Clients
MUST
securely store tokens following OAuth 2.0 best practices
Servers
SHOULD
enforce token expiration and rotation
All authorization endpoints
MUST
be served over HTTPS
Servers
MUST
validate redirect URIs to prevent open redirect vulnerabilities
Redirect URIs
MUST
be either localhost URLs or HTTPS URLs
​
Error Handling
Servers
MUST
return appropriate HTTP status codes for authorization errors:
Status Code
Description
Usage
401
Unauthorized
Authorization required or token invalid
403
Forbidden
Invalid scopes or insufficient permissions
400
Bad Request
Malformed authorization request
​
Implementation Requirements
Implementations
MUST
follow OAuth 2.1 security best practices
PKCE is
REQUIRED
for all clients
Token rotation
SHOULD
be implemented for enhanced security
Token lifetimes
SHOULD
be limited based on security requirements
​
Third-Party Authorization Flow
​
Overview
MCP servers
MAY
support delegated authorization through third-party authorization
servers. In this flow, the MCP server acts as both an OAuth client (to the third-party
auth server) and an OAuth authorization server (to the MCP client).
​
Flow Description
The third-party authorization flow comprises these steps:
MCP client initiates standard OAuth flow with MCP server
MCP server redirects user to third-party authorization server
User authorizes with third-party server
Third-party server redirects back to MCP server with authorization code
MCP server exchanges code for third-party access token
MCP server generates its own access token bound to the third-party session
MCP server completes original OAuth flow with MCP client
​
Session Binding Requirements
MCP servers implementing third-party authorization
MUST
:
Maintain secure mapping between third-party tokens and issued MCP tokens
Validate third-party token status before honoring MCP tokens
Implement appropriate token lifecycle management
Handle third-party token expiration and renewal
​
Security Considerations
When implementing third-party authorization, servers
MUST
:
Validate all redirect URIs
Securely store third-party credentials
Implement appropriate session timeout handling
Consider security implications of token chaining
Implement proper error handling for third-party auth failures
​
Best Practices
​
Local clients as Public OAuth 2.1 Clients
We strongly recommend that local clients implement OAuth 2.1 as a public client:
Utilizing code challenges (PKCE) for authorization requests to prevent interception
attacks
Implementing secure token storage appropriate for the local system
Following token refresh best practices to maintain sessions
Properly handling token expiration and renewal
​
Authorization Metadata Discovery
We strongly recommend that all clients implement metadata discovery. This reduces the
need for users to provide endpoints manually or clients to fallback to the defined
defaults.
​
Dynamic Client Registration
Since clients do not know the set of MCP servers in advance, we strongly recommend the
implementation of dynamic client registration. This allows applications to automatically
register with the MCP server, and removes the need for users to obtain client ids
manually.
Was this page helpful?
Yes
No
Transports
Cancellation
github
On this page
Introduction
Purpose and Scope
Protocol Requirements
Standards Compliance
Authorization Flow
Overview
OAuth Grant Types
Example: authorization code grant
Server Metadata Discovery
Server Metadata Discovery Headers
Authorization Base URL
Fallbacks for Servers without Metadata Discovery
Dynamic Client Registration
Authorization Flow Steps
Decision Flow Overview
Access Token Usage
Token Requirements
Token Handling
Security Considerations
Error Handling
Implementation Requirements
Third-Party Authorization Flow
Overview
Flow Description
Session Binding Requirements
Security Considerations
Best Practices
Local clients as Public OAuth 2.1 Clients
Authorization Metadata Discovery
Dynamic Client Registration
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/index

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Overview
Protocol Revision
: 2025-03-26
The Model Context Protocol consists of several key components that work together:
Base Protocol
: Core JSON-RPC message types
Lifecycle Management
: Connection initialization, capability negotiation, and
session control
Server Features
: Resources, prompts, and tools exposed by servers
Client Features
: Sampling and root directory lists provided by clients
Utilities
: Cross-cutting concerns like logging and argument completion
All implementations
MUST
support the base protocol and lifecycle management
components. Other components
MAY
be implemented based on the specific needs of the
application.
These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.
​
Messages
All messages between MCP clients and servers
MUST
follow the
JSON-RPC 2.0
specification. The protocol defines
these types of messages:
​
Requests
Requests are sent from the client to the server or vice versa, to initiate an operation.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Requests
MUST
include a string or integer ID.
Unlike base JSON-RPC, the ID
MUST NOT
be
null
.
The request ID
MUST NOT
have been previously used by the requestor within the same
session.
​
Responses
Responses are sent in reply to requests, containing the result or error of the operation.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
result
?:
{
[key: string]:
unknown
;
}
error
?:
{
code:
number
;
message
:
string
;
data
?:
unknown
;
}
}
Responses
MUST
include the same ID as the request they correspond to.
Responses
are further sub-categorized as either
successful results
or
errors
. Either a
result
or an
error
MUST
be set. A response
MUST NOT
set both.
Results
MAY
follow any JSON object structure, while errors
MUST
include an
error code and message at minimum.
Error codes
MUST
be integers.
​
Notifications
Notifications are sent from the client to the server or vice versa, as a one-way message.
The receiver
MUST NOT
send a response.
Copy
{
jsonrpc
:
"2.0"
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Notifications
MUST NOT
include an ID.
​
Batching
JSON-RPC also defines a means to
batch multiple requests and notifications
,
by sending them in an array. MCP implementations
MAY
support sending JSON-RPC
batches, but
MUST
support receiving JSON-RPC batches.
​
Auth
MCP provides an
Authorization
framework for use with HTTP.
Implementations using an HTTP-based transport
SHOULD
conform to this specification,
whereas implementations using STDIO transport
SHOULD NOT
follow this specification,
and instead retrieve credentials from the environment.
Additionally, clients and servers
MAY
negotiate their own custom authentication and
authorization strategies.
For further discussions and contributions to the evolution of MCP’s auth mechanisms, join
us in
GitHub Discussions
to help shape the future of the protocol!
​
Schema
The full specification of the protocol is defined as a
TypeScript schema
.
This is the source of truth for all protocol messages and structures.
There is also a
JSON Schema
,
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.
Was this page helpful?
Yes
No
Architecture
Lifecycle
github
On this page
Messages
Requests
Responses
Notifications
Batching
Auth
Schema
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/lifecycle

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Lifecycle
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Lifecycle
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.
Initialization
: Capability negotiation and protocol version agreement
Operation
: Normal protocol communication
Shutdown
: Graceful termination of the connection
​
Lifecycle Phases
​
Initialization
The initialization phase
MUST
be the first interaction between client and server.
During this phase, the client and server:
Establish protocol version compatibility
Exchange and negotiate capabilities
Share implementation details
The client
MUST
initiate this phase by sending an
initialize
request containing:
Protocol version supported
Client capabilities
Client implementation information
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"initialize"
,
"params"
: {
"protocolVersion"
:
"2025-03-26"
,
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
},
"sampling"
: {}
},
"clientInfo"
: {
"name"
:
"ExampleClient"
,
"version"
:
"1.0.0"
}
}
}
The initialize request
MUST NOT
be part of a JSON-RPC
batch
, as other requests and notifications
are not possible until initialization has completed. This also permits backwards
compatibility with prior protocol versions that do not explicitly support JSON-RPC
batches.
The server
MUST
respond with its own capabilities and information:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"protocolVersion"
:
"2025-03-26"
,
"capabilities"
: {
"logging"
: {},
"prompts"
: {
"listChanged"
:
true
},
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
},
"tools"
: {
"listChanged"
:
true
}
},
"serverInfo"
: {
"name"
:
"ExampleServer"
,
"version"
:
"1.0.0"
},
"instructions"
:
"Optional instructions for the client"
}
}
After successful initialization, the client
MUST
send an
initialized
notification
to indicate it is ready to begin normal operations:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/initialized"
}
The client
SHOULD NOT
send requests other than
pings
before the server has responded to the
initialize
request.
The server
SHOULD NOT
send requests other than
pings
and
logging
before receiving the
initialized
notification.
​
Version Negotiation
In the
initialize
request, the client
MUST
send a protocol version it supports.
This
SHOULD
be the
latest
version supported by the client.
If the server supports the requested protocol version, it
MUST
respond with the same
version. Otherwise, the server
MUST
respond with another protocol version it
supports. This
SHOULD
be the
latest
version supported by the server.
If the client does not support the version in the server’s response, it
SHOULD
disconnect.
​
Capability Negotiation
Client and server capabilities establish which optional protocol features will be
available during the session.
Key capabilities include:
Category
Capability
Description
Client
roots
Ability to provide filesystem
roots
Client
sampling
Support for LLM
sampling
requests
Client
experimental
Describes support for non-standard experimental features
Server
prompts
Offers
prompt templates
Server
resources
Provides readable
resources
Server
tools
Exposes callable
tools
Server
logging
Emits structured
log messages
Server
completions
Supports argument
autocompletion
Server
experimental
Describes support for non-standard experimental features
Capability objects can describe sub-capabilities like:
listChanged
: Support for list change notifications (for prompts, resources, and
tools)
subscribe
: Support for subscribing to individual items’ changes (resources only)
​
Operation
During the operation phase, the client and server exchange messages according to the
negotiated capabilities.
Both parties
SHOULD
:
Respect the negotiated protocol version
Only use capabilities that were successfully negotiated
​
Shutdown
During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are defined—instead, the underlying transport
mechanism should be used to signal connection termination:
​
stdio
For the stdio
transport
, the client
SHOULD
initiate
shutdown by:
First, closing the input stream to the child process (the server)
Waiting for the server to exit, or sending
SIGTERM
if the server does not exit
within a reasonable time
Sending
SIGKILL
if the server does not exit within a reasonable time after
SIGTERM
The server
MAY
initiate shutdown by closing its output stream to the client and
exiting.
​
HTTP
For HTTP
transports
, shutdown is indicated by closing the
associated HTTP connection(s).
​
Timeouts
Implementations
SHOULD
establish timeouts for all sent requests, to prevent hung
connections and resource exhaustion. When the request has not received a success or error
response within the timeout period, the sender
SHOULD
issue a
cancellation
notification
for that request and stop waiting for
a response.
SDKs and other middleware
SHOULD
allow these timeouts to be configured on a
per-request basis.
Implementations
MAY
choose to reset the timeout clock when receiving a
progress
notification
corresponding to the request, as this
implies that work is actually happening. However, implementations
SHOULD
always
enforce a maximum timeout, regardless of progress notifications, to limit the impact of a
misbehaving client or server.
​
Error Handling
Implementations
SHOULD
be prepared to handle these error cases:
Protocol version mismatch
Failure to negotiate required capabilities
Request
timeouts
Example initialization error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unsupported protocol version"
,
"data"
: {
"supported"
: [
"2024-11-05"
],
"requested"
:
"1.0.0"
}
}
}
Was this page helpful?
Yes
No
Overview
Transports
github
On this page
Lifecycle Phases
Initialization
Version Negotiation
Capability Negotiation
Operation
Shutdown
stdio
HTTP
Timeouts
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/transports

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Transports
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Transports
Protocol Revision
: 2025-03-26
MCP uses JSON-RPC to encode messages. JSON-RPC messages
MUST
be UTF-8 encoded.
The protocol currently defines two standard transport mechanisms for client-server
communication:
stdio
, communication over standard in and standard out
Streamable HTTP
Clients
SHOULD
support stdio whenever possible.
It is also possible for clients and servers to implement
custom transports
in a pluggable fashion.
​
stdio
In the
stdio
transport:
The client launches the MCP server as a subprocess.
The server reads JSON-RPC messages from its standard input (
stdin
) and sends messages
to its standard output (
stdout
).
Messages may be JSON-RPC requests, notifications, responses—or a JSON-RPC
batch
containing one or more requests
and/or notifications.
Messages are delimited by newlines, and
MUST NOT
contain embedded newlines.
The server
MAY
write UTF-8 strings to its standard error (
stderr
) for logging
purposes. Clients
MAY
capture, forward, or ignore this logging.
The server
MUST NOT
write anything to its
stdout
that is not a valid MCP message.
The client
MUST NOT
write anything to the server’s
stdin
that is not a valid MCP
message.
​
Streamable HTTP
This replaces the
HTTP+SSE
transport
from
protocol version 2024-11-05. See the
backwards compatibility
guide below.
In the
Streamable HTTP
transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
Server-Sent Events
(SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.
The server
MUST
provide a single HTTP endpoint path (hereafter referred to as the
MCP endpoint
) that supports both POST and GET methods. For example, this could be a
URL like
https://example.com/mcp
.
​
Security Warning
When implementing Streamable HTTP transport:
Servers
MUST
validate the
Origin
header on all incoming connections to prevent DNS rebinding attacks
When running locally, servers
SHOULD
bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
Servers
SHOULD
implement proper authentication for all connections
Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.
​
Sending Messages to the Server
Every JSON-RPC message sent from the client
MUST
be a new HTTP POST request to the
MCP endpoint.
The client
MUST
use HTTP POST to send JSON-RPC messages to the MCP endpoint.
The client
MUST
include an
Accept
header, listing both
application/json
and
text/event-stream
as supported content types.
The body of the POST request
MUST
be one of the following:
A single JSON-RPC
request
,
notification
, or
response
An array
batching
one or more
requests and/or notifications
An array
batching
one or more
responses
If the input consists solely of (any number of) JSON-RPC
responses
or
notifications
:
If the server accepts the input, the server
MUST
return HTTP status code 202
Accepted with no body.
If the server cannot accept the input, it
MUST
return an HTTP error status code
(e.g., 400 Bad Request). The HTTP response body
MAY
comprise a JSON-RPC
error
response
that has no
id
.
If the input contains any number of JSON-RPC
requests
, the server
MUST
either
return
Content-Type: text/event-stream
, to initiate an SSE stream, or
Content-Type: application/json
, to return one JSON object. The client
MUST
support both these cases.
If the server initiates an SSE stream:
The SSE stream
SHOULD
eventually include one JSON-RPC
response
per each
JSON-RPC
request
sent in the POST body. These
responses
MAY
be
batched
.
The server
MAY
send JSON-RPC
requests
and
notifications
before sending a
JSON-RPC
response
. These messages
SHOULD
relate to the originating client
request
. These
requests
and
notifications
MAY
be
batched
.
The server
SHOULD NOT
close the SSE stream before sending a JSON-RPC
response
per each received JSON-RPC
request
, unless the
session
expires.
After all JSON-RPC
responses
have been sent, the server
SHOULD
close the SSE
stream.
Disconnection
MAY
occur at any time (e.g., due to network conditions).
Therefore:
Disconnection
SHOULD NOT
be interpreted as the client cancelling its request.
To cancel, the client
SHOULD
explicitly send an MCP
CancelledNotification
.
To avoid message loss due to disconnection, the server
MAY
make the stream
resumable
.
​
Listening for Messages from the Server
The client
MAY
issue an HTTP GET to the MCP endpoint. This can be used to open an
SSE stream, allowing the server to communicate to the client, without the client first
sending data via HTTP POST.
The client
MUST
include an
Accept
header, listing
text/event-stream
as a
supported content type.
The server
MUST
either return
Content-Type: text/event-stream
in response to
this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
does not offer an SSE stream at this endpoint.
If the server initiates an SSE stream:
The server
MAY
send JSON-RPC
requests
and
notifications
on the stream. These
requests
and
notifications
MAY
be
batched
.
These messages
SHOULD
be unrelated to any concurrently-running JSON-RPC
request
from the client.
The server
MUST NOT
send a JSON-RPC
response
on the stream
unless
resuming
a stream associated with a previous client
request.
The server
MAY
close the SSE stream at any time.
The client
MAY
close the SSE stream at any time.
​
Multiple Connections
The client
MAY
remain connected to multiple SSE streams simultaneously.
The server
MUST
send each of its JSON-RPC messages on only one of the connected
streams; that is, it
MUST NOT
broadcast the same message across multiple streams.
The risk of message loss
MAY
be mitigated by making the stream
resumable
.
​
Resumability and Redelivery
To support resuming broken connections, and redelivering messages that might otherwise be
lost:
Servers
MAY
attach an
id
field to their SSE events, as described in the
SSE standard
.
If present, the ID
MUST
be globally unique across all streams within that
session
—or all streams with that specific client, if session
management is not in use.
If the client wishes to resume after a broken connection, it
SHOULD
issue an HTTP
GET to the MCP endpoint, and include the
Last-Event-ID
header to indicate the last event ID it received.
The server
MAY
use this header to replay messages that would have been sent
after the last event ID,
on the stream that was disconnected
, and to resume the
stream from that point.
The server
MUST NOT
replay messages that would have been delivered on a
different stream.
In other words, these event IDs should be assigned by servers on a
per-stream
basis, to
act as a cursor within that particular stream.
​
Session Management
An MCP “session” consists of logically related interactions between a client and a
server, beginning with the
initialization phase
. To support
servers which want to establish stateful sessions:
A server using the Streamable HTTP transport
MAY
assign a session ID at
initialization time, by including it in an
Mcp-Session-Id
header on the HTTP
response containing the
InitializeResult
.
The session ID
SHOULD
be globally unique and cryptographically secure (e.g., a
securely generated UUID, a JWT, or a cryptographic hash).
The session ID
MUST
only contain visible ASCII characters (ranging from 0x21 to
0x7E).
If an
Mcp-Session-Id
is returned by the server during initialization, clients using
the Streamable HTTP transport
MUST
include it in the
Mcp-Session-Id
header on
all of their subsequent HTTP requests.
Servers that require a session ID
SHOULD
respond to requests without an
Mcp-Session-Id
header (other than initialization) with HTTP 400 Bad Request.
The server
MAY
terminate the session at any time, after which it
MUST
respond
to requests containing that session ID with HTTP 404 Not Found.
When a client receives HTTP 404 in response to a request containing an
Mcp-Session-Id
, it
MUST
start a new session by sending a new
InitializeRequest
without a session ID attached.
Clients that no longer need a particular session (e.g., because the user is leaving
the client application)
SHOULD
send an HTTP DELETE to the MCP endpoint with the
Mcp-Session-Id
header, to explicitly terminate the session.
The server
MAY
respond to this request with HTTP 405 Method Not Allowed,
indicating that the server does not allow clients to terminate sessions.
​
Sequence Diagram
​
Backwards Compatibility
Clients and servers can maintain backwards compatibility with the deprecated
HTTP+SSE
transport
(from
protocol version 2024-11-05) as follows:
Servers
wanting to support older clients should:
Continue to host both the SSE and POST endpoints of the old transport, alongside the
new “MCP endpoint” defined for the Streamable HTTP transport.
It is also possible to combine the old POST endpoint and the new MCP endpoint, but
this may introduce unneeded complexity.
Clients
wanting to support older servers should:
Accept an MCP server URL from the user, which may point to either a server using the
old transport or the new transport.
Attempt to POST an
InitializeRequest
to the server URL, with an
Accept
header as
defined above:
If it succeeds, the client can assume this is a server supporting the new Streamable
HTTP transport.
If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
Found):
Issue a GET request to the server URL, expecting that this will open an SSE stream
and return an
endpoint
event as the first event.
When the
endpoint
event arrives, the client can assume this is a server running
the old HTTP+SSE transport, and should use that transport for all subsequent
communication.
​
Custom Transports
Clients and servers
MAY
implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.
Implementers who choose to support custom transports
MUST
ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
SHOULD
document their specific connection establishment and message exchange patterns
to aid interoperability.
Was this page helpful?
Yes
No
Lifecycle
Authorization
github
On this page
stdio
Streamable HTTP
Security Warning
Sending Messages to the Server
Listening for Messages from the Server
Multiple Connections
Resumability and Redelivery
Session Management
Sequence Diagram
Backwards Compatibility
Custom Transports
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/utilities/cancellation

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Cancellation
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Cancellation
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.
​
Cancellation Flow
When a party wants to cancel an in-progress request, it sends a
notifications/cancelled
notification containing:
The ID of the request to cancel
An optional reason string that can be logged or displayed
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/cancelled"
,
"params"
: {
"requestId"
:
"123"
,
"reason"
:
"User requested cancellation"
}
}
​
Behavior Requirements
Cancellation notifications
MUST
only reference requests that:
Were previously issued in the same direction
Are believed to still be in-progress
The
initialize
request
MUST NOT
be cancelled by clients
Receivers of cancellation notifications
SHOULD
:
Stop processing the cancelled request
Free associated resources
Not send a response for the cancelled request
Receivers
MAY
ignore cancellation notifications if:
The referenced request is unknown
Processing has already completed
The request cannot be cancelled
The sender of the cancellation notification
SHOULD
ignore any response to the
request that arrives afterward
​
Timing Considerations
Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.
Both parties
MUST
handle these race conditions gracefully:
​
Implementation Notes
Both parties
SHOULD
log cancellation reasons for debugging
Application UIs
SHOULD
indicate when cancellation is requested
​
Error Handling
Invalid cancellation notifications
SHOULD
be ignored:
Unknown request IDs
Already completed requests
Malformed notifications
This maintains the “fire and forget” nature of notifications while allowing for race
conditions in asynchronous communication.
Was this page helpful?
Yes
No
Authorization
Ping
github
On this page
Cancellation Flow
Behavior Requirements
Timing Considerations
Implementation Notes
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/utilities/ping

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Ping
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Ping
Protocol Revision
: 2025-03-26
The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.
​
Overview
The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a
ping
request.
​
Message Format
A ping request is a standard JSON-RPC request with no parameters:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"method"
:
"ping"
}
​
Behavior Requirements
The receiver
MUST
respond promptly with an empty response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {}
}
If no response is received within a reasonable timeout period, the sender
MAY
:
Consider the connection stale
Terminate the connection
Attempt reconnection procedures
​
Usage Patterns
​
Implementation Considerations
Implementations
SHOULD
periodically issue pings to detect connection health
The frequency of pings
SHOULD
be configurable
Timeouts
SHOULD
be appropriate for the network environment
Excessive pinging
SHOULD
be avoided to reduce network overhead
​
Error Handling
Timeouts
SHOULD
be treated as connection failures
Multiple failed pings
MAY
trigger connection reset
Implementations
SHOULD
log ping failures for diagnostics
Was this page helpful?
Yes
No
Cancellation
Progress
github
On this page
Overview
Message Format
Behavior Requirements
Usage Patterns
Implementation Considerations
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/basic/utilities/progress

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Progress
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Progress
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.
​
Progress Flow
When a party wants to
receive
progress updates for a request, it includes a
progressToken
in the request metadata.
Progress tokens
MUST
be a string or integer value
Progress tokens can be chosen by the sender using any means, but
MUST
be unique
across all active requests.
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"some_method"
,
"params"
: {
"_meta"
: {
"progressToken"
:
"abc123"
}
}
}
The receiver
MAY
then send progress notifications containing:
The original progress token
The current progress value so far
An optional “total” value
An optional “message” value
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/progress"
,
"params"
: {
"progressToken"
:
"abc123"
,
"progress"
:
50
,
"total"
:
100
,
"message"
:
"Reticulating splines..."
}
}
The
progress
value
MUST
increase with each notification, even if the total is
unknown.
The
progress
and the
total
values
MAY
be floating point.
The
message
field
SHOULD
provide relevant human readable progress information.
​
Behavior Requirements
Progress notifications
MUST
only reference tokens that:
Were provided in an active request
Are associated with an in-progress operation
Receivers of progress requests
MAY
:
Choose not to send any progress notifications
Send notifications at whatever frequency they deem appropriate
Omit the total value if unknown
​
Implementation Notes
Senders and receivers
SHOULD
track active progress tokens
Both parties
SHOULD
implement rate limiting to prevent flooding
Progress notifications
MUST
stop after completion
Was this page helpful?
Yes
No
Ping
Roots
github
On this page
Progress Flow
Behavior Requirements
Implementation Notes
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/changelog

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Key Changes
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Key Changes
This document lists changes made to the Model Context Protocol (MCP) specification since
the previous revision,
2024-11-05
.
​
Major changes
Added a comprehensive
authorization framework
based on OAuth 2.1 (PR
#133
)
Replaced the previous HTTP+SSE transport with a more flexible
Streamable HTTP
transport
(PR
#206
)
Added support for JSON-RPC
batching
(PR
#228
)
Added comprehensive
tool annotations
for better describing tool behavior, like
whether it is read-only or destructive (PR
#185
)
​
Other schema changes
Added
message
field to
ProgressNotification
to provide descriptive status updates
Added support for audio data, joining the existing text and image content types
Added
completions
capability to explicitly indicate support for argument
autocompletion suggestions
See
the updated schema
for more details.
​
Full changelog
For a complete list of all changes that have been made since the last protocol revision,
see GitHub
.
Was this page helpful?
Yes
No
Specification
Architecture
github
On this page
Major changes
Other schema changes
Full changelog
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/client/roots

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Roots
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Roots
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem “roots” to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.
​
User Interaction Model
Roots in MCP are typically exposed through workspace or project configuration interfaces.
For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.
However, implementations are free to expose roots through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Clients that support roots
MUST
declare the
roots
capability during
initialization
:
Copy
{
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the client will emit notifications when the list of roots
changes.
​
Protocol Messages
​
Listing Roots
To retrieve roots, servers send a
roots/list
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"roots/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"roots"
: [
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
]
}
}
​
Root List Changes
When roots change, clients that support
listChanged
MUST
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/roots/list_changed"
}
​
Message Flow
​
Data Types
​
Root
A root definition includes:
uri
: Unique identifier for the root. This
MUST
be a
file://
URI in the current
specification.
name
: Optional human-readable name for display purposes.
Example roots for different use cases:
​
Project Directory
Copy
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
​
Multiple Repositories
Copy
[
{
"uri"
:
"file:///home/user/repos/frontend"
,
"name"
:
"Frontend Repository"
},
{
"uri"
:
"file:///home/user/repos/backend"
,
"name"
:
"Backend Repository"
}
]
​
Error Handling
Clients
SHOULD
return standard JSON-RPC errors for common failure cases:
Client does not support roots:
-32601
(Method not found)
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32601
,
"message"
:
"Roots not supported"
,
"data"
: {
"reason"
:
"Client does not have roots capability"
}
}
}
​
Security Considerations
Clients
MUST
:
Only expose roots with appropriate permissions
Validate all root URIs to prevent path traversal
Implement proper access controls
Monitor root accessibility
Servers
SHOULD
:
Handle cases where roots become unavailable
Respect root boundaries during operations
Validate all paths against provided roots
​
Implementation Guidelines
Clients
SHOULD
:
Prompt users for consent before exposing roots to servers
Provide clear user interfaces for root management
Validate root accessibility before exposing
Monitor for root changes
Servers
SHOULD
:
Check for roots capability before usage
Handle root list changes gracefully
Respect root boundaries in operations
Cache root information appropriately
Was this page helpful?
Yes
No
Progress
Sampling
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Roots
Root List Changes
Message Flow
Data Types
Root
Project Directory
Multiple Repositories
Error Handling
Security Considerations
Implementation Guidelines
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/client/sampling

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Sampling
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Sampling
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling (“completions” or “generations”) from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities—with no server API keys necessary.
Servers can request text, audio, or image-based interactions and optionally include
context from MCP servers in their prompts.
​
User Interaction Model
Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur
nested
inside other MCP server features.
Implementations are free to expose sampling through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny sampling requests.
Applications
SHOULD
:
Provide UI that makes it easy and intuitive to review sampling requests
Allow users to view and edit prompts before sending
Present generated responses for review before delivery
​
Capabilities
Clients that support sampling
MUST
declare the
sampling
capability during
initialization
:
Copy
{
"capabilities"
: {
"sampling"
: {}
}
}
​
Protocol Messages
​
Creating Messages
To request a language model generation, servers send a
sampling/createMessage
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"sampling/createMessage"
,
"params"
: {
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"What is the capital of France?"
}
}
],
"modelPreferences"
: {
"hints"
: [
{
"name"
:
"claude-3-sonnet"
}
],
"intelligencePriority"
:
0.8
,
"speedPriority"
:
0.5
},
"systemPrompt"
:
"You are a helpful assistant."
,
"maxTokens"
:
100
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"role"
:
"assistant"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"The capital of France is Paris."
},
"model"
:
"claude-3-sonnet-20240307"
,
"stopReason"
:
"endTurn"
}
}
​
Message Flow
​
Data Types
​
Messages
Sampling messages can contain:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"The message content"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/jpeg"
}
​
Audio Content
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
​
Model Preferences
Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider’s equivalent model.
To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:
​
Capability Priorities
Servers express their needs through three normalized priority values (0-1):
costPriority
: How important is minimizing costs? Higher values prefer cheaper models.
speedPriority
: How important is low latency? Higher values prefer faster models.
intelligencePriority
: How important are advanced capabilities? Higher values prefer
more capable models.
​
Model Hints
While priorities help select models based on characteristics,
hints
allow servers to
suggest specific models or model families:
Hints are treated as substrings that can match model names flexibly
Multiple hints are evaluated in order of preference
Clients
MAY
map hints to equivalent models from different providers
Hints are advisory—clients make final model selection
For example:
Copy
{
"hints"
: [
{
"name"
:
"claude-3-sonnet"
},
// Prefer Sonnet-class models
{
"name"
:
"claude"
}
// Fall back to any Claude model
],
"costPriority"
:
0.3
,
// Cost is less important
"speedPriority"
:
0.8
,
// Speed is very important
"intelligencePriority"
:
0.5
// Moderate capability needs
}
The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn’t have access to Claude models but has Gemini,
it might map the sonnet hint to
gemini-1.5-pro
based on similar capabilities.
​
Error Handling
Clients
SHOULD
return errors for common failure cases:
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-1
,
"message"
:
"User rejected sampling request"
}
}
​
Security Considerations
Clients
SHOULD
implement user approval controls
Both parties
SHOULD
validate message content
Clients
SHOULD
respect model preference hints
Clients
SHOULD
implement rate limiting
Both parties
MUST
handle sensitive data appropriately
Was this page helpful?
Yes
No
Roots
Overview
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Creating Messages
Message Flow
Data Types
Messages
Text Content
Image Content
Audio Content
Model Preferences
Capability Priorities
Model Hints
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/index

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Specification
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Specification
Model Context Protocol
(MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.
This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
schema.ts
.
For implementation guides and examples, visit
modelcontextprotocol.io
.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD
NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in
BCP 14
[
RFC2119
]
[
RFC8174
] when, and only when, they
appear in all capitals, as shown here.
​
Overview
MCP provides a standardized way for applications to:
Share contextual information with language models
Expose tools and capabilities to AI systems
Build composable integrations and workflows
The protocol uses
JSON-RPC
2.0 messages to establish
communication between:
Hosts
: LLM applications that initiate connections
Clients
: Connectors within the host application
Servers
: Services that provide context and capabilities
MCP takes some inspiration from the
Language Server Protocol
, which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.
​
Key Details
​
Base Protocol
JSON-RPC
message format
Stateful connections
Server and client capability negotiation
​
Features
Servers offer any of the following features to clients:
Resources
: Context and data, for the user or the AI model to use
Prompts
: Templated messages and workflows for users
Tools
: Functions for the AI model to execute
Clients may offer the following feature to servers:
Sampling
: Server-initiated agentic behaviors and recursive LLM interactions
​
Additional Utilities
Configuration
Progress tracking
Cancellation
Error reporting
Logging
​
Security and Trust & Safety
The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.
​
Key Principles
User Consent and Control
Users must explicitly consent to and understand all data access and operations
Users must retain control over what data is shared and what actions are taken
Implementors should provide clear UIs for reviewing and authorizing activities
Data Privacy
Hosts must obtain explicit user consent before exposing user data to servers
Hosts must not transmit resource data elsewhere without user consent
User data should be protected with appropriate access controls
Tool Safety
Tools represent arbitrary code execution and must be treated with appropriate
caution.
In particular, descriptions of tool behavior such as annotations should be
considered untrusted, unless obtained from a trusted server.
Hosts must obtain explicit user consent before invoking any tool
Users should understand what each tool does before authorizing its use
LLM Sampling Controls
Users must explicitly approve any LLM sampling requests
Users should control:
Whether sampling occurs at all
The actual prompt that will be sent
What results the server can see
The protocol intentionally limits server visibility into prompts
​
Implementation Guidelines
While MCP itself cannot enforce these security principles at the protocol level,
implementors
SHOULD
:
Build robust consent and authorization flows into their applications
Provide clear documentation of security implications
Implement appropriate access controls and data protections
Follow security best practices in their integrations
Consider privacy implications in their feature designs
​
Learn More
Explore the detailed specification for each protocol component:
Architecture
Base Protocol
Server Features
Client Features
Contributing
Was this page helpful?
Yes
No
FAQs
Key Changes
github
On this page
Overview
Key Details
Base Protocol
Features
Additional Utilities
Security and Trust & Safety
Key Principles
Implementation Guidelines
Learn More
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/index

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Overview
Protocol Revision
: 2025-03-26
Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:
Prompts
: Pre-defined templates or instructions that guide language model
interactions
Resources
: Structured data or content that provides additional context to the model
Tools
: Executable functions that allow models to perform actions or retrieve
information
Each primitive can be summarized in the following control hierarchy:
Primitive
Control
Description
Example
Prompts
User-controlled
Interactive templates invoked by user choice
Slash commands, menu options
Resources
Application-controlled
Contextual data attached and managed by the client
File contents, git history
Tools
Model-controlled
Functions exposed to the LLM to take actions
API POST requests, file writing
Explore these key primitives in more detail below:
Prompts
Resources
Tools
Was this page helpful?
Yes
No
Sampling
Prompts
github
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/prompts

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Prompts
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Prompts
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.
​
User Interaction Model
Prompts are designed to be
user-controlled
, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.
Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.
For example, as slash commands:
However, implementors are free to expose prompts through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
​
Capabilities
Servers that support prompts
MUST
declare the
prompts
capability during
initialization
:
Copy
{
"capabilities"
: {
"prompts"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available prompts changes.
​
Protocol Messages
​
Listing Prompts
To retrieve available prompts, clients send a
prompts/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"prompts/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"prompts"
: [
{
"name"
:
"code_review"
,
"description"
:
"Asks the LLM to analyze code quality and suggest improvements"
,
"arguments"
: [
{
"name"
:
"code"
,
"description"
:
"The code to review"
,
"required"
:
true
}
]
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Getting a Prompt
To retrieve a specific prompt, clients send a
prompts/get
request. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"prompts/get"
,
"params"
: {
"name"
:
"code_review"
,
"arguments"
: {
"code"
:
"def hello():
\n
print('world')"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"description"
:
"Code review prompt"
,
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"Please review this Python code:
\n
def hello():
\n
print('world')"
}
}
]
}
}
​
List Changed Notification
When the list of available prompts changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/prompts/list_changed"
}
​
Message Flow
​
Data Types
​
Prompt
A prompt definition includes:
name
: Unique identifier for the prompt
description
: Optional human-readable description
arguments
: Optional list of arguments for customization
​
PromptMessage
Messages in a prompt can contain:
role
: Either “user” or “assistant” to indicate the speaker
content
: One of the following content types:
​
Text Content
Text content represents plain text messages:
Copy
{
"type"
:
"text"
,
"text"
:
"The text content of the message"
}
This is the most common content type used for natural language interactions.
​
Image Content
Image content allows including visual information in messages:
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/png"
}
The image data
MUST
be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.
​
Audio Content
Audio content allows including audio information in messages:
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
The audio data MUST be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where audio context is important.
​
Embedded Resources
Embedded resources allow referencing server-side resources directly in messages:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"resource://example"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
}
Resources can contain either text or binary (blob) data and
MUST
include:
A valid resource URI
The appropriate MIME type
Either text content or base64-encoded blob data
Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
validate prompt arguments before processing
Clients
SHOULD
handle pagination for large prompt lists
Both parties
SHOULD
respect capability negotiation
​
Security
Implementations
MUST
carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.
Was this page helpful?
Yes
No
Overview
Resources
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Prompts
Getting a Prompt
List Changed Notification
Message Flow
Data Types
Prompt
PromptMessage
Text Content
Image Content
Audio Content
Embedded Resources
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/resources

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Resources
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Resources
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
URI
.
​
User Interaction Model
Resources in MCP are designed to be
application-driven
, with host applications
determining how to incorporate context based on their needs.
For example, applications could:
Expose resources through UI elements for explicit selection, in a tree or list view
Allow the user to search through and filter available resources
Implement automatic context inclusion, based on heuristics or the AI model’s selection
However, implementations are free to expose resources through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support resources
MUST
declare the
resources
capability:
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
}
}
}
The capability supports two optional features:
subscribe
: whether the client can subscribe to be notified of changes to individual
resources.
listChanged
: whether the server will emit notifications when the list of available
resources changes.
Both
subscribe
and
listChanged
are optional—servers can support neither,
either, or both:
Copy
{
"capabilities"
: {
"resources"
: {}
// Neither feature supported
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
// Only subscriptions supported
}
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"listChanged"
:
true
// Only list change notifications supported
}
}
}
​
Protocol Messages
​
Listing Resources
To discover available resources, clients send a
resources/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"resources"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"description"
:
"Primary application entry point"
,
"mimeType"
:
"text/x-rust"
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Reading Resources
To retrieve resource contents, clients send a
resources/read
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"resources/read"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"contents"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"mimeType"
:
"text/x-rust"
,
"text"
:
"fn main() {
\n
println!(
\"
Hello world!
\"
);
\n
}"
}
]
}
}
​
Resource Templates
Resource templates allow servers to expose parameterized resources using
URI templates
. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"method"
:
"resources/templates/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"result"
: {
"resourceTemplates"
: [
{
"uriTemplate"
:
"file:///{path}"
,
"name"
:
"Project Files"
,
"description"
:
"Access files in the project directory"
,
"mimeType"
:
"application/octet-stream"
}
]
}
}
​
List Changed Notification
When the list of available resources changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/list_changed"
}
​
Subscriptions
The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:
Subscribe Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"method"
:
"resources/subscribe"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Update Notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/updated"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
​
Message Flow
​
Data Types
​
Resource
A resource definition includes:
uri
: Unique identifier for the resource
name
: Human-readable name
description
: Optional description
mimeType
: Optional MIME type
size
: Optional size in bytes
​
Resource Contents
Resources can contain either text or binary data:
​
Text Content
Copy
{
"uri"
:
"file:///example.txt"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
​
Binary Content
Copy
{
"uri"
:
"file:///example.png"
,
"mimeType"
:
"image/png"
,
"blob"
:
"base64-encoded-data"
}
​
Common URI Schemes
The protocol defines several standard URI schemes. This list not
exhaustive—implementations are always free to use additional, custom URI schemes.
​
https://
Used to represent a resource available on the web.
Servers
SHOULD
use this scheme only when the client is able to fetch and load the
resource directly from the web on its own—that is, it doesn’t need to read the resource
via the MCP server.
For other use cases, servers
SHOULD
prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.
​
file://
Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.
MCP servers
MAY
identify file:// resources with an
XDG MIME type
,
like
inode/directory
, to represent non-regular files (such as directories) that don’t
otherwise have a standard MIME type.
​
git://
Git version control integration.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Resource not found:
-32002
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
5
,
"error"
: {
"code"
:
-32002
,
"message"
:
"Resource not found"
,
"data"
: {
"uri"
:
"file:///nonexistent.txt"
}
}
}
​
Security Considerations
Servers
MUST
validate all resource URIs
Access controls
SHOULD
be implemented for sensitive resources
Binary data
MUST
be properly encoded
Resource permissions
SHOULD
be checked before operations
Was this page helpful?
Yes
No
Prompts
Tools
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Resources
Reading Resources
Resource Templates
List Changed Notification
Subscriptions
Message Flow
Data Types
Resource
Resource Contents
Text Content
Binary Content
Common URI Schemes
https://
file://
git://
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/tools

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Tools
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Tools
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.
​
User Interaction Model
Tools in MCP are designed to be
model-controlled
, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user’s prompts.
However, implementations are free to expose tools through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny tool invocations.
Applications
SHOULD
:
Provide UI that makes clear which tools are being exposed to the AI model
Insert clear visual indicators when tools are invoked
Present confirmation prompts to the user for operations, to ensure a human is in the
loop
​
Capabilities
Servers that support tools
MUST
declare the
tools
capability:
Copy
{
"capabilities"
: {
"tools"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available tools changes.
​
Protocol Messages
​
Listing Tools
To discover available tools, clients send a
tools/list
request. This operation supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"tools/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"tools"
: [
{
"name"
:
"get_weather"
,
"description"
:
"Get current weather information for a location"
,
"inputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"location"
: {
"type"
:
"string"
,
"description"
:
"City name or zip code"
}
},
"required"
: [
"location"
]
}
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Calling Tools
To invoke a tool, clients send a
tools/call
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"tools/call"
,
"params"
: {
"name"
:
"get_weather"
,
"arguments"
: {
"location"
:
"New York"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Current weather in New York:
\n
Temperature: 72°F
\n
Conditions: Partly cloudy"
}
],
"isError"
:
false
}
}
​
List Changed Notification
When the list of available tools changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/tools/list_changed"
}
​
Message Flow
​
Data Types
​
Tool
A tool definition includes:
name
: Unique identifier for the tool
description
: Human-readable description of functionality
inputSchema
: JSON Schema defining expected parameters
annotations
: optional properties describing tool behavior
For trust & safety and security, clients
MUST
consider
tool annotations to be untrusted unless they come from trusted servers.
​
Tool Result
Tool results can contain multiple content items of different types:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"Tool result text"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-data"
,
"mimeType"
:
"image/png"
}
​
Audio Content
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
​
Embedded Resources
Resources
MAY
be embedded, to provide additional context
or data, behind a URI that can be subscribed to or fetched again by the client later:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"resource://example"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
}
​
Error Handling
Tools use two error reporting mechanisms:
Protocol Errors
: Standard JSON-RPC errors for issues like:
Unknown tools
Invalid arguments
Server errors
Tool Execution Errors
: Reported in tool results with
isError: true
:
API failures
Invalid input data
Business logic errors
Example protocol error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unknown tool: invalid_tool_name"
}
}
Example tool execution error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Failed to fetch weather data: API rate limit exceeded"
}
],
"isError"
:
true
}
}
​
Security Considerations
Servers
MUST
:
Validate all tool inputs
Implement proper access controls
Rate limit tool invocations
Sanitize tool outputs
Clients
SHOULD
:
Prompt for user confirmation on sensitive operations
Show tool inputs to the user before calling the server, to avoid malicious or
accidental data exfiltration
Validate tool results before passing to LLM
Implement timeouts for tool calls
Log tool usage for audit purposes
Was this page helpful?
Yes
No
Resources
Completion
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Tools
Calling Tools
List Changed Notification
Message Flow
Data Types
Tool
Tool Result
Text Content
Image Content
Audio Content
Embedded Resources
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/utilities/completion

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Completion
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Completion
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.
​
User Interaction Model
Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.
For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.
However, implementations are free to expose completion through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support completions
MUST
declare the
completions
capability:
Copy
{
"capabilities"
: {
"completions"
: {}
}
}
​
Protocol Messages
​
Requesting Completions
To get completion suggestions, clients send a
completion/complete
request specifying
what is being completed through a reference type:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"completion/complete"
,
"params"
: {
"ref"
: {
"type"
:
"ref/prompt"
,
"name"
:
"code_review"
},
"argument"
: {
"name"
:
"language"
,
"value"
:
"py"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"completion"
: {
"values"
: [
"python"
,
"pytorch"
,
"pyside"
],
"total"
:
10
,
"hasMore"
:
true
}
}
}
​
Reference Types
The protocol supports two types of completion references:
Type
Description
Example
ref/prompt
References a prompt by name
{"type": "ref/prompt", "name": "code_review"}
ref/resource
References a resource URI
{"type": "ref/resource", "uri": "file:///{path}"}
​
Completion Results
Servers return an array of completion values ranked by relevance, with:
Maximum 100 items per response
Optional total number of available matches
Boolean indicating if additional results exist
​
Message Flow
​
Data Types
​
CompleteRequest
ref
: A
PromptReference
or
ResourceReference
argument
: Object containing:
name
: Argument name
value
: Current value
​
CompleteResult
completion
: Object containing:
values
: Array of suggestions (max 100)
total
: Optional total matches
hasMore
: Additional results flag
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Method not found:
-32601
(Capability not supported)
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Return suggestions sorted by relevance
Implement fuzzy matching where appropriate
Rate limit completion requests
Validate all inputs
Clients
SHOULD
:
Debounce rapid completion requests
Cache completion results where appropriate
Handle missing or partial results gracefully
​
Security
Implementations
MUST
:
Validate all completion inputs
Implement appropriate rate limiting
Control access to sensitive suggestions
Prevent completion-based information disclosure
Was this page helpful?
Yes
No
Tools
Logging
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Requesting Completions
Reference Types
Completion Results
Message Flow
Data Types
CompleteRequest
CompleteResult
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/utilities/logging

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Logging
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Logging
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.
​
User Interaction Model
Implementations are free to expose logging through any interface pattern that suits their
needs—the protocol itself does not mandate any specific user interaction model.
​
Capabilities
Servers that emit log message notifications
MUST
declare the
logging
capability:
Copy
{
"capabilities"
: {
"logging"
: {}
}
}
​
Log Levels
The protocol follows the standard syslog severity levels specified in
RFC 5424
:
Level
Description
Example Use Case
debug
Detailed debugging information
Function entry/exit points
info
General informational messages
Operation progress updates
notice
Normal but significant events
Configuration changes
warning
Warning conditions
Deprecated feature usage
error
Error conditions
Operation failures
critical
Critical conditions
System component failures
alert
Action must be taken immediately
Data corruption detected
emergency
System is unusable
Complete system failure
​
Protocol Messages
​
Setting Log Level
To configure the minimum log level, clients
MAY
send a
logging/setLevel
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"logging/setLevel"
,
"params"
: {
"level"
:
"info"
}
}
​
Log Message Notifications
Servers send log messages using
notifications/message
notifications:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/message"
,
"params"
: {
"level"
:
"error"
,
"logger"
:
"database"
,
"data"
: {
"error"
:
"Connection failed"
,
"details"
: {
"host"
:
"localhost"
,
"port"
:
5432
}
}
}
}
​
Message Flow
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid log level:
-32602
(Invalid params)
Configuration errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Rate limit log messages
Include relevant context in data field
Use consistent logger names
Remove sensitive information
Clients
MAY
:
Present log messages in the UI
Implement log filtering/search
Display severity visually
Persist log messages
​
Security
Log messages
MUST NOT
contain:
Credentials or secrets
Personal identifying information
Internal system details that could aid attacks
Implementations
SHOULD
:
Rate limit messages
Validate all data fields
Control log access
Monitor for sensitive content
Was this page helpful?
Yes
No
Completion
Pagination
github
On this page
User Interaction Model
Capabilities
Log Levels
Protocol Messages
Setting Log Level
Log Message Notifications
Message Flow
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-03-26/server/utilities/pagination

Model Context Protocol
home page
Version 2025-03-26
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Pagination
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Pagination
Protocol Revision
: 2025-03-26
The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.
Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.
​
Pagination Model
Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.
The
cursor
is an opaque string token, representing a position in the result set
Page size
is determined by the server, and clients
MUST NOT
assume a fixed page
size
​
Response Format
Pagination starts when the server sends a
response
that includes:
The current page of results
An optional
nextCursor
field if more results exist
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {
"resources"
: [
...
],
"nextCursor"
:
"eyJwYWdlIjogM30="
}
}
​
Request Format
After receiving a cursor, the client can
continue
paginating by issuing a request
including that cursor:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"eyJwYWdlIjogMn0="
}
}
​
Pagination Flow
​
Operations Supporting Pagination
The following MCP operations support pagination:
resources/list
- List available resources
resources/templates/list
- List resource templates
prompts/list
- List available prompts
tools/list
- List available tools
​
Implementation Guidelines
Servers
SHOULD
:
Provide stable cursors
Handle invalid cursors gracefully
Clients
SHOULD
:
Treat a missing
nextCursor
as the end of results
Support both paginated and non-paginated flows
Clients
MUST
treat cursors as opaque tokens:
Don’t make assumptions about cursor format
Don’t attempt to parse or modify cursors
Don’t persist cursors across sessions
​
Error Handling
Invalid cursors
SHOULD
result in an error with code -32602 (Invalid params).
Was this page helpful?
Yes
No
Logging
Versioning
github
On this page
Pagination Model
Response Format
Request Format
Pagination Flow
Operations Supporting Pagination
Implementation Guidelines
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/architecture/index

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Architecture
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Architecture
The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.
​
Core Components
​
Host
The host process acts as the container and coordinator:
Creates and manages multiple client instances
Controls client connection permissions and lifecycle
Enforces security policies and consent requirements
Handles user authorization decisions
Coordinates AI/LLM integration and sampling
Manages context aggregation across clients
​
Clients
Each client is created by the host and maintains an isolated server connection:
Establishes one stateful session per server
Handles protocol negotiation and capability exchange
Routes protocol messages bidirectionally
Manages subscriptions and notifications
Maintains security boundaries between servers
A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.
​
Servers
Servers provide specialized context and capabilities:
Expose resources, tools and prompts via MCP primitives
Operate independently with focused responsibilities
Request sampling through client interfaces
Must respect security constraints
Can be local processes or remote services
​
Design Principles
MCP is built on several key design principles that inform its architecture and
implementation:
Servers should be extremely easy to build
Host applications handle complex orchestration responsibilities
Servers focus on specific, well-defined capabilities
Simple interfaces minimize implementation overhead
Clear separation enables maintainable code
Servers should be highly composable
Each server provides focused functionality in isolation
Multiple servers can be combined seamlessly
Shared protocol enables interoperability
Modular design supports extensibility
Servers should not be able to read the whole conversation, nor “see into” other
servers
Servers receive only necessary contextual information
Full conversation history stays with the host
Each server connection maintains isolation
Cross-server interactions are controlled by the host
Host process enforces security boundaries
Features can be added to servers and clients progressively
Core protocol provides minimal required functionality
Additional capabilities can be negotiated as needed
Servers and clients evolve independently
Protocol designed for future extensibility
Backwards compatibility is maintained
​
Capability Negotiation
The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.
Servers declare capabilities like resource subscriptions, tool support, and prompt
templates
Clients declare capabilities like sampling support and notification handling
Both parties must respect declared capabilities throughout the session
Additional capabilities can be negotiated through extensions to the protocol
Each capability unlocks specific protocol features for use during the session. For
example:
Implemented
server features
must be advertised in the
server’s capabilities
Emitting resource subscription notifications requires the server to declare
subscription support
Tool invocation requires the server to declare tool capabilities
Sampling
requires the client to declare support in its
capabilities
This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.
Was this page helpful?
Yes
No
Key Changes
Overview
github
On this page
Core Components
Host
Clients
Servers
Design Principles
Capability Negotiation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/authorization

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Authorization
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Authorization
Protocol Revision
: 2025-06-18
​
Introduction
​
Purpose and Scope
The Model Context Protocol provides authorization capabilities at the transport level,
enabling MCP clients to make requests to restricted MCP servers on behalf of resource
owners. This specification defines the authorization flow for HTTP-based transports.
​
Protocol Requirements
Authorization is
OPTIONAL
for MCP implementations. When supported:
Implementations using an HTTP-based transport
SHOULD
conform to this specification.
Implementations using an STDIO transport
SHOULD NOT
follow this specification, and
instead retrieve credentials from the environment.
Implementations using alternative transports
MUST
follow established security best
practices for their protocol.
​
Standards Compliance
This authorization mechanism is based on established specifications listed below, but
implements a selected subset of their features to ensure security and interoperability
while maintaining simplicity:
OAuth 2.1 IETF DRAFT (
draft-ietf-oauth-v2-1-12
)
OAuth 2.0 Authorization Server Metadata
(
RFC8414
)
OAuth 2.0 Dynamic Client Registration Protocol
(
RFC7591
)
OAuth 2.0 Protected Resource Metadata (
RFC9728
)
​
Authorization Flow
​
Roles
A protected
MCP server
acts as an
OAuth 2.1 resource server
,
capable of accepting and responding to protected resource requests using access tokens.
An
MCP client
acts as an
OAuth 2.1 client
,
making protected resource requests on behalf of a resource owner.
The
authorization server
is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server.
The implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the
resource server or a separate entity. The
Authorization Server Discovery section
specifies how an MCP server indicates the location of its corresponding authorization server to a client.
​
Overview
Authorization servers
MUST
implement OAuth 2.1 with appropriate security
measures for both confidential and public clients.
Authorization servers and MCP clients
SHOULD
support the OAuth 2.0 Dynamic Client Registration
Protocol (
RFC7591
).
MCP servers
MUST
implement OAuth 2.0 Protected Resource Metadata (
RFC9728
).
MCP clients
MUST
use OAuth 2.0 Protected Resource Metadata for authorization server discovery.
Authorization servers
MUST
provide OAuth 2.0 Authorization
Server Metadata (
RFC8414
).
MCP clients
MUST
use the OAuth 2.0 Authorization Server Metadata.
​
Authorization Server Discovery
This section describes the mechanisms by which MCP servers advertise their associated
authorization servers to MCP clients, as well as the discovery process through which MCP
clients can determine authorization server endpoints and supported capabilities.
​
Authorization Server Location
MCP servers
MUST
implement the OAuth 2.0 Protected Resource Metadata (
RFC9728
)
specification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server
MUST
include
the
authorization_servers
field containing at least one authorization server.
The specific use of
authorization_servers
is beyond the scope of this specification; implementers should consult
OAuth 2.0 Protected Resource Metadata (
RFC9728
) for
guidance on implementation details.
Implementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in
RFC9728 Section 7.6 “Authorization Servers”
.
MCP servers
MUST
use the HTTP header
WWW-Authenticate
when returning a
401 Unauthorized
to indicate the location of the resource server metadata URL
as described in
RFC9728 Section 5.1 “WWW-Authenticate Response”
.
MCP clients
MUST
be able to parse
WWW-Authenticate
headers and respond appropriately to
HTTP 401 Unauthorized
responses from the MCP server.
​
Server Metadata Discovery
MCP clients
MUST
follow the OAuth 2.0 Authorization Server Metadata
RFC8414
specification to obtain the information required to interact with the authorization server.
​
Sequence Diagram
The following diagram outlines an example flow:
​
Dynamic Client Registration
MCP clients and authorization servers
SHOULD
support the
OAuth 2.0 Dynamic Client Registration Protocol
RFC7591
to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a
standardized way for clients to automatically register with new authorization servers, which is crucial
for MCP because:
Clients may not know all possible MCP servers and their authorization servers in advance.
Manual registration would create friction for users.
It enables seamless connection to new MCP servers and their authorization servers.
Authorization servers can implement their own registration policies.
Any authorization servers that
do not
support Dynamic Client Registration need to provide
alternative ways to obtain a client ID (and, if applicable, client credentials). For one of
these authorization servers, MCP clients will have to either:
Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when
interacting with that authorization server, or
Present a UI to users that allows them to enter these details, after registering an
OAuth client themselves (e.g., through a configuration interface hosted by the
server).
​
Authorization Flow Steps
The complete Authorization flow proceeds as follows:
​
Resource Parameter Implementation
MCP clients
MUST
implement Resource Indicators for OAuth 2.0 as defined in
RFC 8707
to explicitly specify the target resource for which the token is being requested. The
resource
parameter:
MUST
be included in both authorization requests and token requests.
MUST
identify the MCP server that the client intends to use the token with.
MUST
use the canonical URI of the MCP server as defined in
RFC 8707 Section 2
.
Canonical Server URI
For the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in
RFC 8707 Section 2
and aligns with the
resource
parameter in
RFC 9728
.
MCP clients
SHOULD
provide the most specific URI that they can for the MCP server they intend to access, following the guidance in
RFC 8707
. While the canonical form uses lowercase scheme and host components, implementations
SHOULD
accept uppercase scheme and host components for robustness and interoperability.
Examples of valid canonical URIs:
https://mcp.example.com/mcp
https://mcp.example.com
https://mcp.example.com:8443
https://mcp.example.com/server/mcp
(when path component is necessary to identify individual MCP server)
Examples of invalid canonical URIs:
mcp.example.com
(missing scheme)
https://mcp.example.com#fragment
(contains fragment)
Note:
While both
https://mcp.example.com/
(with trailing slash) and
https://mcp.example.com
(without trailing slash) are technically valid absolute URIs according to
RFC 3986
, implementations
SHOULD
consistently use the form without the trailing slash for better interoperability unless the trailing slash is semantically significant for the specific resource.
For example, if accessing an MCP server at
https://mcp.example.com
, the authorization request would include:
Copy
&resource=https%3A%2F%2Fmcp.example.com
MCP clients
MUST
send this parameter regardless of whether authorization servers support it.
​
Access Token Usage
​
Token Requirements
Access token handling when making requests to MCP servers
MUST
conform to the requirements defined in
OAuth 2.1 Section 5 “Resource Requests”
.
Specifically:
MCP client
MUST
use the Authorization request header field defined in
OAuth 2.1 Section 5.1.1
:
Copy
Authorization: Bearer <access-token>
Note that authorization
MUST
be included in every HTTP request from client to server,
even if they are part of the same logical session.
Access tokens
MUST NOT
be included in the URI query string
Example request:
Copy
GET
/mcp
HTTP
/
1.1
Host
:
mcp.example.com
Authorization
:
Bearer eyJhbGciOiJIUzI1NiIs...
​
Token Handling
MCP servers, acting in their role as an OAuth 2.1 resource server,
MUST
validate access tokens as described in
OAuth 2.1 Section 5.2
.
MCP servers
MUST
validate that access tokens were issued specifically for them as the intended audience,
according to
RFC 8707 Section 2
.
If validation fails, servers
MUST
respond according to
OAuth 2.1 Section 5.3
error handling requirements. Invalid or expired tokens
MUST
receive a HTTP 401
response.
MCP clients
MUST NOT
send tokens to the MCP server other than ones issued by the MCP server’s authorization server.
Authorization servers
MUST
only accept tokens that are valid for use with their
own resources.
MCP servers
MUST NOT
accept or transit any other tokens.
​
Error Handling
Servers
MUST
return appropriate HTTP status codes for authorization errors:
Status Code
Description
Usage
401
Unauthorized
Authorization required or token invalid
403
Forbidden
Invalid scopes or insufficient permissions
400
Bad Request
Malformed authorization request
​
Security Considerations
Implementations
MUST
follow OAuth 2.1 security best practices as laid out in
OAuth 2.1 Section 7. “Security Considerations”
.
​
Token Audience Binding and Validation
RFC 8707
Resource Indicators provide critical security benefits by binding tokens to their intended
audiences
when the Authorization Server supports the capability
. To enable current and future adoption:
MCP clients
MUST
include the
resource
parameter in authorization and token requests as specified in the
Resource Parameter Implementation
section
MCP servers
MUST
validate that tokens presented to them were specifically issued for their use
The
Security Best Practices document
outlines why token audience validation is crucial and why token passthrough is explicitly forbidden.
​
Token Theft
Attackers who obtain tokens stored by the client, or tokens cached or logged on the server can access protected resources with
requests that appear legitimate to resource servers.
Clients and servers
MUST
implement secure token storage and follow OAuth best practices,
as outlined in
OAuth 2.1, Section 7.1
.
Authorization servers
SHOULD
issue short-lived access tokens to reduce the impact of leaked tokens.
For public clients, authorization servers
MUST
rotate refresh tokens as described in
OAuth 2.1 Section 4.3.1 “Refresh Token Grant”
.
​
Communication Security
Implementations
MUST
follow
OAuth 2.1 Section 1.5 “Communication Security”
.
Specifically:
All authorization server endpoints
MUST
be served over HTTPS.
All redirect URIs
MUST
be either
localhost
or use HTTPS.
​
Authorization Code Protection
An attacker who has gained access to an authorization code contained in an authorization response can try to redeem the authorization code for an access token or otherwise make use of the authorization code.
(Further described in
OAuth 2.1 Section 7.5
)
To mitigate this, MCP clients
MUST
implement PKCE according to
OAuth 2.1 Section 7.5.2
.
PKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.
​
Open Redirection
An attacker may craft malicious redirect URIs to direct users to phishing sites.
MCP clients
MUST
have redirect URIs registered with the authorization server.
Authorization servers
MUST
validate exact redirect URIs against pre-registered values to prevent redirection attacks.
MCP clients
SHOULD
use and verify state parameters in the authorization code flow
and discard any results that do not include or have a mismatch with the original state.
Authorization servers
MUST
take precautions to prevent redirecting user agents to untrusted URI’s, following suggestions laid out in
OAuth 2.1 Section 7.12.2
Authorization servers
SHOULD
only automatically redirect the user agent if it trusts the redirection URI. If the URI is not trusted, the authorization server MAY inform the user and rely on the user to make the correct decision.
​
Confused Deputy Problem
Attackers can exploit MCP servers acting as intermediaries to third-party APIs, leading to
confused deputy vulnerabilities
.
By using stolen authorization codes, they can obtain access tokens without user consent.
MCP proxy servers using static client IDs
MUST
obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).
​
Access Token Privilege Restriction
An attacker can gain unauthorized access or otherwise compromise a MCP server if the server accepts tokens issued for other resources.
This vulnerability has two critical dimensions:
Audience validation failures.
When an MCP server doesn’t verify that tokens were specifically intended for it (for example, via the audience claim, as mentioned in
RFC9068
), it may accept tokens originally issued for other services. This breaks a fundamental OAuth security boundary, allowing attackers to reuse legitimate tokens across different services than intended.
Token passthrough.
If the MCP server not only accepts tokens with incorrect audiences but also forwards these unmodified tokens to downstream services, it can potentially cause the
“confused deputy” problem
, where the downstream API may incorrectly trust the token as if it came from the MCP server or assume the token was validated by the upstream API. See the
Token Passthrough section
of the Security Best Practices guide for additional details.
MCP servers
MUST
validate access tokens before processing the request, ensuring the access token is issued specifically for the MCP server, and take all necessary steps to ensure no data is returned to unauthorized parties.
A MCP server
MUST
follow the guidelines in
OAuth 2.1 - Section 5.2
to validate inbound tokens.
MCP servers
MUST
only accept tokens specifically intended for themselves and
MUST
reject tokens that do not include them in the audience claim or otherwise verify that they are the intended recipient of the token. See the
Security Best Practices Token Passthrough section
for details.
If the MCP server makes requests to upstream APIs, it may act as an OAuth client to them. The access token used at the upstream API is a seperate token, issued by the upstream authorization server. The MCP server
MUST NOT
pass through the token it received from the MCP client.
MCP clients
MUST
implement and use the
resource
parameter as defined in
RFC 8707 - Resource Indicators for OAuth 2.0
to explicitly specify the target resource for which the token is being requested. This requirement aligns with the recommendation in
RFC 9728 Section 7.4
. This ensures that access tokens are bound to their intended resources and
cannot be misused across different services.
Was this page helpful?
Yes
No
Transports
Security Best Practices
github
On this page
Introduction
Purpose and Scope
Protocol Requirements
Standards Compliance
Authorization Flow
Roles
Overview
Authorization Server Discovery
Authorization Server Location
Server Metadata Discovery
Sequence Diagram
Dynamic Client Registration
Authorization Flow Steps
Resource Parameter Implementation
Access Token Usage
Token Requirements
Token Handling
Error Handling
Security Considerations
Token Audience Binding and Validation
Token Theft
Communication Security
Authorization Code Protection
Open Redirection
Confused Deputy Problem
Access Token Privilege Restriction
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/index

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Overview
Protocol Revision
: 2025-06-18
The Model Context Protocol consists of several key components that work together:
Base Protocol
: Core JSON-RPC message types
Lifecycle Management
: Connection initialization, capability negotiation, and
session control
Authorization
: Authentication and authorization framework for HTTP-based transports
Server Features
: Resources, prompts, and tools exposed by servers
Client Features
: Sampling and root directory lists provided by clients
Utilities
: Cross-cutting concerns like logging and argument completion
All implementations
MUST
support the base protocol and lifecycle management
components. Other components
MAY
be implemented based on the specific needs of the
application.
These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.
​
Messages
All messages between MCP clients and servers
MUST
follow the
JSON-RPC 2.0
specification. The protocol defines
these types of messages:
​
Requests
Requests are sent from the client to the server or vice versa, to initiate an operation.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Requests
MUST
include a string or integer ID.
Unlike base JSON-RPC, the ID
MUST NOT
be
null
.
The request ID
MUST NOT
have been previously used by the requestor within the same
session.
​
Responses
Responses are sent in reply to requests, containing the result or error of the operation.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
result
?:
{
[key: string]:
unknown
;
}
error
?:
{
code:
number
;
message
:
string
;
data
?:
unknown
;
}
}
Responses
MUST
include the same ID as the request they correspond to.
Responses
are further sub-categorized as either
successful results
or
errors
. Either a
result
or an
error
MUST
be set. A response
MUST NOT
set both.
Results
MAY
follow any JSON object structure, while errors
MUST
include an
error code and message at minimum.
Error codes
MUST
be integers.
​
Notifications
Notifications are sent from the client to the server or vice versa, as a one-way message.
The receiver
MUST NOT
send a response.
Copy
{
jsonrpc
:
"2.0"
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Notifications
MUST NOT
include an ID.
​
Auth
MCP provides an
Authorization
framework for use with HTTP.
Implementations using an HTTP-based transport
SHOULD
conform to this specification,
whereas implementations using STDIO transport
SHOULD NOT
follow this specification,
and instead retrieve credentials from the environment.
Additionally, clients and servers
MAY
negotiate their own custom authentication and
authorization strategies.
For further discussions and contributions to the evolution of MCP’s auth mechanisms, join
us in
GitHub Discussions
to help shape the future of the protocol!
​
Schema
The full specification of the protocol is defined as a
TypeScript schema
.
This is the source of truth for all protocol messages and structures.
There is also a
JSON Schema
,
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.
​
General fields
​
_meta
The
_meta
property/parameter is reserved by MCP to allow clients and servers
to attach additional metadata to their interactions.
Certain key names are reserved by MCP for protocol-level metadata, as specified below;
implementations MUST NOT make assumptions about values at these keys.
Additionally, definitions in the
schema
may reserve particular names for purpose-specific metadata, as declared in those definitions.
Key name format:
valid
_meta
key names have two segments: an optional
prefix
, and a
name
.
Prefix:
If specified, MUST be a series of labels separated by dots (
.
), followed by a slash (
/
).
Labels MUST start with a letter and end with a letter or digit; interior characters can be letters, digits, or hyphens (
-
).
Any prefix beginning with zero or more valid labels, followed by
modelcontextprotocol
or
mcp
, followed by any valid label,
is
reserved
for MCP use.
For example:
modelcontextprotocol.io/
,
mcp.dev/
,
api.modelcontextprotocol.org/
, and
tools.mcp.com/
are all reserved.
Name:
Unless empty, MUST begin and end with an alphanumeric character (
[a-z0-9A-Z]
).
MAY contain hyphens (
-
), underscores (
_
), dots (
.
), and alphanumerics in between.
Was this page helpful?
Yes
No
Architecture
Lifecycle
github
On this page
Messages
Requests
Responses
Notifications
Auth
Schema
General fields
_meta
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/lifecycle

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Lifecycle
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Lifecycle
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.
Initialization
: Capability negotiation and protocol version agreement
Operation
: Normal protocol communication
Shutdown
: Graceful termination of the connection
​
Lifecycle Phases
​
Initialization
The initialization phase
MUST
be the first interaction between client and server.
During this phase, the client and server:
Establish protocol version compatibility
Exchange and negotiate capabilities
Share implementation details
The client
MUST
initiate this phase by sending an
initialize
request containing:
Protocol version supported
Client capabilities
Client implementation information
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"initialize"
,
"params"
: {
"protocolVersion"
:
"2024-11-05"
,
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
},
"sampling"
: {},
"elicitation"
: {}
},
"clientInfo"
: {
"name"
:
"ExampleClient"
,
"title"
:
"Example Client Display Name"
,
"version"
:
"1.0.0"
}
}
}
The server
MUST
respond with its own capabilities and information:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"protocolVersion"
:
"2024-11-05"
,
"capabilities"
: {
"logging"
: {},
"prompts"
: {
"listChanged"
:
true
},
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
},
"tools"
: {
"listChanged"
:
true
}
},
"serverInfo"
: {
"name"
:
"ExampleServer"
,
"title"
:
"Example Server Display Name"
,
"version"
:
"1.0.0"
},
"instructions"
:
"Optional instructions for the client"
}
}
After successful initialization, the client
MUST
send an
initialized
notification
to indicate it is ready to begin normal operations:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/initialized"
}
The client
SHOULD NOT
send requests other than
pings
before the server has responded to the
initialize
request.
The server
SHOULD NOT
send requests other than
pings
and
logging
before receiving the
initialized
notification.
​
Version Negotiation
In the
initialize
request, the client
MUST
send a protocol version it supports.
This
SHOULD
be the
latest
version supported by the client.
If the server supports the requested protocol version, it
MUST
respond with the same
version. Otherwise, the server
MUST
respond with another protocol version it
supports. This
SHOULD
be the
latest
version supported by the server.
If the client does not support the version in the server’s response, it
SHOULD
disconnect.
If using HTTP, the client
MUST
include the
MCP-Protocol-Version: <protocol-version>
HTTP header on all subsequent requests to the MCP
server.
For details, see
the Protocol Version Header section in Transports
.
​
Capability Negotiation
Client and server capabilities establish which optional protocol features will be
available during the session.
Key capabilities include:
Category
Capability
Description
Client
roots
Ability to provide filesystem
roots
Client
sampling
Support for LLM
sampling
requests
Client
elicitation
Support for server
elicitation
requests
Client
experimental
Describes support for non-standard experimental features
Server
prompts
Offers
prompt templates
Server
resources
Provides readable
resources
Server
tools
Exposes callable
tools
Server
logging
Emits structured
log messages
Server
completions
Supports argument
autocompletion
Server
experimental
Describes support for non-standard experimental features
Capability objects can describe sub-capabilities like:
listChanged
: Support for list change notifications (for prompts, resources, and
tools)
subscribe
: Support for subscribing to individual items’ changes (resources only)
​
Operation
During the operation phase, the client and server exchange messages according to the
negotiated capabilities.
Both parties
MUST
:
Respect the negotiated protocol version
Only use capabilities that were successfully negotiated
​
Shutdown
During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are defined—instead, the underlying transport
mechanism should be used to signal connection termination:
​
stdio
For the stdio
transport
, the client
SHOULD
initiate
shutdown by:
First, closing the input stream to the child process (the server)
Waiting for the server to exit, or sending
SIGTERM
if the server does not exit
within a reasonable time
Sending
SIGKILL
if the server does not exit within a reasonable time after
SIGTERM
The server
MAY
initiate shutdown by closing its output stream to the client and
exiting.
​
HTTP
For HTTP
transports
, shutdown is indicated by closing the
associated HTTP connection(s).
​
Timeouts
Implementations
SHOULD
establish timeouts for all sent requests, to prevent hung
connections and resource exhaustion. When the request has not received a success or error
response within the timeout period, the sender
SHOULD
issue a
cancellation
notification
for that request and stop waiting for
a response.
SDKs and other middleware
SHOULD
allow these timeouts to be configured on a
per-request basis.
Implementations
MAY
choose to reset the timeout clock when receiving a
progress
notification
corresponding to the request, as this
implies that work is actually happening. However, implementations
SHOULD
always
enforce a maximum timeout, regardless of progress notifications, to limit the impact of a
misbehaving client or server.
​
Error Handling
Implementations
SHOULD
be prepared to handle these error cases:
Protocol version mismatch
Failure to negotiate required capabilities
Request
timeouts
Example initialization error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unsupported protocol version"
,
"data"
: {
"supported"
: [
"2024-11-05"
],
"requested"
:
"1.0.0"
}
}
}
Was this page helpful?
Yes
No
Overview
Transports
github
On this page
Lifecycle Phases
Initialization
Version Negotiation
Capability Negotiation
Operation
Shutdown
stdio
HTTP
Timeouts
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/security_best_practices

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Security Best Practices
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Security Best Practices
​
Introduction
​
Purpose and Scope
This document provides security considerations for the Model Context Protocol (MCP), complementing the MCP Authorization specification. This document identifies security risks, attack vectors, and best practices specific to MCP implementations.
The primary audience for this document includes developers implementing MCP authorization flows, MCP server operators, and security professionals evaluating MCP-based systems. This document should be read alongside the MCP Authorization specification and
OAuth 2.0 security best practices
.
​
Attacks and Mitigations
This section gives a detailed description of attacks on MCP implementations, along with potential countermeasures.
​
Confused Deputy Problem
Attackers can exploit MCP servers proxying other resource servers, creating “
confused deputy
” vulnerabilities.
​
Terminology
MCP Proxy Server
: An MCP server that connects MCP clients to third-party APIs, offering MCP features while delegating operations and acting as a single OAuth client to the third-party API server.
Third-Party Authorization Server
: Authorization server that protects the third-party API. It may lack dynamic client registration support, requiring MCP proxy to use a static client ID for all requests.
Third-Party API
: The protected resource server that provides the actual API functionality. Access to this
API requires tokens issued by the third-party authorization server.
Static Client ID
: A fixed OAuth 2.0 client identifier used by the MCP proxy server when communicating with
the third-party authorization server. This Client ID refers to the MCP server acting as a client
to the Third-Party API. It is the same value for all MCP server to Third-Party API interactions regardless of
which MCP client initiated the request.
​
Architecture and Attack Flows
Normal OAuth proxy usage (preserves user consent)
Malicious OAuth proxy usage (skips user consent)
​
Attack Description
When an MCP proxy server uses a static client ID to authenticate with a third-party
authorization server that does not support dynamic client registration, the following
attack becomes possible:
A user authenticates normally through the MCP proxy server to access the third-party API
During this flow, the third-party authorization server sets a cookie on the user agent
indicating consent for the static client ID
An attacker later sends the user a malicious link containing a crafted authorization request which contains a malicious redirect URI along with a new dynamically registered client ID
When the user clicks the link, their browser still has the consent cookie from the previous legitimate request
The third-party authorization server detects the cookie and skips the consent screen
The MCP authorization code is redirected to the attacker’s server (specified in the crafted redirect_uri during dynamic client registration)
The attacker exchanges the stolen authorization code for access tokens for the MCP server without the user’s explicit approval
Attacker now has access to the third-party API as the compromised user
​
Mitigation
MCP proxy servers using static client IDs
MUST
obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).
​
Token Passthrough
“Token passthrough” is an anti-pattern where an MCP server accepts tokens from an MCP client without validating that the tokens were properly issued
to the MCP server
and “passing them through” to the downstream API.
​
Risks
Token passthrough is explicitly forbidden in the
authorization specification
as it introduces a number of security risks, that include:
Security Control Circumvention
The MCP Server or downstream APIs might implement important security controls like rate limiting, request validation, or traffic monitoring, that depend on the token audience or other credential constraints. If clients can obtain and use tokens directly with the downstream APIs without the MCP server validating them properly or ensuring that the tokens are issued for the right service, they bypass these controls.
Accountability and Audit Trail Issues
The MCP Server will be unable to identify or distinguish between MCP Clients when clients are calling with an upstream-issued access token which may be opaque to the MCP Server.
The downstream Resource Server’s logs may show requests that appear to come from a different source with a different identity, rather than the MCP server that is actually forwarding the tokens.
Both factors make incident investigation, controls, and auditing more difficult.
If the MCP Server passes tokens without validating their claims (e.g., roles, privileges, or audience) or other metadata, a malicious actor in possession of a stolen token can use the server as a proxy for data exfiltration.
Trust Boundary Issues
The downstream Resource Server grants trust to specific entities. This trust might include assumptions about origin or client behavior patterns. Breaking this trust boundary could lead to unexpected issues.
If the token is accepted by multiple services without proper validation, an attacker compromising one service can use the token to access other connected services.
Future Compatibility Risk
Even if an MCP Server starts as a “pure proxy” today, it might need to add security controls later. Starting with proper token audience separation makes it easier to evolve the security model.
​
Mitigation
MCP servers
MUST NOT
accept any tokens that were not explicitly issued for the MCP server.
​
Session Hijacking
Session hijacking is an attack vector where a client is provided a session ID by the server, and an unauthorized party is able to obtain and use that same session ID to impersonate the original client and perform unauthorized actions on their behalf.
​
Session Hijack Prompt Injection
​
Session Hijack Impersonation
​
Attack Description
When you have multiple stateful HTTP servers that handle MCP requests, the following attack vectors are possible:
Session Hijack Prompt Injection
The client connects to
Server A
and receives a session ID.
The attacker obtains an existing session ID and sends a malicious event to
Server B
with said session ID.
When a server supports
redelivery/resumable streams
, deliberately terminating the request before receiving the response could lead to it being resumed by the original client via the GET request for server sent events.
If a particular server initiates server sent events as a consequence of a tool call such as a
notifications/tools/list_changed
, where it is possible to affect the tools that are offered by the server, a client could end up with tools that they were not aware were enabled.
Server B
enqueues the event (associated with session ID) into a shared queue.
Server A
polls the queue for events using the session ID and retrieves the malicious payload.
Server A
sends the malicious payload to the client as an asynchronous or resumed response.
The client receives and acts on the malicious payload, leading to potential compromise.
Session Hijack Impersonation
The MCP client authenticates with the MCP server, creating a persistent session ID.
The attacker obtains the session ID.
The attacker makes calls to the MCP server using the session ID.
MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.
​
Mitigation
To prevent session hijacking and event injection attacks, the following mitigations should be implemented:
MCP servers that implement authorization
MUST
verify all inbound requests.
MCP Servers
MUST NOT
use sessions for authentication.
MCP servers
MUST
use secure, non-deterministic session IDs.
Generated session IDs (e.g., UUIDs)
SHOULD
use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.
MCP servers
SHOULD
bind session IDs to user-specific information.
When storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like
<user_id>:<session_id>
. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.
MCP servers can optionally leverage additional unique identifiers.
Was this page helpful?
Yes
No
Authorization
Cancellation
github
On this page
Introduction
Purpose and Scope
Attacks and Mitigations
Confused Deputy Problem
Terminology
Architecture and Attack Flows
Attack Description
Mitigation
Token Passthrough
Risks
Mitigation
Session Hijacking
Session Hijack Prompt Injection
Session Hijack Impersonation
Attack Description
Mitigation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/transports

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Transports
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Transports
Protocol Revision
: 2025-06-18
MCP uses JSON-RPC to encode messages. JSON-RPC messages
MUST
be UTF-8 encoded.
The protocol currently defines two standard transport mechanisms for client-server
communication:
stdio
, communication over standard in and standard out
Streamable HTTP
Clients
SHOULD
support stdio whenever possible.
It is also possible for clients and servers to implement
custom transports
in a pluggable fashion.
​
stdio
In the
stdio
transport:
The client launches the MCP server as a subprocess.
The server reads JSON-RPC messages from its standard input (
stdin
) and sends messages
to its standard output (
stdout
).
Messages are individual JSON-RPC requests, notifications, or responses.
Messages are delimited by newlines, and
MUST NOT
contain embedded newlines.
The server
MAY
write UTF-8 strings to its standard error (
stderr
) for logging
purposes. Clients
MAY
capture, forward, or ignore this logging.
The server
MUST NOT
write anything to its
stdout
that is not a valid MCP message.
The client
MUST NOT
write anything to the server’s
stdin
that is not a valid MCP
message.
​
Streamable HTTP
This replaces the
HTTP+SSE
transport
from
protocol version 2024-11-05. See the
backwards compatibility
guide below.
In the
Streamable HTTP
transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
Server-Sent Events
(SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.
The server
MUST
provide a single HTTP endpoint path (hereafter referred to as the
MCP endpoint
) that supports both POST and GET methods. For example, this could be a
URL like
https://example.com/mcp
.
​
Security Warning
When implementing Streamable HTTP transport:
Servers
MUST
validate the
Origin
header on all incoming connections to prevent DNS rebinding attacks
When running locally, servers
SHOULD
bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
Servers
SHOULD
implement proper authentication for all connections
Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.
​
Sending Messages to the Server
Every JSON-RPC message sent from the client
MUST
be a new HTTP POST request to the
MCP endpoint.
The client
MUST
use HTTP POST to send JSON-RPC messages to the MCP endpoint.
The client
MUST
include an
Accept
header, listing both
application/json
and
text/event-stream
as supported content types.
The body of the POST request
MUST
be a single JSON-RPC
request
,
notification
, or
response
.
If the input is a JSON-RPC
response
or
notification
:
If the server accepts the input, the server
MUST
return HTTP status code 202
Accepted with no body.
If the server cannot accept the input, it
MUST
return an HTTP error status code
(e.g., 400 Bad Request). The HTTP response body
MAY
comprise a JSON-RPC
error
response
that has no
id
.
If the input is a JSON-RPC
request
, the server
MUST
either
return
Content-Type: text/event-stream
, to initiate an SSE stream, or
Content-Type: application/json
, to return one JSON object. The client
MUST
support both these cases.
If the server initiates an SSE stream:
The SSE stream
SHOULD
eventually include JSON-RPC
response
for the
JSON-RPC
request
sent in the POST body.
The server
MAY
send JSON-RPC
requests
and
notifications
before sending the
JSON-RPC
response
. These messages
SHOULD
relate to the originating client
request
.
The server
SHOULD NOT
close the SSE stream before sending the JSON-RPC
response
for the received JSON-RPC
request
, unless the
session
expires.
After the JSON-RPC
response
has been sent, the server
SHOULD
close the SSE
stream.
Disconnection
MAY
occur at any time (e.g., due to network conditions).
Therefore:
Disconnection
SHOULD NOT
be interpreted as the client cancelling its request.
To cancel, the client
SHOULD
explicitly send an MCP
CancelledNotification
.
To avoid message loss due to disconnection, the server
MAY
make the stream
resumable
.
​
Listening for Messages from the Server
The client
MAY
issue an HTTP GET to the MCP endpoint. This can be used to open an
SSE stream, allowing the server to communicate to the client, without the client first
sending data via HTTP POST.
The client
MUST
include an
Accept
header, listing
text/event-stream
as a
supported content type.
The server
MUST
either return
Content-Type: text/event-stream
in response to
this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
does not offer an SSE stream at this endpoint.
If the server initiates an SSE stream:
The server
MAY
send JSON-RPC
requests
and
notifications
on the stream.
These messages
SHOULD
be unrelated to any concurrently-running JSON-RPC
request
from the client.
The server
MUST NOT
send a JSON-RPC
response
on the stream
unless
resuming
a stream associated with a previous client
request.
The server
MAY
close the SSE stream at any time.
The client
MAY
close the SSE stream at any time.
​
Multiple Connections
The client
MAY
remain connected to multiple SSE streams simultaneously.
The server
MUST
send each of its JSON-RPC messages on only one of the connected
streams; that is, it
MUST NOT
broadcast the same message across multiple streams.
The risk of message loss
MAY
be mitigated by making the stream
resumable
.
​
Resumability and Redelivery
To support resuming broken connections, and redelivering messages that might otherwise be
lost:
Servers
MAY
attach an
id
field to their SSE events, as described in the
SSE standard
.
If present, the ID
MUST
be globally unique across all streams within that
session
—or all streams with that specific client, if session
management is not in use.
If the client wishes to resume after a broken connection, it
SHOULD
issue an HTTP
GET to the MCP endpoint, and include the
Last-Event-ID
header to indicate the last event ID it received.
The server
MAY
use this header to replay messages that would have been sent
after the last event ID,
on the stream that was disconnected
, and to resume the
stream from that point.
The server
MUST NOT
replay messages that would have been delivered on a
different stream.
In other words, these event IDs should be assigned by servers on a
per-stream
basis, to
act as a cursor within that particular stream.
​
Session Management
An MCP “session” consists of logically related interactions between a client and a
server, beginning with the
initialization phase
. To support
servers which want to establish stateful sessions:
A server using the Streamable HTTP transport
MAY
assign a session ID at
initialization time, by including it in an
Mcp-Session-Id
header on the HTTP
response containing the
InitializeResult
.
The session ID
SHOULD
be globally unique and cryptographically secure (e.g., a
securely generated UUID, a JWT, or a cryptographic hash).
The session ID
MUST
only contain visible ASCII characters (ranging from 0x21 to
0x7E).
If an
Mcp-Session-Id
is returned by the server during initialization, clients using
the Streamable HTTP transport
MUST
include it in the
Mcp-Session-Id
header on
all of their subsequent HTTP requests.
Servers that require a session ID
SHOULD
respond to requests without an
Mcp-Session-Id
header (other than initialization) with HTTP 400 Bad Request.
The server
MAY
terminate the session at any time, after which it
MUST
respond
to requests containing that session ID with HTTP 404 Not Found.
When a client receives HTTP 404 in response to a request containing an
Mcp-Session-Id
, it
MUST
start a new session by sending a new
InitializeRequest
without a session ID attached.
Clients that no longer need a particular session (e.g., because the user is leaving
the client application)
SHOULD
send an HTTP DELETE to the MCP endpoint with the
Mcp-Session-Id
header, to explicitly terminate the session.
The server
MAY
respond to this request with HTTP 405 Method Not Allowed,
indicating that the server does not allow clients to terminate sessions.
​
Sequence Diagram
​
Protocol Version Header
If using HTTP, the client
MUST
include the
MCP-Protocol-Version: <protocol-version>
HTTP header on all subsequent requests to the MCP
server, allowing the MCP server to respond based on the MCP protocol version.
For example:
MCP-Protocol-Version: 2025-06-18
The protocol version sent by the client
SHOULD
be the one
negotiated during
initialization
.
For backwards compatibility, if the server does
not
receive an
MCP-Protocol-Version
header, and has no other way to identify the version - for example, by relying on the
protocol version negotiated during initialization - the server
SHOULD
assume protocol
version
2025-03-26
.
If the server receives a request with an invalid or unsupported
MCP-Protocol-Version
, it
MUST
respond with
400 Bad Request
.
​
Backwards Compatibility
Clients and servers can maintain backwards compatibility with the deprecated
HTTP+SSE
transport
(from
protocol version 2024-11-05) as follows:
Servers
wanting to support older clients should:
Continue to host both the SSE and POST endpoints of the old transport, alongside the
new “MCP endpoint” defined for the Streamable HTTP transport.
It is also possible to combine the old POST endpoint and the new MCP endpoint, but
this may introduce unneeded complexity.
Clients
wanting to support older servers should:
Accept an MCP server URL from the user, which may point to either a server using the
old transport or the new transport.
Attempt to POST an
InitializeRequest
to the server URL, with an
Accept
header as
defined above:
If it succeeds, the client can assume this is a server supporting the new Streamable
HTTP transport.
If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
Found):
Issue a GET request to the server URL, expecting that this will open an SSE stream
and return an
endpoint
event as the first event.
When the
endpoint
event arrives, the client can assume this is a server running
the old HTTP+SSE transport, and should use that transport for all subsequent
communication.
​
Custom Transports
Clients and servers
MAY
implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.
Implementers who choose to support custom transports
MUST
ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
SHOULD
document their specific connection establishment and message exchange patterns
to aid interoperability.
Was this page helpful?
Yes
No
Lifecycle
Authorization
github
On this page
stdio
Streamable HTTP
Security Warning
Sending Messages to the Server
Listening for Messages from the Server
Multiple Connections
Resumability and Redelivery
Session Management
Sequence Diagram
Protocol Version Header
Backwards Compatibility
Custom Transports
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/cancellation

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Cancellation
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Cancellation
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.
​
Cancellation Flow
When a party wants to cancel an in-progress request, it sends a
notifications/cancelled
notification containing:
The ID of the request to cancel
An optional reason string that can be logged or displayed
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/cancelled"
,
"params"
: {
"requestId"
:
"123"
,
"reason"
:
"User requested cancellation"
}
}
​
Behavior Requirements
Cancellation notifications
MUST
only reference requests that:
Were previously issued in the same direction
Are believed to still be in-progress
The
initialize
request
MUST NOT
be cancelled by clients
Receivers of cancellation notifications
SHOULD
:
Stop processing the cancelled request
Free associated resources
Not send a response for the cancelled request
Receivers
MAY
ignore cancellation notifications if:
The referenced request is unknown
Processing has already completed
The request cannot be cancelled
The sender of the cancellation notification
SHOULD
ignore any response to the
request that arrives afterward
​
Timing Considerations
Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.
Both parties
MUST
handle these race conditions gracefully:
​
Implementation Notes
Both parties
SHOULD
log cancellation reasons for debugging
Application UIs
SHOULD
indicate when cancellation is requested
​
Error Handling
Invalid cancellation notifications
SHOULD
be ignored:
Unknown request IDs
Already completed requests
Malformed notifications
This maintains the “fire and forget” nature of notifications while allowing for race
conditions in asynchronous communication.
Was this page helpful?
Yes
No
Security Best Practices
Ping
github
On this page
Cancellation Flow
Behavior Requirements
Timing Considerations
Implementation Notes
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/ping

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Ping
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Ping
Protocol Revision
: 2025-06-18
The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.
​
Overview
The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a
ping
request.
​
Message Format
A ping request is a standard JSON-RPC request with no parameters:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"method"
:
"ping"
}
​
Behavior Requirements
The receiver
MUST
respond promptly with an empty response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {}
}
If no response is received within a reasonable timeout period, the sender
MAY
:
Consider the connection stale
Terminate the connection
Attempt reconnection procedures
​
Usage Patterns
​
Implementation Considerations
Implementations
SHOULD
periodically issue pings to detect connection health
The frequency of pings
SHOULD
be configurable
Timeouts
SHOULD
be appropriate for the network environment
Excessive pinging
SHOULD
be avoided to reduce network overhead
​
Error Handling
Timeouts
SHOULD
be treated as connection failures
Multiple failed pings
MAY
trigger connection reset
Implementations
SHOULD
log ping failures for diagnostics
Was this page helpful?
Yes
No
Cancellation
Progress
github
On this page
Overview
Message Format
Behavior Requirements
Usage Patterns
Implementation Considerations
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/basic/utilities/progress

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Progress
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Progress
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.
​
Progress Flow
When a party wants to
receive
progress updates for a request, it includes a
progressToken
in the request metadata.
Progress tokens
MUST
be a string or integer value
Progress tokens can be chosen by the sender using any means, but
MUST
be unique
across all active requests.
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"some_method"
,
"params"
: {
"_meta"
: {
"progressToken"
:
"abc123"
}
}
}
The receiver
MAY
then send progress notifications containing:
The original progress token
The current progress value so far
An optional “total” value
An optional “message” value
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/progress"
,
"params"
: {
"progressToken"
:
"abc123"
,
"progress"
:
50
,
"total"
:
100
,
"message"
:
"Reticulating splines..."
}
}
The
progress
value
MUST
increase with each notification, even if the total is
unknown.
The
progress
and the
total
values
MAY
be floating point.
The
message
field
SHOULD
provide relevant human readable progress information.
​
Behavior Requirements
Progress notifications
MUST
only reference tokens that:
Were provided in an active request
Are associated with an in-progress operation
Receivers of progress requests
MAY
:
Choose not to send any progress notifications
Send notifications at whatever frequency they deem appropriate
Omit the total value if unknown
​
Implementation Notes
Senders and receivers
SHOULD
track active progress tokens
Both parties
SHOULD
implement rate limiting to prevent flooding
Progress notifications
MUST
stop after completion
Was this page helpful?
Yes
No
Ping
Roots
github
On this page
Progress Flow
Behavior Requirements
Implementation Notes
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/changelog

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Key Changes
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Key Changes
This document lists changes made to the Model Context Protocol (MCP) specification since
the previous revision,
2025-03-26
.
​
Major changes
Remove support for JSON-RPC
batching
(PR
#416
)
Add support for
structured tool output
(PR
#371
)
Classify MCP servers as
OAuth Resource Servers
,
adding protected resource metadata to discover the corresponding Authorization server.
(PR
#338
)
Require MCP clients to implement Resource Indicators as described in
RFC 8707
to prevent
malicious servers from obtaining access tokens.
(PR
#734
)
Clarify
security considerations
and best practices
in the authorization spec and in a new
security best practices page
.
Add support for
elicitation
, enabling servers to request additional
information from users during interactions.
(PR
#382
)
Add support for
resource links
in
tool call results. (PR
#603
)
Require
negotiated protocol version to be specified
via
MCP-Protocol-Version
header in subsequent requests when using HTTP (PR
#548
).
Change
SHOULD
to
MUST
in
Lifecycle Operation
​
Other schema changes
Add
_meta
field to additional interface types (PR
#710
),
and specify
proper usage
.
Add
context
field to
CompletionRequest
, providing for completion requests to include
previously-resolved variables (PR
#598
).
Add
title
field for human-friendly display names, so that
name
can be used as a programmatic
identifier (PR
#663
)
​
Full changelog
For a complete list of all changes that have been made since the last protocol revision,
see GitHub
.
Was this page helpful?
Yes
No
Specification
Architecture
github
On this page
Major changes
Other schema changes
Full changelog
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/client/elicitation

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Elicitation
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Elicitation
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Elicitation
Protocol Revision
: 2025-06-18
Elicitation is newly introduced in this version of the MCP specification and its design may evolve in future protocol versions.
The Model Context Protocol (MCP) provides a standardized way for servers to request additional
information from users through the client during interactions. This flow allows clients to
maintain control over user interactions and data sharing while enabling servers to gather
necessary information dynamically.
Servers request structured data from users with JSON schemas to validate responses.
​
User Interaction Model
Elicitation in MCP allows servers to implement interactive workflows by enabling user input
requests to occur
nested
inside other MCP server features.
Implementations are free to expose elicitation through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
For trust & safety and security:
Servers
MUST NOT
use elicitation to request sensitive information.
Applications
SHOULD
:
Provide UI that makes it clear which server is requesting information
Allow users to review and modify their responses before sending
Respect user privacy and provide clear reject and cancel options
​
Capabilities
Clients that support elicitation
MUST
declare the
elicitation
capability during
initialization
:
Copy
{
"capabilities"
: {
"elicitation"
: {}
}
}
​
Protocol Messages
​
Creating Elicitation Requests
To request information from a user, servers send an
elicitation/create
request:
​
Simple Text Request
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"elicitation/create"
,
"params"
: {
"message"
:
"Please provide your GitHub username"
,
"requestedSchema"
: {
"type"
:
"object"
,
"properties"
: {
"name"
: {
"type"
:
"string"
}
},
"required"
: [
"name"
]
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"action"
:
"accept"
,
"content"
: {
"name"
:
"octocat"
}
}
}
​
Structured Data Request
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"elicitation/create"
,
"params"
: {
"message"
:
"Please provide your contact information"
,
"requestedSchema"
: {
"type"
:
"object"
,
"properties"
: {
"name"
: {
"type"
:
"string"
,
"description"
:
"Your full name"
},
"email"
: {
"type"
:
"string"
,
"format"
:
"email"
,
"description"
:
"Your email address"
},
"age"
: {
"type"
:
"number"
,
"minimum"
:
18
,
"description"
:
"Your age"
}
},
"required"
: [
"name"
,
"email"
]
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"action"
:
"accept"
,
"content"
: {
"name"
:
"Monalisa Octocat"
,
"email"
:
"
[email protected]
"
,
"age"
:
30
}
}
}
Reject Response Example:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"action"
:
"reject"
}
}
Cancel Response Example:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"action"
:
"cancel"
}
}
​
Message Flow
​
Request Schema
The
requestedSchema
field allows servers to define the structure of the expected response using a restricted subset of JSON Schema. To simplify implementation for clients, elicitation schemas are limited to flat objects with primitive properties only:
Copy
"requestedSchema"
: {
"type"
:
"object"
,
"properties"
: {
"propertyName"
: {
"type"
:
"string"
,
"title"
:
"Display Name"
,
"description"
:
"Description of the property"
},
"anotherProperty"
: {
"type"
:
"number"
,
"minimum"
:
0
,
"maximum"
:
100
}
},
"required"
: [
"propertyName"
]
}
​
Supported Schema Types
The schema is restricted to these primitive types:
String Schema
Copy
{
"type"
:
"string"
,
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"minLength"
:
3
,
"maxLength"
:
50
,
"format"
:
"email"
// Supported: "email", "uri", "date", "date-time"
}
Supported formats:
email
,
uri
,
date
,
date-time
Number Schema
Copy
{
"type"
:
"number"
,
// or "integer"
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"minimum"
:
0
,
"maximum"
:
100
}
Boolean Schema
Copy
{
"type"
:
"boolean"
,
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"default"
:
false
}
Enum Schema
Copy
{
"type"
:
"string"
,
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"enum"
: [
"option1"
,
"option2"
,
"option3"
],
"enumNames"
: [
"Option 1"
,
"Option 2"
,
"Option 3"
]
}
Clients can use this schema to:
Generate appropriate input forms
Validate user input before sending
Provide better guidance to users
Note that complex nested structures, arrays of objects, and other advanced JSON Schema features are intentionally not supported to simplify client implementation.
​
Response Actions
Elicitation responses use a three-action model to clearly distinguish between different user actions:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"action"
:
"accept"
,
// or "reject" or "cancel"
"content"
: {
"propertyName"
:
"value"
,
"anotherProperty"
:
42
}
}
}
The three response actions are:
Accept
(
action: "accept"
): User explicitly approved and submitted with data
The
content
field contains the submitted data matching the requested schema
Example: User clicked “Submit”, “OK”, “Confirm”, etc.
Reject
(
action: "reject"
): User explicitly rejected the request
The
content
field is typically omitted
Example: User clicked “Reject”, “Decline”, “No”, etc.
Cancel
(
action: "cancel"
): User dismissed without making an explicit choice
The
content
field is typically omitted
Example: User closed the dialog, clicked outside, pressed Escape, etc.
Servers should handle each state appropriately:
Accept
: Process the submitted data
Reject
: Handle explicit rejection (e.g., offer alternatives)
Cancel
: Handle dismissal (e.g., prompt again later)
​
Security Considerations
Servers
MUST NOT
request sensitive information through elicitation
Clients
SHOULD
implement user approval controls
Both parties
SHOULD
validate elicitation content against the provided schema
Clients
SHOULD
provide clear indication of which server is requesting information
Clients
SHOULD
allow users to reject elicitation requests at any time
Clients
SHOULD
implement rate limiting
Clients
SHOULD
present elicitation requests in a way that makes it clear what information is being requested and why
Was this page helpful?
Yes
No
Sampling
Overview
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Creating Elicitation Requests
Simple Text Request
Structured Data Request
Message Flow
Request Schema
Supported Schema Types
Response Actions
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/client/roots

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Roots
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Elicitation
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Roots
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem “roots” to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.
​
User Interaction Model
Roots in MCP are typically exposed through workspace or project configuration interfaces.
For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.
However, implementations are free to expose roots through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Clients that support roots
MUST
declare the
roots
capability during
initialization
:
Copy
{
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the client will emit notifications when the list of roots
changes.
​
Protocol Messages
​
Listing Roots
To retrieve roots, servers send a
roots/list
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"roots/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"roots"
: [
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
]
}
}
​
Root List Changes
When roots change, clients that support
listChanged
MUST
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/roots/list_changed"
}
​
Message Flow
​
Data Types
​
Root
A root definition includes:
uri
: Unique identifier for the root. This
MUST
be a
file://
URI in the current
specification.
name
: Optional human-readable name for display purposes.
Example roots for different use cases:
​
Project Directory
Copy
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
​
Multiple Repositories
Copy
[
{
"uri"
:
"file:///home/user/repos/frontend"
,
"name"
:
"Frontend Repository"
},
{
"uri"
:
"file:///home/user/repos/backend"
,
"name"
:
"Backend Repository"
}
]
​
Error Handling
Clients
SHOULD
return standard JSON-RPC errors for common failure cases:
Client does not support roots:
-32601
(Method not found)
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32601
,
"message"
:
"Roots not supported"
,
"data"
: {
"reason"
:
"Client does not have roots capability"
}
}
}
​
Security Considerations
Clients
MUST
:
Only expose roots with appropriate permissions
Validate all root URIs to prevent path traversal
Implement proper access controls
Monitor root accessibility
Servers
SHOULD
:
Handle cases where roots become unavailable
Respect root boundaries during operations
Validate all paths against provided roots
​
Implementation Guidelines
Clients
SHOULD
:
Prompt users for consent before exposing roots to servers
Provide clear user interfaces for root management
Validate root accessibility before exposing
Monitor for root changes
Servers
SHOULD
:
Check for roots capability before usage
Handle root list changes gracefully
Respect root boundaries in operations
Cache root information appropriately
Was this page helpful?
Yes
No
Progress
Sampling
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Roots
Root List Changes
Message Flow
Data Types
Root
Project Directory
Multiple Repositories
Error Handling
Security Considerations
Implementation Guidelines
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/client/sampling

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Sampling
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Elicitation
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Sampling
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling (“completions” or “generations”) from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities—with no server API keys necessary.
Servers can request text, audio, or image-based interactions and optionally include
context from MCP servers in their prompts.
​
User Interaction Model
Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur
nested
inside other MCP server features.
Implementations are free to expose sampling through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny sampling requests.
Applications
SHOULD
:
Provide UI that makes it easy and intuitive to review sampling requests
Allow users to view and edit prompts before sending
Present generated responses for review before delivery
​
Capabilities
Clients that support sampling
MUST
declare the
sampling
capability during
initialization
:
Copy
{
"capabilities"
: {
"sampling"
: {}
}
}
​
Protocol Messages
​
Creating Messages
To request a language model generation, servers send a
sampling/createMessage
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"sampling/createMessage"
,
"params"
: {
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"What is the capital of France?"
}
}
],
"modelPreferences"
: {
"hints"
: [
{
"name"
:
"claude-3-sonnet"
}
],
"intelligencePriority"
:
0.8
,
"speedPriority"
:
0.5
},
"systemPrompt"
:
"You are a helpful assistant."
,
"maxTokens"
:
100
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"role"
:
"assistant"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"The capital of France is Paris."
},
"model"
:
"claude-3-sonnet-20240307"
,
"stopReason"
:
"endTurn"
}
}
​
Message Flow
​
Data Types
​
Messages
Sampling messages can contain:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"The message content"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/jpeg"
}
​
Audio Content
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
​
Model Preferences
Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider’s equivalent model.
To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:
​
Capability Priorities
Servers express their needs through three normalized priority values (0-1):
costPriority
: How important is minimizing costs? Higher values prefer cheaper models.
speedPriority
: How important is low latency? Higher values prefer faster models.
intelligencePriority
: How important are advanced capabilities? Higher values prefer
more capable models.
​
Model Hints
While priorities help select models based on characteristics,
hints
allow servers to
suggest specific models or model families:
Hints are treated as substrings that can match model names flexibly
Multiple hints are evaluated in order of preference
Clients
MAY
map hints to equivalent models from different providers
Hints are advisory—clients make final model selection
For example:
Copy
{
"hints"
: [
{
"name"
:
"claude-3-sonnet"
},
// Prefer Sonnet-class models
{
"name"
:
"claude"
}
// Fall back to any Claude model
],
"costPriority"
:
0.3
,
// Cost is less important
"speedPriority"
:
0.8
,
// Speed is very important
"intelligencePriority"
:
0.5
// Moderate capability needs
}
The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn’t have access to Claude models but has Gemini,
it might map the sonnet hint to
gemini-1.5-pro
based on similar capabilities.
​
Error Handling
Clients
SHOULD
return errors for common failure cases:
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-1
,
"message"
:
"User rejected sampling request"
}
}
​
Security Considerations
Clients
SHOULD
implement user approval controls
Both parties
SHOULD
validate message content
Clients
SHOULD
respect model preference hints
Clients
SHOULD
implement rate limiting
Both parties
MUST
handle sensitive data appropriately
Was this page helpful?
Yes
No
Roots
Elicitation
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Creating Messages
Message Flow
Data Types
Messages
Text Content
Image Content
Audio Content
Model Preferences
Capability Priorities
Model Hints
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/index

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Specification
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Specification
Model Context Protocol
(MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.
This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
schema.ts
.
For implementation guides and examples, visit
modelcontextprotocol.io
.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD
NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in
BCP 14
[
RFC2119
]
[
RFC8174
] when, and only when, they
appear in all capitals, as shown here.
​
Overview
MCP provides a standardized way for applications to:
Share contextual information with language models
Expose tools and capabilities to AI systems
Build composable integrations and workflows
The protocol uses
JSON-RPC
2.0 messages to establish
communication between:
Hosts
: LLM applications that initiate connections
Clients
: Connectors within the host application
Servers
: Services that provide context and capabilities
MCP takes some inspiration from the
Language Server Protocol
, which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.
​
Key Details
​
Base Protocol
JSON-RPC
message format
Stateful connections
Server and client capability negotiation
​
Features
Servers offer any of the following features to clients:
Resources
: Context and data, for the user or the AI model to use
Prompts
: Templated messages and workflows for users
Tools
: Functions for the AI model to execute
Clients may offer the following features to servers:
Sampling
: Server-initiated agentic behaviors and recursive LLM interactions
Roots
: Server-initiated inquiries into uri or filesystem boundaries to operate in
Elicitation
: Server-initiated requests for additional information from users
​
Additional Utilities
Configuration
Progress tracking
Cancellation
Error reporting
Logging
​
Security and Trust & Safety
The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.
​
Key Principles
User Consent and Control
Users must explicitly consent to and understand all data access and operations
Users must retain control over what data is shared and what actions are taken
Implementors should provide clear UIs for reviewing and authorizing activities
Data Privacy
Hosts must obtain explicit user consent before exposing user data to servers
Hosts must not transmit resource data elsewhere without user consent
User data should be protected with appropriate access controls
Tool Safety
Tools represent arbitrary code execution and must be treated with appropriate
caution.
In particular, descriptions of tool behavior such as annotations should be
considered untrusted, unless obtained from a trusted server.
Hosts must obtain explicit user consent before invoking any tool
Users should understand what each tool does before authorizing its use
LLM Sampling Controls
Users must explicitly approve any LLM sampling requests
Users should control:
Whether sampling occurs at all
The actual prompt that will be sent
What results the server can see
The protocol intentionally limits server visibility into prompts
​
Implementation Guidelines
While MCP itself cannot enforce these security principles at the protocol level,
implementors
SHOULD
:
Build robust consent and authorization flows into their applications
Provide clear documentation of security implications
Implement appropriate access controls and data protections
Follow security best practices in their integrations
Consider privacy implications in their feature designs
​
Learn More
Explore the detailed specification for each protocol component:
Architecture
Base Protocol
Server Features
Client Features
Contributing
Was this page helpful?
Yes
No
FAQs
Key Changes
github
On this page
Overview
Key Details
Base Protocol
Features
Additional Utilities
Security and Trust & Safety
Key Principles
Implementation Guidelines
Learn More
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/index

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Overview
Protocol Revision
: 2025-06-18
Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:
Prompts
: Pre-defined templates or instructions that guide language model
interactions
Resources
: Structured data or content that provides additional context to the model
Tools
: Executable functions that allow models to perform actions or retrieve
information
Each primitive can be summarized in the following control hierarchy:
Primitive
Control
Description
Example
Prompts
User-controlled
Interactive templates invoked by user choice
Slash commands, menu options
Resources
Application-controlled
Contextual data attached and managed by the client
File contents, git history
Tools
Model-controlled
Functions exposed to the LLM to take actions
API POST requests, file writing
Explore these key primitives in more detail below:
Prompts
Resources
Tools
Was this page helpful?
Yes
No
Elicitation
Prompts
github
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/prompts

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Prompts
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Prompts
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.
​
User Interaction Model
Prompts are designed to be
user-controlled
, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.
Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.
For example, as slash commands:
However, implementors are free to expose prompts through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
​
Capabilities
Servers that support prompts
MUST
declare the
prompts
capability during
initialization
:
Copy
{
"capabilities"
: {
"prompts"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available prompts changes.
​
Protocol Messages
​
Listing Prompts
To retrieve available prompts, clients send a
prompts/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"prompts/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"prompts"
: [
{
"name"
:
"code_review"
,
"title"
:
"Request Code Review"
,
"description"
:
"Asks the LLM to analyze code quality and suggest improvements"
,
"arguments"
: [
{
"name"
:
"code"
,
"description"
:
"The code to review"
,
"required"
:
true
}
]
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Getting a Prompt
To retrieve a specific prompt, clients send a
prompts/get
request. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"prompts/get"
,
"params"
: {
"name"
:
"code_review"
,
"arguments"
: {
"code"
:
"def hello():
\n
print('world')"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"description"
:
"Code review prompt"
,
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"Please review this Python code:
\n
def hello():
\n
print('world')"
}
}
]
}
}
​
List Changed Notification
When the list of available prompts changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/prompts/list_changed"
}
​
Message Flow
​
Data Types
​
Prompt
A prompt definition includes:
name
: Unique identifier for the prompt
title
: Optional human-readable name of the prompt for display purposes.
description
: Optional human-readable description
arguments
: Optional list of arguments for customization
​
PromptMessage
Messages in a prompt can contain:
role
: Either “user” or “assistant” to indicate the speaker
content
: One of the following content types:
​
Text Content
Text content represents plain text messages:
Copy
{
"type"
:
"text"
,
"text"
:
"The text content of the message"
}
This is the most common content type used for natural language interactions.
​
Image Content
Image content allows including visual information in messages:
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/png"
}
The image data
MUST
be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.
​
Audio Content
Audio content allows including audio information in messages:
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
The audio data MUST be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where audio context is important.
​
Embedded Resources
Embedded resources allow referencing server-side resources directly in messages:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"resource://example"
,
"name"
:
"example"
,
"title"
:
"My Example Resource"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
}
Resources can contain either text or binary (blob) data and
MUST
include:
A valid resource URI
The appropriate MIME type
Either text content or base64-encoded blob data
Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
validate prompt arguments before processing
Clients
SHOULD
handle pagination for large prompt lists
Both parties
SHOULD
respect capability negotiation
​
Security
Implementations
MUST
carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.
Was this page helpful?
Yes
No
Overview
Resources
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Prompts
Getting a Prompt
List Changed Notification
Message Flow
Data Types
Prompt
PromptMessage
Text Content
Image Content
Audio Content
Embedded Resources
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/resources

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Resources
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Resources
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
URI
.
​
User Interaction Model
Resources in MCP are designed to be
application-driven
, with host applications
determining how to incorporate context based on their needs.
For example, applications could:
Expose resources through UI elements for explicit selection, in a tree or list view
Allow the user to search through and filter available resources
Implement automatic context inclusion, based on heuristics or the AI model’s selection
However, implementations are free to expose resources through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support resources
MUST
declare the
resources
capability:
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
}
}
}
The capability supports two optional features:
subscribe
: whether the client can subscribe to be notified of changes to individual
resources.
listChanged
: whether the server will emit notifications when the list of available
resources changes.
Both
subscribe
and
listChanged
are optional—servers can support neither,
either, or both:
Copy
{
"capabilities"
: {
"resources"
: {}
// Neither feature supported
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
// Only subscriptions supported
}
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"listChanged"
:
true
// Only list change notifications supported
}
}
}
​
Protocol Messages
​
Listing Resources
To discover available resources, clients send a
resources/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"resources"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"title"
:
"Rust Software Application Main File"
,
"description"
:
"Primary application entry point"
,
"mimeType"
:
"text/x-rust"
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Reading Resources
To retrieve resource contents, clients send a
resources/read
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"resources/read"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"contents"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"title"
:
"Rust Software Application Main File"
,
"mimeType"
:
"text/x-rust"
,
"text"
:
"fn main() {
\n
println!(
\"
Hello world!
\"
);
\n
}"
}
]
}
}
​
Resource Templates
Resource templates allow servers to expose parameterized resources using
URI templates
. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"method"
:
"resources/templates/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"result"
: {
"resourceTemplates"
: [
{
"uriTemplate"
:
"file:///{path}"
,
"name"
:
"Project Files"
,
"title"
:
"📁 Project Files"
,
"description"
:
"Access files in the project directory"
,
"mimeType"
:
"application/octet-stream"
}
]
}
}
​
List Changed Notification
When the list of available resources changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/list_changed"
}
​
Subscriptions
The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:
Subscribe Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"method"
:
"resources/subscribe"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Update Notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/updated"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
,
"title"
:
"Rust Software Application Main File"
}
}
​
Message Flow
​
Data Types
​
Resource
A resource definition includes:
uri
: Unique identifier for the resource
name
: The name of the resource.
title
: Optional human-readable name of the resource for display purposes.
description
: Optional description
mimeType
: Optional MIME type
size
: Optional size in bytes
​
Resource Contents
Resources can contain either text or binary data:
​
Text Content
Copy
{
"uri"
:
"file:///example.txt"
,
"name"
:
"example.txt"
,
"title"
:
"Example Text File"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
​
Binary Content
Copy
{
"uri"
:
"file:///example.png"
,
"name"
:
"example.png"
,
"title"
:
"Example Image"
,
"mimeType"
:
"image/png"
,
"blob"
:
"base64-encoded-data"
}
​
Common URI Schemes
The protocol defines several standard URI schemes. This list not
exhaustive—implementations are always free to use additional, custom URI schemes.
​
https://
Used to represent a resource available on the web.
Servers
SHOULD
use this scheme only when the client is able to fetch and load the
resource directly from the web on its own—that is, it doesn’t need to read the resource
via the MCP server.
For other use cases, servers
SHOULD
prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.
​
file://
Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.
MCP servers
MAY
identify file:// resources with an
XDG MIME type
,
like
inode/directory
, to represent non-regular files (such as directories) that don’t
otherwise have a standard MIME type.
​
git://
Git version control integration.
​
Custom URI Schemes
Custom URI schemes
MUST
be in accordance with
RFC3986
,
taking the above guidance in to account.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Resource not found:
-32002
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
5
,
"error"
: {
"code"
:
-32002
,
"message"
:
"Resource not found"
,
"data"
: {
"uri"
:
"file:///nonexistent.txt"
}
}
}
​
Security Considerations
Servers
MUST
validate all resource URIs
Access controls
SHOULD
be implemented for sensitive resources
Binary data
MUST
be properly encoded
Resource permissions
SHOULD
be checked before operations
Was this page helpful?
Yes
No
Prompts
Tools
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Resources
Reading Resources
Resource Templates
List Changed Notification
Subscriptions
Message Flow
Data Types
Resource
Resource Contents
Text Content
Binary Content
Common URI Schemes
https://
file://
git://
Custom URI Schemes
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/tools

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Tools
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Tools
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.
​
User Interaction Model
Tools in MCP are designed to be
model-controlled
, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user’s prompts.
However, implementations are free to expose tools through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny tool invocations.
Applications
SHOULD
:
Provide UI that makes clear which tools are being exposed to the AI model
Insert clear visual indicators when tools are invoked
Present confirmation prompts to the user for operations, to ensure a human is in the
loop
​
Capabilities
Servers that support tools
MUST
declare the
tools
capability:
Copy
{
"capabilities"
: {
"tools"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available tools changes.
​
Protocol Messages
​
Listing Tools
To discover available tools, clients send a
tools/list
request. This operation supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"tools/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"tools"
: [
{
"name"
:
"get_weather"
,
"title"
:
"Weather Information Provider"
,
"description"
:
"Get current weather information for a location"
,
"inputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"location"
: {
"type"
:
"string"
,
"description"
:
"City name or zip code"
}
},
"required"
: [
"location"
]
}
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Calling Tools
To invoke a tool, clients send a
tools/call
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"tools/call"
,
"params"
: {
"name"
:
"get_weather"
,
"arguments"
: {
"location"
:
"New York"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Current weather in New York:
\n
Temperature: 72°F
\n
Conditions: Partly cloudy"
}
],
"isError"
:
false
}
}
​
List Changed Notification
When the list of available tools changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/tools/list_changed"
}
​
Message Flow
​
Data Types
​
Tool
A tool definition includes:
name
: Unique identifier for the tool
title
: Optional human-readable name of the tool for display purposes.
description
: Human-readable description of functionality
inputSchema
: JSON Schema defining expected parameters
outputSchema
: Optional JSON Schema defining expected output structure
annotations
: optional properties describing tool behavior
For trust & safety and security, clients
MUST
consider
tool annotations to be untrusted unless they come from trusted servers.
​
Tool Result
Tool results may contain
structured
or
unstructured
content.
Unstructured
content is returned in the
content
field of a result, and can contain multiple content items of different types:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"Tool result text"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-data"
,
"mimeType"
:
"image/png"
}
​
Audio Content
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
​
Resource Links
A tool
MAY
return links to
Resources
, to provide additional context
or data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:
Copy
{
"type"
:
"resource_link"
,
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"description"
:
"Primary application entry point"
,
"mimeType"
:
"text/x-rust"
}
Resource links returned by tools are not guaranteed to appear in the results
of a
resources/list
request.
​
Embedded Resources
Resources
MAY
be embedded to provide additional context
or data using a suitable
URI scheme
. Servers that use embedded resources
SHOULD
implement the
resources
capability:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"file:///project/src/main.rs"
,
"title"
:
"Project Rust Main File"
,
"mimeType"
:
"text/x-rust"
,
"text"
:
"fn main() {
\n
println!(
\"
Hello world!
\"
);
\n
}"
}
}
​
Structured Content
Structured
content is returned as a JSON object in the
structuredContent
field of a result.
For backwards compatibility, a tool that returns structured content SHOULD also return functionally equivalent unstructured content.
(For example, serialized JSON can be returned in a
TextContent
block.)
​
Output Schema
Tools may also provide an output schema for validation of structured results.
If an output schema is provided:
Servers
MUST
provide structured results that conform to this schema.
Clients
SHOULD
validate structured results against this schema.
Example tool with output schema:
Copy
{
"name"
:
"get_weather_data"
,
"title"
:
"Weather Data Retriever"
,
"description"
:
"Get current weather data for a location"
,
"inputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"location"
: {
"type"
:
"string"
,
"description"
:
"City name or zip code"
}
},
"required"
: [
"location"
]
},
"outputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"temperature"
: {
"type"
:
"number"
,
"description"
:
"Temperature in celsius"
},
"conditions"
: {
"type"
:
"string"
,
"description"
:
"Weather conditions description"
},
"humidity"
: {
"type"
:
"number"
,
"description"
:
"Humidity percentage"
}
},
"required"
: [
"temperature"
,
"conditions"
,
"humidity"
]
}
}
Example valid response for this tool:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
5
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"{
\"
temperature
\"
: 22.5,
\"
conditions
\"
:
\"
Partly cloudy
\"
,
\"
humidity
\"
: 65}"
}
],
"structuredContent"
: {
"temperature"
:
22.5
,
"conditions"
:
"Partly cloudy"
,
"humidity"
:
65
}
}
}
Providing an output schema helps clients and LLMs understand and properly handle structured tool outputs by:
Enabling strict schema validation of responses
Providing type information for better integration with programming languages
Guiding clients and LLMs to properly parse and utilize the returned data
Supporting better documentation and developer experience
​
Error Handling
Tools use two error reporting mechanisms:
Protocol Errors
: Standard JSON-RPC errors for issues like:
Unknown tools
Invalid arguments
Server errors
Tool Execution Errors
: Reported in tool results with
isError: true
:
API failures
Invalid input data
Business logic errors
Example protocol error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unknown tool: invalid_tool_name"
}
}
Example tool execution error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Failed to fetch weather data: API rate limit exceeded"
}
],
"isError"
:
true
}
}
​
Security Considerations
Servers
MUST
:
Validate all tool inputs
Implement proper access controls
Rate limit tool invocations
Sanitize tool outputs
Clients
SHOULD
:
Prompt for user confirmation on sensitive operations
Show tool inputs to the user before calling the server, to avoid malicious or
accidental data exfiltration
Validate tool results before passing to LLM
Implement timeouts for tool calls
Log tool usage for audit purposes
Was this page helpful?
Yes
No
Resources
Completion
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Tools
Calling Tools
List Changed Notification
Message Flow
Data Types
Tool
Tool Result
Text Content
Image Content
Audio Content
Resource Links
Embedded Resources
Structured Content
Output Schema
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/completion

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Completion
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Completion
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.
​
User Interaction Model
Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.
For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.
However, implementations are free to expose completion through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support completions
MUST
declare the
completions
capability:
Copy
{
"capabilities"
: {
"completions"
: {}
}
}
​
Protocol Messages
​
Requesting Completions
To get completion suggestions, clients send a
completion/complete
request specifying
what is being completed through a reference type:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"completion/complete"
,
"params"
: {
"ref"
: {
"type"
:
"ref/prompt"
,
"name"
:
"code_review"
},
"argument"
: {
"name"
:
"language"
,
"value"
:
"py"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"completion"
: {
"values"
: [
"python"
,
"pytorch"
,
"pyside"
],
"total"
:
10
,
"hasMore"
:
true
}
}
}
For prompts or URI templates with multiple arguments, clients should include previous completions in the
context.arguments
object to provide context for subsequent requests.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"completion/complete"
,
"params"
: {
"ref"
: {
"type"
:
"ref/prompt"
,
"name"
:
"code_review"
},
"argument"
: {
"name"
:
"framework"
,
"value"
:
"fla"
},
"context"
: {
"arguments"
: {
"language"
:
"python"
}
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"completion"
: {
"values"
: [
"flask"
],
"total"
:
1
,
"hasMore"
:
false
}
}
}
​
Reference Types
The protocol supports two types of completion references:
Type
Description
Example
ref/prompt
References a prompt by name
{"type": "ref/prompt", "name": "code_review"}
ref/resource
References a resource URI
{"type": "ref/resource", "uri": "file:///{path}"}
​
Completion Results
Servers return an array of completion values ranked by relevance, with:
Maximum 100 items per response
Optional total number of available matches
Boolean indicating if additional results exist
​
Message Flow
​
Data Types
​
CompleteRequest
ref
: A
PromptReference
or
ResourceReference
argument
: Object containing:
name
: Argument name
value
: Current value
context
: Object containing:
arguments
: A mapping of already-resolved argument names to their values.
​
CompleteResult
completion
: Object containing:
values
: Array of suggestions (max 100)
total
: Optional total matches
hasMore
: Additional results flag
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Method not found:
-32601
(Capability not supported)
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Return suggestions sorted by relevance
Implement fuzzy matching where appropriate
Rate limit completion requests
Validate all inputs
Clients
SHOULD
:
Debounce rapid completion requests
Cache completion results where appropriate
Handle missing or partial results gracefully
​
Security
Implementations
MUST
:
Validate all completion inputs
Implement appropriate rate limiting
Control access to sensitive suggestions
Prevent completion-based information disclosure
Was this page helpful?
Yes
No
Tools
Logging
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Requesting Completions
Reference Types
Completion Results
Message Flow
Data Types
CompleteRequest
CompleteResult
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/logging

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Logging
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Logging
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.
​
User Interaction Model
Implementations are free to expose logging through any interface pattern that suits their
needs—the protocol itself does not mandate any specific user interaction model.
​
Capabilities
Servers that emit log message notifications
MUST
declare the
logging
capability:
Copy
{
"capabilities"
: {
"logging"
: {}
}
}
​
Log Levels
The protocol follows the standard syslog severity levels specified in
RFC 5424
:
Level
Description
Example Use Case
debug
Detailed debugging information
Function entry/exit points
info
General informational messages
Operation progress updates
notice
Normal but significant events
Configuration changes
warning
Warning conditions
Deprecated feature usage
error
Error conditions
Operation failures
critical
Critical conditions
System component failures
alert
Action must be taken immediately
Data corruption detected
emergency
System is unusable
Complete system failure
​
Protocol Messages
​
Setting Log Level
To configure the minimum log level, clients
MAY
send a
logging/setLevel
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"logging/setLevel"
,
"params"
: {
"level"
:
"info"
}
}
​
Log Message Notifications
Servers send log messages using
notifications/message
notifications:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/message"
,
"params"
: {
"level"
:
"error"
,
"logger"
:
"database"
,
"data"
: {
"error"
:
"Connection failed"
,
"details"
: {
"host"
:
"localhost"
,
"port"
:
5432
}
}
}
}
​
Message Flow
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid log level:
-32602
(Invalid params)
Configuration errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Rate limit log messages
Include relevant context in data field
Use consistent logger names
Remove sensitive information
Clients
MAY
:
Present log messages in the UI
Implement log filtering/search
Display severity visually
Persist log messages
​
Security
Log messages
MUST NOT
contain:
Credentials or secrets
Personal identifying information
Internal system details that could aid attacks
Implementations
SHOULD
:
Rate limit messages
Validate all data fields
Control log access
Monitor for sensitive content
Was this page helpful?
Yes
No
Completion
Pagination
github
On this page
User Interaction Model
Capabilities
Log Levels
Protocol Messages
Setting Log Level
Log Message Notifications
Message Flow
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/2025-06-18/server/utilities/pagination

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Pagination
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Pagination
Protocol Revision
: 2025-06-18
The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.
Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.
​
Pagination Model
Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.
The
cursor
is an opaque string token, representing a position in the result set
Page size
is determined by the server, and clients
MUST NOT
assume a fixed page
size
​
Response Format
Pagination starts when the server sends a
response
that includes:
The current page of results
An optional
nextCursor
field if more results exist
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {
"resources"
: [
...
],
"nextCursor"
:
"eyJwYWdlIjogM30="
}
}
​
Request Format
After receiving a cursor, the client can
continue
paginating by issuing a request
including that cursor:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"eyJwYWdlIjogMn0="
}
}
​
Pagination Flow
​
Operations Supporting Pagination
The following MCP operations support pagination:
resources/list
- List available resources
resources/templates/list
- List resource templates
prompts/list
- List available prompts
tools/list
- List available tools
​
Implementation Guidelines
Servers
SHOULD
:
Provide stable cursors
Handle invalid cursors gracefully
Clients
SHOULD
:
Treat a missing
nextCursor
as the end of results
Support both paginated and non-paginated flows
Clients
MUST
treat cursors as opaque tokens:
Don’t make assumptions about cursor format
Don’t attempt to parse or modify cursors
Don’t persist cursors across sessions
​
Error Handling
Invalid cursors
SHOULD
result in an error with code -32602 (Invalid params).
Was this page helpful?
Yes
No
Logging
Versioning
github
On this page
Pagination Model
Response Format
Request Format
Pagination Flow
Operations Supporting Pagination
Implementation Guidelines
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/architecture/index

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Architecture
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Architecture
The Model Context Protocol (MCP) follows a client-host-server architecture where each
host can run multiple client instances. This architecture enables users to integrate AI
capabilities across applications while maintaining clear security boundaries and
isolating concerns. Built on JSON-RPC, MCP provides a stateful session protocol focused
on context exchange and sampling coordination between clients and servers.
​
Core Components
​
Host
The host process acts as the container and coordinator:
Creates and manages multiple client instances
Controls client connection permissions and lifecycle
Enforces security policies and consent requirements
Handles user authorization decisions
Coordinates AI/LLM integration and sampling
Manages context aggregation across clients
​
Clients
Each client is created by the host and maintains an isolated server connection:
Establishes one stateful session per server
Handles protocol negotiation and capability exchange
Routes protocol messages bidirectionally
Manages subscriptions and notifications
Maintains security boundaries between servers
A host application creates and manages multiple clients, with each client having a 1:1
relationship with a particular server.
​
Servers
Servers provide specialized context and capabilities:
Expose resources, tools and prompts via MCP primitives
Operate independently with focused responsibilities
Request sampling through client interfaces
Must respect security constraints
Can be local processes or remote services
​
Design Principles
MCP is built on several key design principles that inform its architecture and
implementation:
Servers should be extremely easy to build
Host applications handle complex orchestration responsibilities
Servers focus on specific, well-defined capabilities
Simple interfaces minimize implementation overhead
Clear separation enables maintainable code
Servers should be highly composable
Each server provides focused functionality in isolation
Multiple servers can be combined seamlessly
Shared protocol enables interoperability
Modular design supports extensibility
Servers should not be able to read the whole conversation, nor “see into” other
servers
Servers receive only necessary contextual information
Full conversation history stays with the host
Each server connection maintains isolation
Cross-server interactions are controlled by the host
Host process enforces security boundaries
Features can be added to servers and clients progressively
Core protocol provides minimal required functionality
Additional capabilities can be negotiated as needed
Servers and clients evolve independently
Protocol designed for future extensibility
Backwards compatibility is maintained
​
Capability Negotiation
The Model Context Protocol uses a capability-based negotiation system where clients and
servers explicitly declare their supported features during initialization. Capabilities
determine which protocol features and primitives are available during a session.
Servers declare capabilities like resource subscriptions, tool support, and prompt
templates
Clients declare capabilities like sampling support and notification handling
Both parties must respect declared capabilities throughout the session
Additional capabilities can be negotiated through extensions to the protocol
Each capability unlocks specific protocol features for use during the session. For
example:
Implemented
server features
must be advertised in the
server’s capabilities
Emitting resource subscription notifications requires the server to declare
subscription support
Tool invocation requires the server to declare tool capabilities
Sampling
requires the client to declare support in its
capabilities
This capability negotiation ensures clients and servers have a clear understanding of
supported functionality while maintaining protocol extensibility.
Was this page helpful?
Yes
No
Key Changes
Overview
github
On this page
Core Components
Host
Clients
Servers
Design Principles
Capability Negotiation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/authorization

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Authorization
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Authorization
Protocol Revision
: draft
​
Introduction
​
Purpose and Scope
The Model Context Protocol provides authorization capabilities at the transport level,
enabling MCP clients to make requests to restricted MCP servers on behalf of resource
owners. This specification defines the authorization flow for HTTP-based transports.
​
Protocol Requirements
Authorization is
OPTIONAL
for MCP implementations. When supported:
Implementations using an HTTP-based transport
SHOULD
conform to this specification.
Implementations using an STDIO transport
SHOULD NOT
follow this specification, and
instead retrieve credentials from the environment.
Implementations using alternative transports
MUST
follow established security best
practices for their protocol.
​
Standards Compliance
This authorization mechanism is based on established specifications listed below, but
implements a selected subset of their features to ensure security and interoperability
while maintaining simplicity:
OAuth 2.1 IETF DRAFT (
draft-ietf-oauth-v2-1-13
)
OAuth 2.0 Authorization Server Metadata
(
RFC8414
)
OAuth 2.0 Dynamic Client Registration Protocol
(
RFC7591
)
OAuth 2.0 Protected Resource Metadata (
RFC9728
)
​
Authorization Flow
​
Roles
A protected
MCP server
acts as an
OAuth 2.1 resource server
,
capable of accepting and responding to protected resource requests using access tokens.
An
MCP client
acts as an
OAuth 2.1 client
,
making protected resource requests on behalf of a resource owner.
The
authorization server
is responsible for interacting with the user (if necessary) and issuing access tokens for use at the MCP server.
The implementation details of the authorization server are beyond the scope of this specification. It may be hosted with the
resource server or a separate entity. The
Authorization Server Discovery section
specifies how an MCP server indicates the location of its corresponding authorization server to a client.
​
Overview
Authorization servers
MUST
implement OAuth 2.1 with appropriate security
measures for both confidential and public clients.
Authorization servers and MCP clients
SHOULD
support the OAuth 2.0 Dynamic Client Registration
Protocol (
RFC7591
).
MCP servers
MUST
implement OAuth 2.0 Protected Resource Metadata (
RFC9728
).
MCP clients
MUST
use OAuth 2.0 Protected Resource Metadata for authorization server discovery.
MCP authorization servers
MUST
provide OAuth 2.0 Authorization
Server Metadata (
RFC8414
).
MCP clients
MUST
use the OAuth 2.0 Authorization Server Metadata.
​
Authorization Server Discovery
This section describes the mechanisms by which MCP servers advertise their associated
authorization servers to MCP clients, as well as the discovery process through which MCP
clients can determine authorization server endpoints and supported capabilities.
​
Authorization Server Location
MCP servers
MUST
implement the OAuth 2.0 Protected Resource Metadata (
RFC9728
)
specification to indicate the locations of authorization servers. The Protected Resource Metadata document returned by the MCP server
MUST
include
the
authorization_servers
field containing at least one authorization server.
The specific use of
authorization_servers
is beyond the scope of this specification; implementers should consult
OAuth 2.0 Protected Resource Metadata (
RFC9728
) for
guidance on implementation details.
Implementors should note that Protected Resource Metadata documents can define multiple authorization servers. The responsibility for selecting which authorization server to use lies with the MCP client, following the guidelines specified in
RFC9728 Section 7.6 “Authorization Servers”
.
MCP servers
MUST
use the HTTP header
WWW-Authenticate
when returning a
401 Unauthorized
to indicate the location of the resource server metadata URL
as described in
RFC9728 Section 5.1 “WWW-Authenticate Response”
.
MCP clients
MUST
be able to parse
WWW-Authenticate
headers and respond appropriately to
HTTP 401 Unauthorized
responses from the MCP server.
​
Server Metadata Discovery
MCP clients
MUST
follow the OAuth 2.0 Authorization Server Metadata
RFC8414
specification to obtain the information required to interact with the authorization server.
​
Sequence Diagram
The following diagram outlines an example flow:
​
Dynamic Client Registration
MCP clients and authorization servers
SHOULD
support the
OAuth 2.0 Dynamic Client Registration Protocol
RFC7591
to allow MCP clients to obtain OAuth client IDs without user interaction. This provides a
standardized way for clients to automatically register with new authorization servers, which is crucial
for MCP because:
Clients may not know all possible MCP servers and their authorization servers in advance.
Manual registration would create friction for users.
It enables seamless connection to new MCP servers and their authorization servers.
Authorization servers can implement their own registration policies.
Any authorization servers that
do not
support Dynamic Client Registration need to provide
alternative ways to obtain a client ID (and, if applicable, client credentials). For one of
these authorization servers, MCP clients will have to either:
Hardcode a client ID (and, if applicable, client credentials) specifically for the MCP client to use when
interacting with that authorization server, or
Present a UI to users that allows them to enter these details, after registering an
OAuth client themselves (e.g., through a configuration interface hosted by the
server).
​
Authorization Flow Steps
The complete Authorization flow proceeds as follows:
​
Resource Parameter Implementation
MCP clients
MUST
implement Resource Indicators for OAuth 2.0 as defined in
RFC 8707
to explicitly specify the target resource for which the token is being requested. The
resource
parameter:
MUST
be included in both authorization requests and token requests.
MUST
identify the MCP server that the client intends to use the token with.
MUST
use the canonical URI of the MCP server as defined in
RFC 8707 Section 2
.
Canonical Server URI
For the purposes of this specification, the canonical URI of an MCP server is defined as the resource identifier as specified in
RFC 8707 Section 2
and aligns with the
resource
parameter in
RFC 9728
.
MCP clients
SHOULD
provide the most specific URI that they can for the MCP server they intend to access, following the guidance in
RFC 8707
. While the canonical form uses lowercase scheme and host components, implementations
SHOULD
accept uppercase scheme and host components for robustness and interoperability.
Examples of valid canonical URIs:
https://mcp.example.com/mcp
https://mcp.example.com
https://mcp.example.com:8443
https://mcp.example.com/server/mcp
(when path component is necessary to identify individual MCP server)
Examples of invalid canonical URIs:
mcp.example.com
(missing scheme)
https://mcp.example.com#fragment
(contains fragment)
Note:
While both
https://mcp.example.com/
(with trailing slash) and
https://mcp.example.com
(without trailing slash) are technically valid absolute URIs according to
RFC 3986
, implementations
SHOULD
consistently use the form without the trailing slash for better interoperability unless the trailing slash is semantically significant for the specific resource.
For example, if accessing an MCP server at
https://mcp.example.com
, the authorization request would include:
Copy
&resource=https%3A%2F%2Fmcp.example.com
MCP clients
MUST
send this parameter regardless of whether authorization servers support it.
​
Access Token Usage
​
Token Requirements
Access token handling when making requests to MCP servers
MUST
conform to the requirements defined in
OAuth 2.1 Section 5 “Resource Requests”
.
Specifically:
MCP client
MUST
use the Authorization request header field defined in
OAuth 2.1 Section 5.1.1
:
Copy
Authorization: Bearer <access-token>
Note that authorization
MUST
be included in every HTTP request from client to server,
even if they are part of the same logical session.
Access tokens
MUST NOT
be included in the URI query string
Example request:
Copy
GET
/mcp
HTTP
/
1.1
Host
:
mcp.example.com
Authorization
:
Bearer eyJhbGciOiJIUzI1NiIs...
​
Token Handling
MCP servers, acting in their role as an OAuth 2.1 resource server,
MUST
validate access tokens as described in
OAuth 2.1 Section 5.2
.
MCP servers
MUST
validate that access tokens were issued specifically for them as the intended audience,
according to
RFC 8707 Section 2
.
If validation fails, servers
MUST
respond according to
OAuth 2.1 Section 5.3
error handling requirements. Invalid or expired tokens
MUST
receive a HTTP 401
response.
MCP clients
MUST NOT
send tokens to the MCP server other than ones issued by the MCP server’s authorization server.
Authorization servers
MUST
only accept tokens that are valid for use with their
own resources.
MCP servers
MUST NOT
accept or transit any other tokens.
​
Error Handling
Servers
MUST
return appropriate HTTP status codes for authorization errors:
Status Code
Description
Usage
401
Unauthorized
Authorization required or token invalid
403
Forbidden
Invalid scopes or insufficient permissions
400
Bad Request
Malformed authorization request
​
Security Considerations
Implementations
MUST
follow OAuth 2.1 security best practices as laid out in
OAuth 2.1 Section 7. “Security Considerations”
.
​
Token Audience Binding and Validation
RFC 8707
Resource Indicators provide critical security benefits by binding tokens to their intended
audiences
when the Authorization Server supports the capability
. To enable current and future adoption:
MCP clients
MUST
include the
resource
parameter in authorization and token requests as specified in the
Resource Parameter Implementation
section
MCP servers
MUST
validate that tokens presented to them were specifically issued for their use
The
Security Best Practices document
outlines why token audience validation is crucial and why token passthrough is explicitly forbidden.
​
Token Theft
Attackers who obtain tokens stored by the client, or tokens cached or logged on the server can access protected resources with
requests that appear legitimate to resource servers.
Clients and servers
MUST
implement secure token storage and follow OAuth best practices,
as outlined in
OAuth 2.1, Section 7.1
.
Authorization servers
SHOULD
issue short-lived access tokens to reduce the impact of leaked tokens.
For public clients, authorization servers
MUST
rotate refresh tokens as described in
OAuth 2.1 Section 4.3.1 “Token Endpoint Extension”
.
​
Communication Security
Implementations
MUST
follow
OAuth 2.1 Section 1.5 “Communication Security”
.
Specifically:
All authorization server endpoints
MUST
be served over HTTPS.
All redirect URIs
MUST
be either
localhost
or use HTTPS.
​
Authorization Code Protection
An attacker who has gained access to an authorization code contained in an authorization response can try to redeem the authorization code for an access token or otherwise make use of the authorization code.
(Further described in
OAuth 2.1 Section 7.5
)
To mitigate this, MCP clients
MUST
implement PKCE according to
OAuth 2.1 Section 7.5.2
.
PKCE helps prevent authorization code interception and injection attacks by requiring clients to create a secret verifier-challenge pair, ensuring that only the original requestor can exchange an authorization code for tokens.
​
Open Redirection
An attacker may craft malicious redirect URIs to direct users to phishing sites.
MCP clients
MUST
have redirect URIs registered with the authorization server.
Authorization servers
MUST
validate exact redirect URIs against pre-registered values to prevent redirection attacks.
MCP clients
SHOULD
use and verify state parameters in the authorization code flow
and discard any results that do not include or have a mismatch with the original state.
Authorization servers
MUST
take precautions to prevent redirecting user agents to untrusted URI’s, following suggestions laid out in
OAuth 2.1 Section 7.12.2
Authorization servers
SHOULD
only automatically redirect the user agent if it trusts the redirection URI. If the URI is not trusted, the authorization server MAY inform the user and rely on the user to make the correct decision.
​
Confused Deputy Problem
Attackers can exploit MCP servers acting as intermediaries to third-party APIs, leading to
confused deputy vulnerabilities
.
By using stolen authorization codes, they can obtain access tokens without user consent.
MCP proxy servers using static client IDs
MUST
obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).
​
Access Token Privilege Restriction
An attacker can gain unauthorized access or otherwise compromise a MCP server if the server accepts tokens issued for other resources.
This vulnerability has two critical dimensions:
Audience validation failures.
When an MCP server doesn’t verify that tokens were specifically intended for it (for example, via the audience claim, as mentioned in
RFC9068
), it may accept tokens originally issued for other services. This breaks a fundamental OAuth security boundary, allowing attackers to reuse legitimate tokens across different services than intended.
Token passthrough.
If the MCP server not only accepts tokens with incorrect audiences but also forwards these unmodified tokens to downstream services, it can potentially cause the
“confused deputy” problem
, where the downstream API may incorrectly trust the token as if it came from the MCP server or assume the token was validated by the upstream API. See the
Token Passthrough section
of the Security Best Practices guide for additional details.
MCP servers
MUST
validate access tokens before processing the request, ensuring the access token is issued specifically for the MCP server, and take all necessary steps to ensure no data is returned to unauthorized parties.
A MCP server
MUST
follow the guidelines in
OAuth 2.1 - Section 5.2
to validate inbound tokens.
MCP servers
MUST
only accept tokens specifically intended for themselves and
MUST
reject tokens that do not include them in the audience claim or otherwise verify that they are the intended recipient of the token. See the
Security Best Practices Token Passthrough section
for details.
If the MCP server makes requests to upstream APIs, it may act as an OAuth client to them. The access token used at the upstream API is a seperate token, issued by the upstream authorization server. The MCP server
MUST NOT
pass through the token it received from the MCP client.
MCP clients
MUST
implement and use the
resource
parameter as defined in
RFC 8707 - Resource Indicators for OAuth 2.0
to explicitly specify the target resource for which the token is being requested. This requirement aligns with the recommendation in
RFC 9728 Section 7.4
. This ensures that access tokens are bound to their intended resources and
cannot be misused across different services.
Was this page helpful?
Yes
No
Transports
Security Best Practices
github
On this page
Introduction
Purpose and Scope
Protocol Requirements
Standards Compliance
Authorization Flow
Roles
Overview
Authorization Server Discovery
Authorization Server Location
Server Metadata Discovery
Sequence Diagram
Dynamic Client Registration
Authorization Flow Steps
Resource Parameter Implementation
Access Token Usage
Token Requirements
Token Handling
Error Handling
Security Considerations
Token Audience Binding and Validation
Token Theft
Communication Security
Authorization Code Protection
Open Redirection
Confused Deputy Problem
Access Token Privilege Restriction
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/index

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Overview
Protocol Revision
: draft
The Model Context Protocol consists of several key components that work together:
Base Protocol
: Core JSON-RPC message types
Lifecycle Management
: Connection initialization, capability negotiation, and
session control
Authorization
: Authentication and authorization framework for HTTP-based transports
Server Features
: Resources, prompts, and tools exposed by servers
Client Features
: Sampling and root directory lists provided by clients
Utilities
: Cross-cutting concerns like logging and argument completion
All implementations
MUST
support the base protocol and lifecycle management
components. Other components
MAY
be implemented based on the specific needs of the
application.
These protocol layers establish clear separation of concerns while enabling rich
interactions between clients and servers. The modular design allows implementations to
support exactly the features they need.
​
Messages
All messages between MCP clients and servers
MUST
follow the
JSON-RPC 2.0
specification. The protocol defines
these types of messages:
​
Requests
Requests are sent from the client to the server or vice versa, to initiate an operation.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Requests
MUST
include a string or integer ID.
Unlike base JSON-RPC, the ID
MUST NOT
be
null
.
The request ID
MUST NOT
have been previously used by the requestor within the same
session.
​
Responses
Responses are sent in reply to requests, containing the result or error of the operation.
Copy
{
jsonrpc
:
"2.0"
;
id
:
string
|
number
;
result
?:
{
[key: string]:
unknown
;
}
error
?:
{
code:
number
;
message
:
string
;
data
?:
unknown
;
}
}
Responses
MUST
include the same ID as the request they correspond to.
Responses
are further sub-categorized as either
successful results
or
errors
. Either a
result
or an
error
MUST
be set. A response
MUST NOT
set both.
Results
MAY
follow any JSON object structure, while errors
MUST
include an
error code and message at minimum.
Error codes
MUST
be integers.
​
Notifications
Notifications are sent from the client to the server or vice versa, as a one-way message.
The receiver
MUST NOT
send a response.
Copy
{
jsonrpc
:
"2.0"
;
method
:
string
;
params
?:
{
[key: string]:
unknown
;
};
}
Notifications
MUST NOT
include an ID.
​
Auth
MCP provides an
Authorization
framework for use with HTTP.
Implementations using an HTTP-based transport
SHOULD
conform to this specification,
whereas implementations using STDIO transport
SHOULD NOT
follow this specification,
and instead retrieve credentials from the environment.
Additionally, clients and servers
MAY
negotiate their own custom authentication and
authorization strategies.
For further discussions and contributions to the evolution of MCP’s auth mechanisms, join
us in
GitHub Discussions
to help shape the future of the protocol!
​
Schema
The full specification of the protocol is defined as a
TypeScript schema
.
This is the source of truth for all protocol messages and structures.
There is also a
JSON Schema
,
which is automatically generated from the TypeScript source of truth, for use with
various automated tooling.
​
General fields
​
_meta
The
_meta
property/parameter is reserved by MCP to allow clients and servers
to attach additional metadata to their interactions.
Certain key names are reserved by MCP for protocol-level metadata, as specified below;
implementations MUST NOT make assumptions about values at these keys.
Additionally, definitions in the
schema
may reserve particular names for purpose-specific metadata, as declared in those definitions.
Key name format:
valid
_meta
key names have two segments: an optional
prefix
, and a
name
.
Prefix:
If specified, MUST be a series of labels separated by dots (
.
), followed by a slash (
/
).
Labels MUST start with a letter and end with a letter or digit; interior characters can be letters, digits, or hyphens (
-
).
Any prefix beginning with zero or more valid labels, followed by
modelcontextprotocol
or
mcp
, followed by any valid label,
is
reserved
for MCP use.
For example:
modelcontextprotocol.io/
,
mcp.dev/
,
api.modelcontextprotocol.org/
, and
tools.mcp.com/
are all reserved.
Name:
Unless empty, MUST begin and end with an alphanumeric character (
[a-z0-9A-Z]
).
MAY contain hyphens (
-
), underscores (
_
), dots (
.
), and alphanumerics in between.
Was this page helpful?
Yes
No
Architecture
Lifecycle
github
On this page
Messages
Requests
Responses
Notifications
Auth
Schema
General fields
_meta
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/lifecycle

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Lifecycle
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Lifecycle
Protocol Revision
: draft
The Model Context Protocol (MCP) defines a rigorous lifecycle for client-server
connections that ensures proper capability negotiation and state management.
Initialization
: Capability negotiation and protocol version agreement
Operation
: Normal protocol communication
Shutdown
: Graceful termination of the connection
​
Lifecycle Phases
​
Initialization
The initialization phase
MUST
be the first interaction between client and server.
During this phase, the client and server:
Establish protocol version compatibility
Exchange and negotiate capabilities
Share implementation details
The client
MUST
initiate this phase by sending an
initialize
request containing:
Protocol version supported
Client capabilities
Client implementation information
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"initialize"
,
"params"
: {
"protocolVersion"
:
"2024-11-05"
,
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
},
"sampling"
: {},
"elicitation"
: {}
},
"clientInfo"
: {
"name"
:
"ExampleClient"
,
"title"
:
"Example Client Display Name"
,
"version"
:
"1.0.0"
}
}
}
The server
MUST
respond with its own capabilities and information:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"protocolVersion"
:
"2024-11-05"
,
"capabilities"
: {
"logging"
: {},
"prompts"
: {
"listChanged"
:
true
},
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
},
"tools"
: {
"listChanged"
:
true
}
},
"serverInfo"
: {
"name"
:
"ExampleServer"
,
"title"
:
"Example Server Display Name"
,
"version"
:
"1.0.0"
},
"instructions"
:
"Optional instructions for the client"
}
}
After successful initialization, the client
MUST
send an
initialized
notification
to indicate it is ready to begin normal operations:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/initialized"
}
The client
SHOULD NOT
send requests other than
pings
before the server has responded to the
initialize
request.
The server
SHOULD NOT
send requests other than
pings
and
logging
before receiving the
initialized
notification.
​
Version Negotiation
In the
initialize
request, the client
MUST
send a protocol version it supports.
This
SHOULD
be the
latest
version supported by the client.
If the server supports the requested protocol version, it
MUST
respond with the same
version. Otherwise, the server
MUST
respond with another protocol version it
supports. This
SHOULD
be the
latest
version supported by the server.
If the client does not support the version in the server’s response, it
SHOULD
disconnect.
If using HTTP, the client
MUST
include the
MCP-Protocol-Version: <protocol-version>
HTTP header on all subsequent requests to the MCP
server.
For details, see
the Protocol Version Header section in Transports
.
​
Capability Negotiation
Client and server capabilities establish which optional protocol features will be
available during the session.
Key capabilities include:
Category
Capability
Description
Client
roots
Ability to provide filesystem
roots
Client
sampling
Support for LLM
sampling
requests
Client
elicitation
Support for server
elicitation
requests
Client
experimental
Describes support for non-standard experimental features
Server
prompts
Offers
prompt templates
Server
resources
Provides readable
resources
Server
tools
Exposes callable
tools
Server
logging
Emits structured
log messages
Server
completions
Supports argument
autocompletion
Server
experimental
Describes support for non-standard experimental features
Capability objects can describe sub-capabilities like:
listChanged
: Support for list change notifications (for prompts, resources, and
tools)
subscribe
: Support for subscribing to individual items’ changes (resources only)
​
Operation
During the operation phase, the client and server exchange messages according to the
negotiated capabilities.
Both parties
SHOULD
:
Respect the negotiated protocol version
Only use capabilities that were successfully negotiated
​
Shutdown
During the shutdown phase, one side (usually the client) cleanly terminates the protocol
connection. No specific shutdown messages are defined—instead, the underlying transport
mechanism should be used to signal connection termination:
​
stdio
For the stdio
transport
, the client
SHOULD
initiate
shutdown by:
First, closing the input stream to the child process (the server)
Waiting for the server to exit, or sending
SIGTERM
if the server does not exit
within a reasonable time
Sending
SIGKILL
if the server does not exit within a reasonable time after
SIGTERM
The server
MAY
initiate shutdown by closing its output stream to the client and
exiting.
​
HTTP
For HTTP
transports
, shutdown is indicated by closing the
associated HTTP connection(s).
​
Timeouts
Implementations
SHOULD
establish timeouts for all sent requests, to prevent hung
connections and resource exhaustion. When the request has not received a success or error
response within the timeout period, the sender
SHOULD
issue a
cancellation
notification
for that request and stop waiting for
a response.
SDKs and other middleware
SHOULD
allow these timeouts to be configured on a
per-request basis.
Implementations
MAY
choose to reset the timeout clock when receiving a
progress
notification
corresponding to the request, as this
implies that work is actually happening. However, implementations
SHOULD
always
enforce a maximum timeout, regardless of progress notifications, to limit the impact of a
misbehaving client or server.
​
Error Handling
Implementations
SHOULD
be prepared to handle these error cases:
Protocol version mismatch
Failure to negotiate required capabilities
Request
timeouts
Example initialization error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unsupported protocol version"
,
"data"
: {
"supported"
: [
"2024-11-05"
],
"requested"
:
"1.0.0"
}
}
}
Was this page helpful?
Yes
No
Overview
Transports
github
On this page
Lifecycle Phases
Initialization
Version Negotiation
Capability Negotiation
Operation
Shutdown
stdio
HTTP
Timeouts
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/security_best_practices

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Security Best Practices
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Security Best Practices
​
Introduction
​
Purpose and Scope
This document provides security considerations for the Model Context Protocol (MCP), complementing the MCP Authorization specification. This document identifies security risks, attack vectors, and best practices specific to MCP implementations.
The primary audience for this document includes developers implementing MCP authorization flows, MCP server operators, and security professionals evaluating MCP-based systems. This document should be read alongside the MCP Authorization specification and
OAuth 2.0 security best practices
.
​
Attacks and Mitigations
This section gives a detailed description of attacks on MCP implementations, along with potential countermeasures.
​
Confused Deputy Problem
Attackers can exploit MCP servers proxying other resource servers, creating “
confused deputy
” vulnerabilities.
​
Terminology
MCP Proxy Server
: An MCP server that connects MCP clients to third-party APIs, offering MCP features while delegating operations and acting as a single OAuth client to the third-party API server.
Third-Party Authorization Server
: Authorization server that protects the third-party API. It may lack dynamic client registration support, requiring MCP proxy to use a static client ID for all requests.
Third-Party API
: The protected resource server that provides the actual API functionality. Access to this
API requires tokens issued by the third-party authorization server.
Static Client ID
: A fixed OAuth 2.0 client identifier used by the MCP proxy server when communicating with
the third-party authorization server. This Client ID refers to the MCP server acting as a client
to the Third-Party API. It is the same value for all MCP server to Third-Party API interactions regardless of
which MCP client initiated the request.
​
Architecture and Attack Flows
Normal OAuth proxy usage (preserves user consent)
Malicious OAuth proxy usage (skips user consent)
​
Attack Description
When an MCP proxy server uses a static client ID to authenticate with a third-party
authorization server that does not support dynamic client registration, the following
attack becomes possible:
A user authenticates normally through the MCP proxy server to access the third-party API
During this flow, the third-party authorization server sets a cookie on the user agent
indicating consent for the static client ID
An attacker later sends the user a malicious link containing a crafted authorization request which contains a malicious redirect URI along with a new dynamically registered client ID
When the user clicks the link, their browser still has the consent cookie from the previous legitimate request
The third-party authorization server detects the cookie and skips the consent screen
The MCP authorization code is redirected to the attacker’s server (specified in the crafted redirect_uri during dynamic client registration)
The attacker exchanges the stolen authorization code for access tokens for the MCP server without the user’s explicit approval
Attacker now has access to the third-party API as the compromised user
​
Mitigation
MCP proxy servers using static client IDs
MUST
obtain user consent for each dynamically
registered client before forwarding to third-party authorization servers (which may require additional consent).
​
Token Passthrough
“Token passthrough” is an anti-pattern where an MCP server accepts tokens from an MCP client without validating that the tokens were properly issued
to the MCP server
and “passing them through” to the downstream API.
​
Risks
Token passthrough is explicitly forbidden in the
authorization specification
as it introduces a number of security risks, that include:
Security Control Circumvention
The MCP Server or downstream APIs might implement important security controls like rate limiting, request validation, or traffic monitoring, that depend on the token audience or other credential constraints. If clients can obtain and use tokens directly with the downstream APIs without the MCP server validating them properly or ensuring that the tokens are issued for the right service, they bypass these controls.
Accountability and Audit Trail Issues
The MCP Server will be unable to identify or distinguish between MCP Clients when clients are calling with an upstream-issued access token which may be opaque to the MCP Server.
The downstream Resource Server’s logs may show requests that appear to come from a different source with a different identity, rather than the MCP server that is actually forwarding the tokens.
Both factors make incident investigation, controls, and auditing more difficult.
If the MCP Server passes tokens without validating their claims (e.g., roles, privileges, or audience) or other metadata, a malicious actor in possession of a stolen token can use the server as a proxy for data exfiltration.
Trust Boundary Issues
The downstream Resource Server grants trust to specific entities. This trust might include assumptions about origin or client behavior patterns. Breaking this trust boundary could lead to unexpected issues.
If the token is accepted by multiple services without proper validation, an attacker compromising one service can use the token to access other connected services.
Future Compatibility Risk
Even if an MCP Server starts as a “pure proxy” today, it might need to add security controls later. Starting with proper token audience separation makes it easier to evolve the security model.
​
Mitigation
MCP servers
MUST NOT
accept any tokens that were not explicitly issued for the MCP server.
​
Session Hijacking
Session hijacking is an attack vector where a client is provided a session ID by the server, and an unauthorized party is able to obtain and use that same session ID to impersonate the original client and perform unauthorized actions on their behalf.
​
Session Hijack Prompt Injection
​
Session Hijack Impersonation
​
Attack Description
When you have multiple stateful HTTP servers that handle MCP requests, the following attack vectors are possible:
Session Hijack Prompt Injection
The client connects to
Server A
and receives a session ID.
The attacker obtains an existing session ID and sends a malicious event to
Server B
with said session ID.
When a server supports
redelivery/resumable streams
, deliberately terminating the request before receiving the response could lead to it being resumed by the original client via the GET request for server sent events.
If a particular server initiates server sent events as a consequence of a tool call such as a
notifications/tools/list_changed
, where it is possible to affect the tools that are offered by the server, a client could end up with tools that they were not aware were enabled.
Server B
enqueues the event (associated with session ID) into a shared queue.
Server A
polls the queue for events using the session ID and retrieves the malicious payload.
Server A
sends the malicious payload to the client as an asynchronous or resumed response.
The client receives and acts on the malicious payload, leading to potential compromise.
Session Hijack Impersonation
The MCP client authenticates with the MCP server, creating a persistent session ID.
The attacker obtains the session ID.
The attacker makes calls to the MCP server using the session ID.
MCP server does not check for additional authorization and treats the attacker as a legitimate user, allowing unauthorized access or actions.
​
Mitigation
To prevent session hijacking and event injection attacks, the following mitigations should be implemented:
MCP servers that implement authorization
MUST
verify all inbound requests.
MCP Servers
MUST NOT
use sessions for authentication.
MCP servers
MUST
use secure, non-deterministic session IDs.
Generated session IDs (e.g., UUIDs)
SHOULD
use secure random number generators. Avoid predictable or sequential session identifiers that could be guessed by an attacker. Rotating or expiring session IDs can also reduce the risk.
MCP servers
SHOULD
bind session IDs to user-specific information.
When storing or transmitting session-related data (e.g., in a queue), combine the session ID with information unique to the authorized user, such as their internal user ID. Use a key format like
<user_id>:<session_id>
. This ensures that even if an attacker guesses a session ID, they cannot impersonate another user as the user ID is derived from the user token and not provided by the client.
MCP servers can optionally leverage additional unique identifiers.
Was this page helpful?
Yes
No
Authorization
Cancellation
github
On this page
Introduction
Purpose and Scope
Attacks and Mitigations
Confused Deputy Problem
Terminology
Architecture and Attack Flows
Attack Description
Mitigation
Token Passthrough
Risks
Mitigation
Session Hijacking
Session Hijack Prompt Injection
Session Hijack Impersonation
Attack Description
Mitigation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/transports

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Base Protocol
Transports
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Base Protocol
Copy page
Transports
Protocol Revision
: draft
MCP uses JSON-RPC to encode messages. JSON-RPC messages
MUST
be UTF-8 encoded.
The protocol currently defines two standard transport mechanisms for client-server
communication:
stdio
, communication over standard in and standard out
Streamable HTTP
Clients
SHOULD
support stdio whenever possible.
It is also possible for clients and servers to implement
custom transports
in a pluggable fashion.
​
stdio
In the
stdio
transport:
The client launches the MCP server as a subprocess.
The server reads JSON-RPC messages from its standard input (
stdin
) and sends messages
to its standard output (
stdout
).
Messages are individual JSON-RPC requests, notifications, or responses.
Messages are delimited by newlines, and
MUST NOT
contain embedded newlines.
The server
MAY
write UTF-8 strings to its standard error (
stderr
) for logging
purposes. Clients
MAY
capture, forward, or ignore this logging.
The server
MUST NOT
write anything to its
stdout
that is not a valid MCP message.
The client
MUST NOT
write anything to the server’s
stdin
that is not a valid MCP
message.
​
Streamable HTTP
This replaces the
HTTP+SSE
transport
from
protocol version 2024-11-05. See the
backwards compatibility
guide below.
In the
Streamable HTTP
transport, the server operates as an independent process that
can handle multiple client connections. This transport uses HTTP POST and GET requests.
Server can optionally make use of
Server-Sent Events
(SSE) to stream
multiple server messages. This permits basic MCP servers, as well as more feature-rich
servers supporting streaming and server-to-client notifications and requests.
The server
MUST
provide a single HTTP endpoint path (hereafter referred to as the
MCP endpoint
) that supports both POST and GET methods. For example, this could be a
URL like
https://example.com/mcp
.
​
Security Warning
When implementing Streamable HTTP transport:
Servers
MUST
validate the
Origin
header on all incoming connections to prevent DNS rebinding attacks
When running locally, servers
SHOULD
bind only to localhost (127.0.0.1) rather than all network interfaces (0.0.0.0)
Servers
SHOULD
implement proper authentication for all connections
Without these protections, attackers could use DNS rebinding to interact with local MCP servers from remote websites.
​
Sending Messages to the Server
Every JSON-RPC message sent from the client
MUST
be a new HTTP POST request to the
MCP endpoint.
The client
MUST
use HTTP POST to send JSON-RPC messages to the MCP endpoint.
The client
MUST
include an
Accept
header, listing both
application/json
and
text/event-stream
as supported content types.
The body of the POST request
MUST
be a single JSON-RPC
request
,
notification
, or
response
.
If the input is a JSON-RPC
response
or
notification
:
If the server accepts the input, the server
MUST
return HTTP status code 202
Accepted with no body.
If the server cannot accept the input, it
MUST
return an HTTP error status code
(e.g., 400 Bad Request). The HTTP response body
MAY
comprise a JSON-RPC
error
response
that has no
id
.
If the input is a JSON-RPC
request
, the server
MUST
either
return
Content-Type: text/event-stream
, to initiate an SSE stream, or
Content-Type: application/json
, to return one JSON object. The client
MUST
support both these cases.
If the server initiates an SSE stream:
The SSE stream
SHOULD
eventually include JSON-RPC
response
for the
JSON-RPC
request
sent in the POST body.
The server
MAY
send JSON-RPC
requests
and
notifications
before sending the
JSON-RPC
response
. These messages
SHOULD
relate to the originating client
request
.
The server
SHOULD NOT
close the SSE stream before sending the JSON-RPC
response
for the received JSON-RPC
request
, unless the
session
expires.
After the JSON-RPC
response
has been sent, the server
SHOULD
close the SSE
stream.
Disconnection
MAY
occur at any time (e.g., due to network conditions).
Therefore:
Disconnection
SHOULD NOT
be interpreted as the client cancelling its request.
To cancel, the client
SHOULD
explicitly send an MCP
CancelledNotification
.
To avoid message loss due to disconnection, the server
MAY
make the stream
resumable
.
​
Listening for Messages from the Server
The client
MAY
issue an HTTP GET to the MCP endpoint. This can be used to open an
SSE stream, allowing the server to communicate to the client, without the client first
sending data via HTTP POST.
The client
MUST
include an
Accept
header, listing
text/event-stream
as a
supported content type.
The server
MUST
either return
Content-Type: text/event-stream
in response to
this HTTP GET, or else return HTTP 405 Method Not Allowed, indicating that the server
does not offer an SSE stream at this endpoint.
If the server initiates an SSE stream:
The server
MAY
send JSON-RPC
requests
and
notifications
on the stream.
These messages
SHOULD
be unrelated to any concurrently-running JSON-RPC
request
from the client.
The server
MUST NOT
send a JSON-RPC
response
on the stream
unless
resuming
a stream associated with a previous client
request.
The server
MAY
close the SSE stream at any time.
The client
MAY
close the SSE stream at any time.
​
Multiple Connections
The client
MAY
remain connected to multiple SSE streams simultaneously.
The server
MUST
send each of its JSON-RPC messages on only one of the connected
streams; that is, it
MUST NOT
broadcast the same message across multiple streams.
The risk of message loss
MAY
be mitigated by making the stream
resumable
.
​
Resumability and Redelivery
To support resuming broken connections, and redelivering messages that might otherwise be
lost:
Servers
MAY
attach an
id
field to their SSE events, as described in the
SSE standard
.
If present, the ID
MUST
be globally unique across all streams within that
session
—or all streams with that specific client, if session
management is not in use.
If the client wishes to resume after a broken connection, it
SHOULD
issue an HTTP
GET to the MCP endpoint, and include the
Last-Event-ID
header to indicate the last event ID it received.
The server
MAY
use this header to replay messages that would have been sent
after the last event ID,
on the stream that was disconnected
, and to resume the
stream from that point.
The server
MUST NOT
replay messages that would have been delivered on a
different stream.
In other words, these event IDs should be assigned by servers on a
per-stream
basis, to
act as a cursor within that particular stream.
​
Session Management
An MCP “session” consists of logically related interactions between a client and a
server, beginning with the
initialization phase
. To support
servers which want to establish stateful sessions:
A server using the Streamable HTTP transport
MAY
assign a session ID at
initialization time, by including it in an
Mcp-Session-Id
header on the HTTP
response containing the
InitializeResult
.
The session ID
SHOULD
be globally unique and cryptographically secure (e.g., a
securely generated UUID, a JWT, or a cryptographic hash).
The session ID
MUST
only contain visible ASCII characters (ranging from 0x21 to
0x7E).
If an
Mcp-Session-Id
is returned by the server during initialization, clients using
the Streamable HTTP transport
MUST
include it in the
Mcp-Session-Id
header on
all of their subsequent HTTP requests.
Servers that require a session ID
SHOULD
respond to requests without an
Mcp-Session-Id
header (other than initialization) with HTTP 400 Bad Request.
The server
MAY
terminate the session at any time, after which it
MUST
respond
to requests containing that session ID with HTTP 404 Not Found.
When a client receives HTTP 404 in response to a request containing an
Mcp-Session-Id
, it
MUST
start a new session by sending a new
InitializeRequest
without a session ID attached.
Clients that no longer need a particular session (e.g., because the user is leaving
the client application)
SHOULD
send an HTTP DELETE to the MCP endpoint with the
Mcp-Session-Id
header, to explicitly terminate the session.
The server
MAY
respond to this request with HTTP 405 Method Not Allowed,
indicating that the server does not allow clients to terminate sessions.
​
Sequence Diagram
​
Protocol Version Header
If using HTTP, the client
MUST
include the
MCP-Protocol-Version: <protocol-version>
HTTP header on all subsequent requests to the MCP
server, allowing the MCP server to respond based on the MCP protocol version.
For example:
MCP-Protocol-Version: 2025-06-18
The protocol version sent by the client
SHOULD
be the one
negotiated during
initialization
.
For backwards compatibility, if the server does
not
receive an
MCP-Protocol-Version
header, and has no other way to identify the version - for example, by relying on the
protocol version negotiated during initialization - the server
SHOULD
assume protocol
version
2025-03-26
.
If the server receives a request with an invalid or unsupported
MCP-Protocol-Version
, it
MUST
respond with
400 Bad Request
.
​
Backwards Compatibility
Clients and servers can maintain backwards compatibility with the deprecated
HTTP+SSE
transport
(from
protocol version 2024-11-05) as follows:
Servers
wanting to support older clients should:
Continue to host both the SSE and POST endpoints of the old transport, alongside the
new “MCP endpoint” defined for the Streamable HTTP transport.
It is also possible to combine the old POST endpoint and the new MCP endpoint, but
this may introduce unneeded complexity.
Clients
wanting to support older servers should:
Accept an MCP server URL from the user, which may point to either a server using the
old transport or the new transport.
Attempt to POST an
InitializeRequest
to the server URL, with an
Accept
header as
defined above:
If it succeeds, the client can assume this is a server supporting the new Streamable
HTTP transport.
If it fails with an HTTP 4xx status code (e.g., 405 Method Not Allowed or 404 Not
Found):
Issue a GET request to the server URL, expecting that this will open an SSE stream
and return an
endpoint
event as the first event.
When the
endpoint
event arrives, the client can assume this is a server running
the old HTTP+SSE transport, and should use that transport for all subsequent
communication.
​
Custom Transports
Clients and servers
MAY
implement additional custom transport mechanisms to suit
their specific needs. The protocol is transport-agnostic and can be implemented over any
communication channel that supports bidirectional message exchange.
Implementers who choose to support custom transports
MUST
ensure they preserve the
JSON-RPC message format and lifecycle requirements defined by MCP. Custom transports
SHOULD
document their specific connection establishment and message exchange patterns
to aid interoperability.
Was this page helpful?
Yes
No
Lifecycle
Authorization
github
On this page
stdio
Streamable HTTP
Security Warning
Sending Messages to the Server
Listening for Messages from the Server
Multiple Connections
Resumability and Redelivery
Session Management
Sequence Diagram
Protocol Version Header
Backwards Compatibility
Custom Transports
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/utilities/cancellation

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Cancellation
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Cancellation
Protocol Revision
: draft
The Model Context Protocol (MCP) supports optional cancellation of in-progress requests
through notification messages. Either side can send a cancellation notification to
indicate that a previously-issued request should be terminated.
​
Cancellation Flow
When a party wants to cancel an in-progress request, it sends a
notifications/cancelled
notification containing:
The ID of the request to cancel
An optional reason string that can be logged or displayed
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/cancelled"
,
"params"
: {
"requestId"
:
"123"
,
"reason"
:
"User requested cancellation"
}
}
​
Behavior Requirements
Cancellation notifications
MUST
only reference requests that:
Were previously issued in the same direction
Are believed to still be in-progress
The
initialize
request
MUST NOT
be cancelled by clients
Receivers of cancellation notifications
SHOULD
:
Stop processing the cancelled request
Free associated resources
Not send a response for the cancelled request
Receivers
MAY
ignore cancellation notifications if:
The referenced request is unknown
Processing has already completed
The request cannot be cancelled
The sender of the cancellation notification
SHOULD
ignore any response to the
request that arrives afterward
​
Timing Considerations
Due to network latency, cancellation notifications may arrive after request processing
has completed, and potentially after a response has already been sent.
Both parties
MUST
handle these race conditions gracefully:
​
Implementation Notes
Both parties
SHOULD
log cancellation reasons for debugging
Application UIs
SHOULD
indicate when cancellation is requested
​
Error Handling
Invalid cancellation notifications
SHOULD
be ignored:
Unknown request IDs
Already completed requests
Malformed notifications
This maintains the “fire and forget” nature of notifications while allowing for race
conditions in asynchronous communication.
Was this page helpful?
Yes
No
Security Best Practices
Ping
github
On this page
Cancellation Flow
Behavior Requirements
Timing Considerations
Implementation Notes
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/utilities/ping

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Ping
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Ping
Protocol Revision
: draft
The Model Context Protocol includes an optional ping mechanism that allows either party
to verify that their counterpart is still responsive and the connection is alive.
​
Overview
The ping functionality is implemented through a simple request/response pattern. Either
the client or server can initiate a ping by sending a
ping
request.
​
Message Format
A ping request is a standard JSON-RPC request with no parameters:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"method"
:
"ping"
}
​
Behavior Requirements
The receiver
MUST
respond promptly with an empty response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {}
}
If no response is received within a reasonable timeout period, the sender
MAY
:
Consider the connection stale
Terminate the connection
Attempt reconnection procedures
​
Usage Patterns
​
Implementation Considerations
Implementations
SHOULD
periodically issue pings to detect connection health
The frequency of pings
SHOULD
be configurable
Timeouts
SHOULD
be appropriate for the network environment
Excessive pinging
SHOULD
be avoided to reduce network overhead
​
Error Handling
Timeouts
SHOULD
be treated as connection failures
Multiple failed pings
MAY
trigger connection reset
Implementations
SHOULD
log ping failures for diagnostics
Was this page helpful?
Yes
No
Cancellation
Progress
github
On this page
Overview
Message Format
Behavior Requirements
Usage Patterns
Implementation Considerations
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/basic/utilities/progress

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Progress
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Overview
Lifecycle
Transports
Authorization
Security Best Practices
Utilities
Cancellation
Ping
Progress
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Progress
Protocol Revision
: draft
The Model Context Protocol (MCP) supports optional progress tracking for long-running
operations through notification messages. Either side can send progress notifications to
provide updates about operation status.
​
Progress Flow
When a party wants to
receive
progress updates for a request, it includes a
progressToken
in the request metadata.
Progress tokens
MUST
be a string or integer value
Progress tokens can be chosen by the sender using any means, but
MUST
be unique
across all active requests.
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"some_method"
,
"params"
: {
"_meta"
: {
"progressToken"
:
"abc123"
}
}
}
The receiver
MAY
then send progress notifications containing:
The original progress token
The current progress value so far
An optional “total” value
An optional “message” value
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/progress"
,
"params"
: {
"progressToken"
:
"abc123"
,
"progress"
:
50
,
"total"
:
100
,
"message"
:
"Reticulating splines..."
}
}
The
progress
value
MUST
increase with each notification, even if the total is
unknown.
The
progress
and the
total
values
MAY
be floating point.
The
message
field
SHOULD
provide relevant human readable progress information.
​
Behavior Requirements
Progress notifications
MUST
only reference tokens that:
Were provided in an active request
Are associated with an in-progress operation
Receivers of progress requests
MAY
:
Choose not to send any progress notifications
Send notifications at whatever frequency they deem appropriate
Omit the total value if unknown
​
Implementation Notes
Senders and receivers
SHOULD
track active progress tokens
Both parties
SHOULD
implement rate limiting to prevent flooding
Progress notifications
MUST
stop after completion
Was this page helpful?
Yes
No
Ping
Roots
github
On this page
Progress Flow
Behavior Requirements
Implementation Notes
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/changelog

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Key Changes
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Key Changes
This document lists changes made to the Model Context Protocol (MCP) specification since
the previous revision,
2025-06-18
.
​
Major changes
​
Other schema changes
​
Full changelog
For a complete list of all changes that have been made since the last protocol revision,
see GitHub
.
Was this page helpful?
Yes
No
Specification
Architecture
github
On this page
Major changes
Other schema changes
Full changelog
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/client/elicitation

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Elicitation
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Elicitation
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Elicitation
Protocol Revision
: draft
Elicitation is newly introduced in this version of the MCP specification and its design may evolve in future protocol versions.
The Model Context Protocol (MCP) provides a standardized way for servers to request additional
information from users through the client during interactions. This flow allows clients to
maintain control over user interactions and data sharing while enabling servers to gather
necessary information dynamically.
Servers request structured data from users with JSON schemas to validate responses.
​
User Interaction Model
Elicitation in MCP allows servers to implement interactive workflows by enabling user input
requests to occur
nested
inside other MCP server features.
Implementations are free to expose elicitation through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
For trust & safety and security:
Servers
MUST NOT
use elicitation to request sensitive information.
Applications
SHOULD
:
Provide UI that makes it clear which server is requesting information
Allow users to review and modify their responses before sending
Respect user privacy and provide clear reject and cancel options
​
Capabilities
Clients that support elicitation
MUST
declare the
elicitation
capability during
initialization
:
Copy
{
"capabilities"
: {
"elicitation"
: {}
}
}
​
Protocol Messages
​
Creating Elicitation Requests
To request information from a user, servers send an
elicitation/create
request:
​
Simple Text Request
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"elicitation/create"
,
"params"
: {
"message"
:
"Please provide your GitHub username"
,
"requestedSchema"
: {
"type"
:
"object"
,
"properties"
: {
"name"
: {
"type"
:
"string"
}
},
"required"
: [
"name"
]
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"action"
:
"accept"
,
"content"
: {
"name"
:
"octocat"
}
}
}
​
Structured Data Request
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"elicitation/create"
,
"params"
: {
"message"
:
"Please provide your contact information"
,
"requestedSchema"
: {
"type"
:
"object"
,
"properties"
: {
"name"
: {
"type"
:
"string"
,
"description"
:
"Your full name"
},
"email"
: {
"type"
:
"string"
,
"format"
:
"email"
,
"description"
:
"Your email address"
},
"age"
: {
"type"
:
"number"
,
"minimum"
:
18
,
"description"
:
"Your age"
}
},
"required"
: [
"name"
,
"email"
]
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"action"
:
"accept"
,
"content"
: {
"name"
:
"Monalisa Octocat"
,
"email"
:
"
[email protected]
"
,
"age"
:
30
}
}
}
Reject Response Example:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"action"
:
"reject"
}
}
Cancel Response Example:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"action"
:
"cancel"
}
}
​
Message Flow
​
Request Schema
The
requestedSchema
field allows servers to define the structure of the expected response using a restricted subset of JSON Schema. To simplify implementation for clients, elicitation schemas are limited to flat objects with primitive properties only:
Copy
"requestedSchema"
: {
"type"
:
"object"
,
"properties"
: {
"propertyName"
: {
"type"
:
"string"
,
"title"
:
"Display Name"
,
"description"
:
"Description of the property"
},
"anotherProperty"
: {
"type"
:
"number"
,
"minimum"
:
0
,
"maximum"
:
100
}
},
"required"
: [
"propertyName"
]
}
​
Supported Schema Types
The schema is restricted to these primitive types:
String Schema
Copy
{
"type"
:
"string"
,
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"minLength"
:
3
,
"maxLength"
:
50
,
"pattern"
:
"^[A-Za-z]+$"
,
"format"
:
"email"
}
Supported formats:
email
,
uri
,
date
,
date-time
Number Schema
Copy
{
"type"
:
"number"
,
// or "integer"
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"minimum"
:
0
,
"maximum"
:
100
}
Boolean Schema
Copy
{
"type"
:
"boolean"
,
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"default"
:
false
}
Enum Schema
Copy
{
"type"
:
"string"
,
"title"
:
"Display Name"
,
"description"
:
"Description text"
,
"enum"
: [
"option1"
,
"option2"
,
"option3"
],
"enumNames"
: [
"Option 1"
,
"Option 2"
,
"Option 3"
]
}
Clients can use this schema to:
Generate appropriate input forms
Validate user input before sending
Provide better guidance to users
Note that complex nested structures, arrays of objects, and other advanced JSON Schema features are intentionally not supported to simplify client implementation.
​
Response Actions
Elicitation responses use a three-action model to clearly distinguish between different user actions:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"action"
:
"accept"
,
// or "reject" or "cancel"
"content"
: {
"propertyName"
:
"value"
,
"anotherProperty"
:
42
}
}
}
The three response actions are:
Accept
(
action: "accept"
): User explicitly approved and submitted with data
The
content
field contains the submitted data matching the requested schema
Example: User clicked “Submit”, “OK”, “Confirm”, etc.
Reject
(
action: "reject"
): User explicitly rejected the request
The
content
field is typically omitted
Example: User clicked “Reject”, “Decline”, “No”, etc.
Cancel
(
action: "cancel"
): User dismissed without making an explicit choice
The
content
field is typically omitted
Example: User closed the dialog, clicked outside, pressed Escape, etc.
Servers should handle each state appropriately:
Accept
: Process the submitted data
Reject
: Handle explicit rejection (e.g., offer alternatives)
Cancel
: Handle dismissal (e.g., prompt again later)
​
Security Considerations
Servers
MUST NOT
request sensitive information through elicitation
Clients
SHOULD
implement user approval controls
Both parties
SHOULD
validate elicitation content against the provided schema
Clients
SHOULD
provide clear indication of which server is requesting information
Clients
SHOULD
allow users to reject elicitation requests at any time
Clients
SHOULD
implement rate limiting
Clients
SHOULD
present elicitation requests in a way that makes it clear what information is being requested and why
Was this page helpful?
Yes
No
Sampling
Overview
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Creating Elicitation Requests
Simple Text Request
Structured Data Request
Message Flow
Request Schema
Supported Schema Types
Response Actions
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/client/roots

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Roots
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Elicitation
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Roots
Protocol Revision
: draft
The Model Context Protocol (MCP) provides a standardized way for clients to expose
filesystem “roots” to servers. Roots define the boundaries of where servers can operate
within the filesystem, allowing them to understand which directories and files they have
access to. Servers can request the list of roots from supporting clients and receive
notifications when that list changes.
​
User Interaction Model
Roots in MCP are typically exposed through workspace or project configuration interfaces.
For example, implementations could offer a workspace/project picker that allows users to
select directories and files the server should have access to. This can be combined with
automatic workspace detection from version control systems or project files.
However, implementations are free to expose roots through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Clients that support roots
MUST
declare the
roots
capability during
initialization
:
Copy
{
"capabilities"
: {
"roots"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the client will emit notifications when the list of roots
changes.
​
Protocol Messages
​
Listing Roots
To retrieve roots, servers send a
roots/list
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"roots/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"roots"
: [
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
]
}
}
​
Root List Changes
When roots change, clients that support
listChanged
MUST
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/roots/list_changed"
}
​
Message Flow
​
Data Types
​
Root
A root definition includes:
uri
: Unique identifier for the root. This
MUST
be a
file://
URI in the current
specification.
name
: Optional human-readable name for display purposes.
Example roots for different use cases:
​
Project Directory
Copy
{
"uri"
:
"file:///home/user/projects/myproject"
,
"name"
:
"My Project"
}
​
Multiple Repositories
Copy
[
{
"uri"
:
"file:///home/user/repos/frontend"
,
"name"
:
"Frontend Repository"
},
{
"uri"
:
"file:///home/user/repos/backend"
,
"name"
:
"Backend Repository"
}
]
​
Error Handling
Clients
SHOULD
return standard JSON-RPC errors for common failure cases:
Client does not support roots:
-32601
(Method not found)
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-32601
,
"message"
:
"Roots not supported"
,
"data"
: {
"reason"
:
"Client does not have roots capability"
}
}
}
​
Security Considerations
Clients
MUST
:
Only expose roots with appropriate permissions
Validate all root URIs to prevent path traversal
Implement proper access controls
Monitor root accessibility
Servers
SHOULD
:
Handle cases where roots become unavailable
Respect root boundaries during operations
Validate all paths against provided roots
​
Implementation Guidelines
Clients
SHOULD
:
Prompt users for consent before exposing roots to servers
Provide clear user interfaces for root management
Validate root accessibility before exposing
Monitor for root changes
Servers
SHOULD
:
Check for roots capability before usage
Handle root list changes gracefully
Respect root boundaries in operations
Cache root information appropriately
Was this page helpful?
Yes
No
Progress
Sampling
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Roots
Root List Changes
Message Flow
Data Types
Root
Project Directory
Multiple Repositories
Error Handling
Security Considerations
Implementation Guidelines
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/client/sampling

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Client Features
Sampling
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Roots
Sampling
Elicitation
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Client Features
Copy page
Sampling
Protocol Revision
: draft
The Model Context Protocol (MCP) provides a standardized way for servers to request LLM
sampling (“completions” or “generations”) from language models via clients. This flow
allows clients to maintain control over model access, selection, and permissions while
enabling servers to leverage AI capabilities—with no server API keys necessary.
Servers can request text, audio, or image-based interactions and optionally include
context from MCP servers in their prompts.
​
User Interaction Model
Sampling in MCP allows servers to implement agentic behaviors, by enabling LLM calls to
occur
nested
inside other MCP server features.
Implementations are free to expose sampling through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny sampling requests.
Applications
SHOULD
:
Provide UI that makes it easy and intuitive to review sampling requests
Allow users to view and edit prompts before sending
Present generated responses for review before delivery
​
Capabilities
Clients that support sampling
MUST
declare the
sampling
capability during
initialization
:
Copy
{
"capabilities"
: {
"sampling"
: {}
}
}
​
Protocol Messages
​
Creating Messages
To request a language model generation, servers send a
sampling/createMessage
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"sampling/createMessage"
,
"params"
: {
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"What is the capital of France?"
}
}
],
"modelPreferences"
: {
"hints"
: [
{
"name"
:
"claude-3-sonnet"
}
],
"intelligencePriority"
:
0.8
,
"speedPriority"
:
0.5
},
"systemPrompt"
:
"You are a helpful assistant."
,
"maxTokens"
:
100
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"role"
:
"assistant"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"The capital of France is Paris."
},
"model"
:
"claude-3-sonnet-20240307"
,
"stopReason"
:
"endTurn"
}
}
​
Message Flow
​
Data Types
​
Messages
Sampling messages can contain:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"The message content"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/jpeg"
}
​
Audio Content
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
​
Model Preferences
Model selection in MCP requires careful abstraction since servers and clients may use
different AI providers with distinct model offerings. A server cannot simply request a
specific model by name since the client may not have access to that exact model or may
prefer to use a different provider’s equivalent model.
To solve this, MCP implements a preference system that combines abstract capability
priorities with optional model hints:
​
Capability Priorities
Servers express their needs through three normalized priority values (0-1):
costPriority
: How important is minimizing costs? Higher values prefer cheaper models.
speedPriority
: How important is low latency? Higher values prefer faster models.
intelligencePriority
: How important are advanced capabilities? Higher values prefer
more capable models.
​
Model Hints
While priorities help select models based on characteristics,
hints
allow servers to
suggest specific models or model families:
Hints are treated as substrings that can match model names flexibly
Multiple hints are evaluated in order of preference
Clients
MAY
map hints to equivalent models from different providers
Hints are advisory—clients make final model selection
For example:
Copy
{
"hints"
: [
{
"name"
:
"claude-3-sonnet"
},
// Prefer Sonnet-class models
{
"name"
:
"claude"
}
// Fall back to any Claude model
],
"costPriority"
:
0.3
,
// Cost is less important
"speedPriority"
:
0.8
,
// Speed is very important
"intelligencePriority"
:
0.5
// Moderate capability needs
}
The client processes these preferences to select an appropriate model from its available
options. For instance, if the client doesn’t have access to Claude models but has Gemini,
it might map the sonnet hint to
gemini-1.5-pro
based on similar capabilities.
​
Error Handling
Clients
SHOULD
return errors for common failure cases:
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"error"
: {
"code"
:
-1
,
"message"
:
"User rejected sampling request"
}
}
​
Security Considerations
Clients
SHOULD
implement user approval controls
Both parties
SHOULD
validate message content
Clients
SHOULD
respect model preference hints
Clients
SHOULD
implement rate limiting
Both parties
MUST
handle sensitive data appropriately
Was this page helpful?
Yes
No
Roots
Elicitation
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Creating Messages
Message Flow
Data Types
Messages
Text Content
Image Content
Audio Content
Model Preferences
Capability Priorities
Model Hints
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/index

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Protocol
Specification
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Protocol
Copy page
Specification
Model Context Protocol
(MCP) is an open protocol that
enables seamless integration between LLM applications and external data sources and
tools. Whether you’re building an AI-powered IDE, enhancing a chat interface, or creating
custom AI workflows, MCP provides a standardized way to connect LLMs with the context
they need.
This specification defines the authoritative protocol requirements, based on the
TypeScript schema in
schema.ts
.
For implementation guides and examples, visit
modelcontextprotocol.io
.
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD
NOT”, “RECOMMENDED”, “NOT RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be
interpreted as described in
BCP 14
[
RFC2119
]
[
RFC8174
] when, and only when, they
appear in all capitals, as shown here.
​
Overview
MCP provides a standardized way for applications to:
Share contextual information with language models
Expose tools and capabilities to AI systems
Build composable integrations and workflows
The protocol uses
JSON-RPC
2.0 messages to establish
communication between:
Hosts
: LLM applications that initiate connections
Clients
: Connectors within the host application
Servers
: Services that provide context and capabilities
MCP takes some inspiration from the
Language Server Protocol
, which
standardizes how to add support for programming languages across a whole ecosystem of
development tools. In a similar way, MCP standardizes how to integrate additional context
and tools into the ecosystem of AI applications.
​
Key Details
​
Base Protocol
JSON-RPC
message format
Stateful connections
Server and client capability negotiation
​
Features
Servers offer any of the following features to clients:
Resources
: Context and data, for the user or the AI model to use
Prompts
: Templated messages and workflows for users
Tools
: Functions for the AI model to execute
Clients may offer the following features to servers:
Sampling
: Server-initiated agentic behaviors and recursive LLM interactions
Roots
: Server-initiated inquiries into uri or filesystem boundaries to operate in
Elicitation
: Server-initiated requests for additional information from users
​
Additional Utilities
Configuration
Progress tracking
Cancellation
Error reporting
Logging
​
Security and Trust & Safety
The Model Context Protocol enables powerful capabilities through arbitrary data access
and code execution paths. With this power comes important security and trust
considerations that all implementors must carefully address.
​
Key Principles
User Consent and Control
Users must explicitly consent to and understand all data access and operations
Users must retain control over what data is shared and what actions are taken
Implementors should provide clear UIs for reviewing and authorizing activities
Data Privacy
Hosts must obtain explicit user consent before exposing user data to servers
Hosts must not transmit resource data elsewhere without user consent
User data should be protected with appropriate access controls
Tool Safety
Tools represent arbitrary code execution and must be treated with appropriate
caution.
In particular, descriptions of tool behavior such as annotations should be
considered untrusted, unless obtained from a trusted server.
Hosts must obtain explicit user consent before invoking any tool
Users should understand what each tool does before authorizing its use
LLM Sampling Controls
Users must explicitly approve any LLM sampling requests
Users should control:
Whether sampling occurs at all
The actual prompt that will be sent
What results the server can see
The protocol intentionally limits server visibility into prompts
​
Implementation Guidelines
While MCP itself cannot enforce these security principles at the protocol level,
implementors
SHOULD
:
Build robust consent and authorization flows into their applications
Provide clear documentation of security implications
Implement appropriate access controls and data protections
Follow security best practices in their integrations
Consider privacy implications in their feature designs
​
Learn More
Explore the detailed specification for each protocol component:
Architecture
Base Protocol
Server Features
Client Features
Contributing
Was this page helpful?
Yes
No
FAQs
Key Changes
github
On this page
Overview
Key Details
Base Protocol
Features
Additional Utilities
Security and Trust & Safety
Key Principles
Implementation Guidelines
Learn More
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/index

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Overview
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Overview
Protocol Revision
: draft
Servers provide the fundamental building blocks for adding context to language models via
MCP. These primitives enable rich interactions between clients, servers, and language
models:
Prompts
: Pre-defined templates or instructions that guide language model
interactions
Resources
: Structured data or content that provides additional context to the model
Tools
: Executable functions that allow models to perform actions or retrieve
information
Each primitive can be summarized in the following control hierarchy:
Primitive
Control
Description
Example
Prompts
User-controlled
Interactive templates invoked by user choice
Slash commands, menu options
Resources
Application-controlled
Contextual data attached and managed by the client
File contents, git history
Tools
Model-controlled
Functions exposed to the LLM to take actions
API POST requests, file writing
Explore these key primitives in more detail below:
Prompts
Resources
Tools
Was this page helpful?
Yes
No
Elicitation
Prompts
github
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/prompts

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Prompts
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Prompts
Protocol Revision
: draft
The Model Context Protocol (MCP) provides a standardized way for servers to expose prompt
templates to clients. Prompts allow servers to provide structured messages and
instructions for interacting with language models. Clients can discover available
prompts, retrieve their contents, and provide arguments to customize them.
​
User Interaction Model
Prompts are designed to be
user-controlled
, meaning they are exposed from servers to
clients with the intention of the user being able to explicitly select them for use.
Typically, prompts would be triggered through user-initiated commands in the user
interface, which allows users to naturally discover and invoke available prompts.
For example, as slash commands:
However, implementors are free to expose prompts through any interface pattern that suits
their needs—the protocol itself does not mandate any specific user interaction
model.
​
Capabilities
Servers that support prompts
MUST
declare the
prompts
capability during
initialization
:
Copy
{
"capabilities"
: {
"prompts"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available prompts changes.
​
Protocol Messages
​
Listing Prompts
To retrieve available prompts, clients send a
prompts/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"prompts/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"prompts"
: [
{
"name"
:
"code_review"
,
"title"
:
"Request Code Review"
,
"description"
:
"Asks the LLM to analyze code quality and suggest improvements"
,
"arguments"
: [
{
"name"
:
"code"
,
"description"
:
"The code to review"
,
"required"
:
true
}
]
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Getting a Prompt
To retrieve a specific prompt, clients send a
prompts/get
request. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"prompts/get"
,
"params"
: {
"name"
:
"code_review"
,
"arguments"
: {
"code"
:
"def hello():
\n
print('world')"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"description"
:
"Code review prompt"
,
"messages"
: [
{
"role"
:
"user"
,
"content"
: {
"type"
:
"text"
,
"text"
:
"Please review this Python code:
\n
def hello():
\n
print('world')"
}
}
]
}
}
​
List Changed Notification
When the list of available prompts changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/prompts/list_changed"
}
​
Message Flow
​
Data Types
​
Prompt
A prompt definition includes:
name
: Unique identifier for the prompt
title
: Optional human-readable name of the prompt for display purposes.
description
: Optional human-readable description
arguments
: Optional list of arguments for customization
​
PromptMessage
Messages in a prompt can contain:
role
: Either “user” or “assistant” to indicate the speaker
content
: One of the following content types:
​
Text Content
Text content represents plain text messages:
Copy
{
"type"
:
"text"
,
"text"
:
"The text content of the message"
}
This is the most common content type used for natural language interactions.
​
Image Content
Image content allows including visual information in messages:
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-image-data"
,
"mimeType"
:
"image/png"
}
The image data
MUST
be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where visual context is important.
​
Audio Content
Audio content allows including audio information in messages:
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
The audio data MUST be base64-encoded and include a valid MIME type. This enables
multi-modal interactions where audio context is important.
​
Embedded Resources
Embedded resources allow referencing server-side resources directly in messages:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"resource://example"
,
"name"
:
"example"
,
"title"
:
"My Example Resource"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
}
Resources can contain either text or binary (blob) data and
MUST
include:
A valid resource URI
The appropriate MIME type
Either text content or base64-encoded blob data
Embedded resources enable prompts to seamlessly incorporate server-managed content like
documentation, code samples, or other reference materials directly into the conversation
flow.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
validate prompt arguments before processing
Clients
SHOULD
handle pagination for large prompt lists
Both parties
SHOULD
respect capability negotiation
​
Security
Implementations
MUST
carefully validate all prompt inputs and outputs to prevent
injection attacks or unauthorized access to resources.
Was this page helpful?
Yes
No
Overview
Resources
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Prompts
Getting a Prompt
List Changed Notification
Message Flow
Data Types
Prompt
PromptMessage
Text Content
Image Content
Audio Content
Embedded Resources
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/resources

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Resources
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Resources
Protocol Revision
: draft
The Model Context Protocol (MCP) provides a standardized way for servers to expose
resources to clients. Resources allow servers to share data that provides context to
language models, such as files, database schemas, or application-specific information.
Each resource is uniquely identified by a
URI
.
​
User Interaction Model
Resources in MCP are designed to be
application-driven
, with host applications
determining how to incorporate context based on their needs.
For example, applications could:
Expose resources through UI elements for explicit selection, in a tree or list view
Allow the user to search through and filter available resources
Implement automatic context inclusion, based on heuristics or the AI model’s selection
However, implementations are free to expose resources through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support resources
MUST
declare the
resources
capability:
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
,
"listChanged"
:
true
}
}
}
The capability supports two optional features:
subscribe
: whether the client can subscribe to be notified of changes to individual
resources.
listChanged
: whether the server will emit notifications when the list of available
resources changes.
Both
subscribe
and
listChanged
are optional—servers can support neither,
either, or both:
Copy
{
"capabilities"
: {
"resources"
: {}
// Neither feature supported
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"subscribe"
:
true
// Only subscriptions supported
}
}
}
Copy
{
"capabilities"
: {
"resources"
: {
"listChanged"
:
true
// Only list change notifications supported
}
}
}
​
Protocol Messages
​
Listing Resources
To discover available resources, clients send a
resources/list
request. This operation
supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"resources"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"title"
:
"Rust Software Application Main File"
,
"description"
:
"Primary application entry point"
,
"mimeType"
:
"text/x-rust"
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Reading Resources
To retrieve resource contents, clients send a
resources/read
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"resources/read"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"contents"
: [
{
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"title"
:
"Rust Software Application Main File"
,
"mimeType"
:
"text/x-rust"
,
"text"
:
"fn main() {
\n
println!(
\"
Hello world!
\"
);
\n
}"
}
]
}
}
​
Resource Templates
Resource templates allow servers to expose parameterized resources using
URI templates
. Arguments may be
auto-completed through
the completion API
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"method"
:
"resources/templates/list"
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"result"
: {
"resourceTemplates"
: [
{
"uriTemplate"
:
"file:///{path}"
,
"name"
:
"Project Files"
,
"title"
:
"📁 Project Files"
,
"description"
:
"Access files in the project directory"
,
"mimeType"
:
"application/octet-stream"
}
]
}
}
​
List Changed Notification
When the list of available resources changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/list_changed"
}
​
Subscriptions
The protocol supports optional subscriptions to resource changes. Clients can subscribe
to specific resources and receive notifications when they change:
Subscribe Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"method"
:
"resources/subscribe"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
}
}
Update Notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/resources/updated"
,
"params"
: {
"uri"
:
"file:///project/src/main.rs"
,
"title"
:
"Rust Software Application Main File"
}
}
​
Message Flow
​
Data Types
​
Resource
A resource definition includes:
uri
: Unique identifier for the resource
name
: The name of the resource.
title
: Optional human-readable name of the resource for display purposes.
description
: Optional description
mimeType
: Optional MIME type
size
: Optional size in bytes
​
Resource Contents
Resources can contain either text or binary data:
​
Text Content
Copy
{
"uri"
:
"file:///example.txt"
,
"name"
:
"example.txt"
,
"title"
:
"Example Text File"
,
"mimeType"
:
"text/plain"
,
"text"
:
"Resource content"
}
​
Binary Content
Copy
{
"uri"
:
"file:///example.png"
,
"name"
:
"example.png"
,
"title"
:
"Example Image"
,
"mimeType"
:
"image/png"
,
"blob"
:
"base64-encoded-data"
}
​
Common URI Schemes
The protocol defines several standard URI schemes. This list not
exhaustive—implementations are always free to use additional, custom URI schemes.
​
https://
Used to represent a resource available on the web.
Servers
SHOULD
use this scheme only when the client is able to fetch and load the
resource directly from the web on its own—that is, it doesn’t need to read the resource
via the MCP server.
For other use cases, servers
SHOULD
prefer to use another URI scheme, or define a
custom one, even if the server will itself be downloading resource contents over the
internet.
​
file://
Used to identify resources that behave like a filesystem. However, the resources do not
need to map to an actual physical filesystem.
MCP servers
MAY
identify file:// resources with an
XDG MIME type
,
like
inode/directory
, to represent non-regular files (such as directories) that don’t
otherwise have a standard MIME type.
​
git://
Git version control integration.
​
Custom URI Schemes
Custom URI schemes
MUST
be in accordance with
RFC3986
,
taking the above guidance in to account.
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Resource not found:
-32002
Internal errors:
-32603
Example error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
5
,
"error"
: {
"code"
:
-32002
,
"message"
:
"Resource not found"
,
"data"
: {
"uri"
:
"file:///nonexistent.txt"
}
}
}
​
Security Considerations
Servers
MUST
validate all resource URIs
Access controls
SHOULD
be implemented for sensitive resources
Binary data
MUST
be properly encoded
Resource permissions
SHOULD
be checked before operations
Was this page helpful?
Yes
No
Prompts
Tools
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Resources
Reading Resources
Resource Templates
List Changed Notification
Subscriptions
Message Flow
Data Types
Resource
Resource Contents
Text Content
Binary Content
Common URI Schemes
https://
file://
git://
Custom URI Schemes
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/tools

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Server Features
Tools
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Server Features
Copy page
Tools
Protocol Revision
: draft
The Model Context Protocol (MCP) allows servers to expose tools that can be invoked by
language models. Tools enable models to interact with external systems, such as querying
databases, calling APIs, or performing computations. Each tool is uniquely identified by
a name and includes metadata describing its schema.
​
User Interaction Model
Tools in MCP are designed to be
model-controlled
, meaning that the language model can
discover and invoke tools automatically based on its contextual understanding and the
user’s prompts.
However, implementations are free to expose tools through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
For trust & safety and security, there
SHOULD
always
be a human in the loop with the ability to deny tool invocations.
Applications
SHOULD
:
Provide UI that makes clear which tools are being exposed to the AI model
Insert clear visual indicators when tools are invoked
Present confirmation prompts to the user for operations, to ensure a human is in the
loop
​
Capabilities
Servers that support tools
MUST
declare the
tools
capability:
Copy
{
"capabilities"
: {
"tools"
: {
"listChanged"
:
true
}
}
}
listChanged
indicates whether the server will emit notifications when the list of
available tools changes.
​
Protocol Messages
​
Listing Tools
To discover available tools, clients send a
tools/list
request. This operation supports
pagination
.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"tools/list"
,
"params"
: {
"cursor"
:
"optional-cursor-value"
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"tools"
: [
{
"name"
:
"get_weather"
,
"title"
:
"Weather Information Provider"
,
"description"
:
"Get current weather information for a location"
,
"inputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"location"
: {
"type"
:
"string"
,
"description"
:
"City name or zip code"
}
},
"required"
: [
"location"
]
}
}
],
"nextCursor"
:
"next-page-cursor"
}
}
​
Calling Tools
To invoke a tool, clients send a
tools/call
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"method"
:
"tools/call"
,
"params"
: {
"name"
:
"get_weather"
,
"arguments"
: {
"location"
:
"New York"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
2
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Current weather in New York:
\n
Temperature: 72°F
\n
Conditions: Partly cloudy"
}
],
"isError"
:
false
}
}
​
List Changed Notification
When the list of available tools changes, servers that declared the
listChanged
capability
SHOULD
send a notification:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/tools/list_changed"
}
​
Message Flow
​
Data Types
​
Tool
A tool definition includes:
name
: Unique identifier for the tool
title
: Optional human-readable name of the tool for display purposes.
description
: Human-readable description of functionality
inputSchema
: JSON Schema defining expected parameters
outputSchema
: Optional JSON Schema defining expected output structure
annotations
: optional properties describing tool behavior
For trust & safety and security, clients
MUST
consider
tool annotations to be untrusted unless they come from trusted servers.
​
Tool Result
Tool results may contain
structured
or
unstructured
content.
Unstructured
content is returned in the
content
field of a result, and can contain multiple content items of different types:
​
Text Content
Copy
{
"type"
:
"text"
,
"text"
:
"Tool result text"
}
​
Image Content
Copy
{
"type"
:
"image"
,
"data"
:
"base64-encoded-data"
,
"mimeType"
:
"image/png"
}
​
Audio Content
Copy
{
"type"
:
"audio"
,
"data"
:
"base64-encoded-audio-data"
,
"mimeType"
:
"audio/wav"
}
​
Resource Links
A tool
MAY
return links to
Resources
, to provide additional context
or data. In this case, the tool will return a URI that can be subscribed to or fetched by the client:
Copy
{
"type"
:
"resource_link"
,
"uri"
:
"file:///project/src/main.rs"
,
"name"
:
"main.rs"
,
"description"
:
"Primary application entry point"
,
"mimeType"
:
"text/x-rust"
}
Resource links returned by tools are not guaranteed to appear in the results
of a
resources/list
request.
​
Embedded Resources
Resources
MAY
be embedded to provide additional context
or data using a suitable
URI scheme
. Servers that use embedded resources
SHOULD
implement the
resources
capability:
Copy
{
"type"
:
"resource"
,
"resource"
: {
"uri"
:
"file:///project/src/main.rs"
,
"title"
:
"Project Rust Main File"
,
"mimeType"
:
"text/x-rust"
,
"text"
:
"fn main() {
\n
println!(
\"
Hello world!
\"
);
\n
}"
}
}
​
Structured Content
Structured
content is returned as a JSON object in the
structuredContent
field of a result.
For backwards compatibility, a tool that returns structured content SHOULD also return functionally equivalent unstructured content.
(For example, serialized JSON can be returned in a
TextContent
block.)
​
Output Schema
Tools may also provide an output schema for validation of structured results.
If an output schema is provided:
Servers
MUST
provide structured results that conform to this schema.
Clients
SHOULD
validate structured results against this schema.
Example tool with output schema:
Copy
{
"name"
:
"get_weather_data"
,
"title"
:
"Weather Data Retriever"
,
"description"
:
"Get current weather data for a location"
,
"inputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"location"
: {
"type"
:
"string"
,
"description"
:
"City name or zip code"
}
},
"required"
: [
"location"
]
},
"outputSchema"
: {
"type"
:
"object"
,
"properties"
: {
"temperature"
: {
"type"
:
"number"
,
"description"
:
"Temperature in celsius"
},
"conditions"
: {
"type"
:
"string"
,
"description"
:
"Weather conditions description"
},
"humidity"
: {
"type"
:
"number"
,
"description"
:
"Humidity percentage"
}
},
"required"
: [
"temperature"
,
"conditions"
,
"humidity"
]
}
}
Example valid response for this tool:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
5
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"{
\"
temperature
\"
: 22.5,
\"
conditions
\"
:
\"
Partly cloudy
\"
,
\"
humidity
\"
: 65}"
}
],
"structuredContent"
: {
"temperature"
:
22.5
,
"conditions"
:
"Partly cloudy"
,
"humidity"
:
65
}
}
}
Providing an output schema helps clients and LLMs understand and properly handle structured tool outputs by:
Enabling strict schema validation of responses
Providing type information for better integration with programming languages
Guiding clients and LLMs to properly parse and utilize the returned data
Supporting better documentation and developer experience
​
Error Handling
Tools use two error reporting mechanisms:
Protocol Errors
: Standard JSON-RPC errors for issues like:
Unknown tools
Invalid arguments
Server errors
Tool Execution Errors
: Reported in tool results with
isError: true
:
API failures
Invalid input data
Business logic errors
Example protocol error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
3
,
"error"
: {
"code"
:
-32602
,
"message"
:
"Unknown tool: invalid_tool_name"
}
}
Example tool execution error:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
4
,
"result"
: {
"content"
: [
{
"type"
:
"text"
,
"text"
:
"Failed to fetch weather data: API rate limit exceeded"
}
],
"isError"
:
true
}
}
​
Security Considerations
Servers
MUST
:
Validate all tool inputs
Implement proper access controls
Rate limit tool invocations
Sanitize tool outputs
Clients
SHOULD
:
Prompt for user confirmation on sensitive operations
Show tool inputs to the user before calling the server, to avoid malicious or
accidental data exfiltration
Validate tool results before passing to LLM
Implement timeouts for tool calls
Log tool usage for audit purposes
Was this page helpful?
Yes
No
Resources
Completion
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Listing Tools
Calling Tools
List Changed Notification
Message Flow
Data Types
Tool
Tool Result
Text Content
Image Content
Audio Content
Resource Links
Embedded Resources
Structured Content
Output Schema
Error Handling
Security Considerations
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/utilities/completion

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Completion
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Completion
Protocol Revision
: draft
The Model Context Protocol (MCP) provides a standardized way for servers to offer
argument autocompletion suggestions for prompts and resource URIs. This enables rich,
IDE-like experiences where users receive contextual suggestions while entering argument
values.
​
User Interaction Model
Completion in MCP is designed to support interactive user experiences similar to IDE code
completion.
For example, applications may show completion suggestions in a dropdown or popup menu as
users type, with the ability to filter and select from available options.
However, implementations are free to expose completion through any interface pattern that
suits their needs—the protocol itself does not mandate any specific user
interaction model.
​
Capabilities
Servers that support completions
MUST
declare the
completions
capability:
Copy
{
"capabilities"
: {
"completions"
: {}
}
}
​
Protocol Messages
​
Requesting Completions
To get completion suggestions, clients send a
completion/complete
request specifying
what is being completed through a reference type:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"completion/complete"
,
"params"
: {
"ref"
: {
"type"
:
"ref/prompt"
,
"name"
:
"code_review"
},
"argument"
: {
"name"
:
"language"
,
"value"
:
"py"
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"completion"
: {
"values"
: [
"python"
,
"pytorch"
,
"pyside"
],
"total"
:
10
,
"hasMore"
:
true
}
}
}
For prompts or URI templates with multiple arguments, clients should include previous completions in the
context.arguments
object to provide context for subsequent requests.
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"completion/complete"
,
"params"
: {
"ref"
: {
"type"
:
"ref/prompt"
,
"name"
:
"code_review"
},
"argument"
: {
"name"
:
"framework"
,
"value"
:
"fla"
},
"context"
: {
"arguments"
: {
"language"
:
"python"
}
}
}
}
Response:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"result"
: {
"completion"
: {
"values"
: [
"flask"
],
"total"
:
1
,
"hasMore"
:
false
}
}
}
​
Reference Types
The protocol supports two types of completion references:
Type
Description
Example
ref/prompt
References a prompt by name
{"type": "ref/prompt", "name": "code_review"}
ref/resource
References a resource URI
{"type": "ref/resource", "uri": "file:///{path}"}
​
Completion Results
Servers return an array of completion values ranked by relevance, with:
Maximum 100 items per response
Optional total number of available matches
Boolean indicating if additional results exist
​
Message Flow
​
Data Types
​
CompleteRequest
ref
: A
PromptReference
or
ResourceReference
argument
: Object containing:
name
: Argument name
value
: Current value
context
: Object containing:
arguments
: A mapping of already-resolved argument names to their values.
​
CompleteResult
completion
: Object containing:
values
: Array of suggestions (max 100)
total
: Optional total matches
hasMore
: Additional results flag
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Method not found:
-32601
(Capability not supported)
Invalid prompt name:
-32602
(Invalid params)
Missing required arguments:
-32602
(Invalid params)
Internal errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Return suggestions sorted by relevance
Implement fuzzy matching where appropriate
Rate limit completion requests
Validate all inputs
Clients
SHOULD
:
Debounce rapid completion requests
Cache completion results where appropriate
Handle missing or partial results gracefully
​
Security
Implementations
MUST
:
Validate all completion inputs
Implement appropriate rate limiting
Control access to sensitive suggestions
Prevent completion-based information disclosure
Was this page helpful?
Yes
No
Tools
Logging
github
On this page
User Interaction Model
Capabilities
Protocol Messages
Requesting Completions
Reference Types
Completion Results
Message Flow
Data Types
CompleteRequest
CompleteResult
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/utilities/logging

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Logging
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Logging
Protocol Revision
: draft
The Model Context Protocol (MCP) provides a standardized way for servers to send
structured log messages to clients. Clients can control logging verbosity by setting
minimum log levels, with servers sending notifications containing severity levels,
optional logger names, and arbitrary JSON-serializable data.
​
User Interaction Model
Implementations are free to expose logging through any interface pattern that suits their
needs—the protocol itself does not mandate any specific user interaction model.
​
Capabilities
Servers that emit log message notifications
MUST
declare the
logging
capability:
Copy
{
"capabilities"
: {
"logging"
: {}
}
}
​
Log Levels
The protocol follows the standard syslog severity levels specified in
RFC 5424
:
Level
Description
Example Use Case
debug
Detailed debugging information
Function entry/exit points
info
General informational messages
Operation progress updates
notice
Normal but significant events
Configuration changes
warning
Warning conditions
Deprecated feature usage
error
Error conditions
Operation failures
critical
Critical conditions
System component failures
alert
Action must be taken immediately
Data corruption detected
emergency
System is unusable
Complete system failure
​
Protocol Messages
​
Setting Log Level
To configure the minimum log level, clients
MAY
send a
logging/setLevel
request:
Request:
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
1
,
"method"
:
"logging/setLevel"
,
"params"
: {
"level"
:
"info"
}
}
​
Log Message Notifications
Servers send log messages using
notifications/message
notifications:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"notifications/message"
,
"params"
: {
"level"
:
"error"
,
"logger"
:
"database"
,
"data"
: {
"error"
:
"Connection failed"
,
"details"
: {
"host"
:
"localhost"
,
"port"
:
5432
}
}
}
}
​
Message Flow
​
Error Handling
Servers
SHOULD
return standard JSON-RPC errors for common failure cases:
Invalid log level:
-32602
(Invalid params)
Configuration errors:
-32603
(Internal error)
​
Implementation Considerations
Servers
SHOULD
:
Rate limit log messages
Include relevant context in data field
Use consistent logger names
Remove sensitive information
Clients
MAY
:
Present log messages in the UI
Implement log filtering/search
Display severity visually
Persist log messages
​
Security
Log messages
MUST NOT
contain:
Credentials or secrets
Personal identifying information
Internal system details that could aid attacks
Implementations
SHOULD
:
Rate limit messages
Validate all data fields
Control log access
Monitor for sensitive content
Was this page helpful?
Yes
No
Completion
Pagination
github
On this page
User Interaction Model
Capabilities
Log Levels
Protocol Messages
Setting Log Level
Log Message Notifications
Message Flow
Error Handling
Implementation Considerations
Security
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/draft/server/utilities/pagination

Model Context Protocol
home page
Draft
Search...
⌘
K
GitHub
Search...
Navigation
Utilities
Pagination
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Overview
Prompts
Resources
Tools
Utilities
Completion
Logging
Pagination
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Utilities
Copy page
Pagination
Protocol Revision
: draft
The Model Context Protocol (MCP) supports paginating list operations that may return
large result sets. Pagination allows servers to yield results in smaller chunks rather
than all at once.
Pagination is especially important when connecting to external services over the
internet, but also useful for local integrations to avoid performance issues with large
data sets.
​
Pagination Model
Pagination in MCP uses an opaque cursor-based approach, instead of numbered pages.
The
cursor
is an opaque string token, representing a position in the result set
Page size
is determined by the server, and clients
MUST NOT
assume a fixed page
size
​
Response Format
Pagination starts when the server sends a
response
that includes:
The current page of results
An optional
nextCursor
field if more results exist
Copy
{
"jsonrpc"
:
"2.0"
,
"id"
:
"123"
,
"result"
: {
"resources"
: [
...
],
"nextCursor"
:
"eyJwYWdlIjogM30="
}
}
​
Request Format
After receiving a cursor, the client can
continue
paginating by issuing a request
including that cursor:
Copy
{
"jsonrpc"
:
"2.0"
,
"method"
:
"resources/list"
,
"params"
: {
"cursor"
:
"eyJwYWdlIjogMn0="
}
}
​
Pagination Flow
​
Operations Supporting Pagination
The following MCP operations support pagination:
resources/list
- List available resources
resources/templates/list
- List resource templates
prompts/list
- List available prompts
tools/list
- List available tools
​
Implementation Guidelines
Servers
SHOULD
:
Provide stable cursors
Handle invalid cursors gracefully
Clients
SHOULD
:
Treat a missing
nextCursor
as the end of results
Support both paginated and non-paginated flows
Clients
MUST
treat cursors as opaque tokens:
Don’t make assumptions about cursor format
Don’t attempt to parse or modify cursors
Don’t persist cursors across sessions
​
Error Handling
Invalid cursors
SHOULD
result in an error with code -32602 (Invalid params).
Was this page helpful?
Yes
No
Logging
Versioning
github
On this page
Pagination Model
Response Format
Request Format
Pagination Flow
Operations Supporting Pagination
Implementation Guidelines
Error Handling
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/specification/versioning

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Development
Versioning
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Development
Copy page
Versioning
The Model Context Protocol uses string-based version identifiers following the format
YYYY-MM-DD
, to indicate the last date backwards incompatible changes were made.
The protocol version will
not
be incremented when the
protocol is updated, as long as the changes maintain backwards compatibility. This allows
for incremental improvements while preserving interoperability.
​
Revisions
Revisions may be marked as:
Draft
: in-progress specifications, not yet ready for consumption.
Current
: the current protocol version, which is ready for use and may continue to
receive backwards compatible changes.
Final
: past, complete specifications that will not be changed.
The
current
protocol version is
2025-06-18
.
​
Negotiation
Version negotiation happens during
initialization
. Clients and
servers
MAY
support multiple protocol versions simultaneously, but they
MUST
agree on a single version to use for the session.
The protocol provides appropriate error handling if version negotiation fails, allowing
clients to gracefully terminate connections when they cannot find a version compatible
with the server.
Was this page helpful?
Yes
No
Pagination
Roadmap
github
On this page
Revisions
Negotiation
Assistant
Responses are generated using AI and may contain mistakes.

---

URL: https://modelcontextprotocol.io/tutorials/building-mcp-with-llms

Model Context Protocol
home page
Version 2025-06-18 (latest)
Search...
⌘
K
GitHub
Search...
Navigation
Tutorials
Building MCP with LLMs
User Guide
Introduction
Quickstart
Concepts
Examples
Tutorials
Building MCP with LLMs
Debugging
Inspector
FAQs
Protocol
Specification
Key Changes
Architecture
Base Protocol
Client Features
Server Features
Development
Versioning
Roadmap
Contributing
SDKs
C# SDK
Java SDK
Kotlin SDK
Python SDK
Ruby SDK
Swift SDK
TypeScript SDK
Tutorials
Copy page
Building MCP with LLMs
Speed up your MCP development using LLMs such as Claude!
This guide will help you use LLMs to help you build custom Model Context Protocol (MCP) servers and clients. We’ll be focusing on Claude for this tutorial, but you can do this with any frontier LLM.
​
Preparing the documentation
Before starting, gather the necessary documentation to help Claude understand MCP:
Visit
https://modelcontextprotocol.io/llms-full.txt
and copy the full documentation text
Navigate to either the
MCP TypeScript SDK
or
Python SDK repository
Copy the README files and other relevant documentation
Paste these documents into your conversation with Claude
​
Describing your server
Once you’ve provided the documentation, clearly describe to Claude what kind of server you want to build. Be specific about:
What resources your server will expose
What tools it will provide
Any prompts it should offer
What external systems it needs to interact with
For example:
Copy
Build an MCP server that:
- Connects to my company's PostgreSQL database
- Exposes table schemas as resources
- Provides tools for running read-only SQL queries
- Includes prompts for common data analysis tasks
​
Working with Claude
When working with Claude on MCP servers:
Start with the core functionality first, then iterate to add more features
Ask Claude to explain any parts of the code you don’t understand
Request modifications or improvements as needed
Have Claude help you test the server and handle edge cases
Claude can help implement all the key MCP features:
Resource management and exposure
Tool definitions and implementations
Prompt templates and handlers
Error handling and logging
Connection and transport setup
​
Best practices
When building MCP servers with Claude:
Break down complex servers into smaller pieces
Test each component thoroughly before moving on
Keep security in mind - validate inputs and limit access appropriately
Document your code well for future maintenance
Follow MCP protocol specifications carefully
​
Next steps
After Claude helps you build your server:
Review the generated code carefully
Test the server with the MCP Inspector tool
Connect it to Claude.app or other MCP clients
Iterate based on real usage and feedback
Remember that Claude can help you modify and improve your server as requirements change over time.
Need more guidance? Just ask Claude specific questions about implementing MCP features or troubleshooting issues that arise.
Was this page helpful?
Yes
No
Example Clients
Debugging
github
On this page
Preparing the documentation
Describing your server
Working with Claude
Best practices
Next steps
Assistant
Responses are generated using AI and may contain mistakes.